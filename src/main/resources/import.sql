INSERT INTO user (id, username, password, name, email) VALUES (1, 'admin', '$2a$10$N.zmdr9k7uOCQb376NoUnuTJ8iAt6Z5EHsM8lE9lBOsl7iKTVKIUi', '管理员', '592470146@qq.com');
INSERT INTO user (id, username, password, name, email)  VALUES (2, 'hsiaolung', '$2a$10$N.zmdr9k7uOCQb376NoUnuTJ8iAt6Z5EHsM8lE9lBOsl7iKTVKIUi', '骁龙', '123456789@qq.com');
INSERT INTO user (id, username, password, name, email)  VALUES (3, 'mengpu', '$2a$10$N.zmdr9k7uOCQb376NoUnuTJ8iAt6Z5EHsM8lE9lBOsl7iKTVKIUi', '孟普', '33928527@qq.com');
INSERT INTO user (id, username, password, name, email)  VALUES (4, 'yangyuanlei', '$2a$10$N.zmdr9k7uOCQb376NoUnuTJ8iAt6Z5EHsM8lE9lBOsl7iKTVKIUi', '杨元磊', '765867228@qq.com');
INSERT INTO user (id, username, password, name, email)  VALUES (5, 'chenyingjun', '$2a$10$N.zmdr9k7uOCQb376NoUnuTJ8iAt6Z5EHsM8lE9lBOsl7iKTVKIUi', '陈英俊', '468625758@qq.com');
INSERT INTO user (id, username, password, name, email)  VALUES (6, 'huangshuhua', '$2a$10$N.zmdr9k7uOCQb376NoUnuTJ8iAt6Z5EHsM8lE9lBOsl7iKTVKIUi', '黄淑华', '796828192@qq.com');
INSERT INTO user (id, username, password, name, email)  VALUES (7, 'zhangyekai', '$2a$10$N.zmdr9k7uOCQb376NoUnuTJ8iAt6Z5EHsM8lE9lBOsl7iKTVKIUi', '张叶凯', '897267891@qq.com');

INSERT INTO authority (id, name) VALUES (1, 'ROLE_ADMIN');
INSERT INTO authority (id, name) VALUES (2, 'ROLE_USER');

INSERT INTO user_authority(user_id, authority_id) VALUES (1, 1);
INSERT INTO user_authority(user_id, authority_id) VALUES (2, 2);
INSERT INTO user_authority(user_id, authority_id) VALUES (3, 2);
INSERT INTO user_authority(user_id, authority_id) VALUES (4, 2);
INSERT INTO user_authority(user_id, authority_id) VALUES (5, 2);
INSERT INTO user_authority(user_id, authority_id) VALUES (6, 2);
INSERT INTO user_authority(user_id, authority_id) VALUES (7, 2);

INSERT INTO catalog VALUES (1, '算法', 2);
INSERT INTO catalog VALUES (2, '数据库', 2);
INSERT INTO catalog VALUES (3, '网络', 2);
INSERT INTO catalog VALUES (4, '缓存', 3);
INSERT INTO catalog VALUES (5, '工具', 4);
INSERT INTO catalog VALUES (6, '网站架构', 5);

INSERT INTO vote VALUES (1, '2019-02-16 11:36:35', 2);
INSERT INTO vote VALUES (2, '2019-02-16 11:38:10', 2);
INSERT INTO vote VALUES (3, '2019-02-16 11:39:12', 2);
INSERT INTO vote VALUES (4, '2019-02-16 11:41:41', 3);
INSERT INTO vote VALUES (5, '2019-02-16 11:43:34', 4);
INSERT INTO vote VALUES (6, '2019-02-16 11:44:06', 4);

INSERT INTO comment VALUES (1, '写的很好', '2019-02-16 11:40:08', 3);
INSERT INTO comment VALUES (2, '学习一个', '2019-02-16 11:40:21', 3);
INSERT INTO comment VALUES (3, '很实用', '2019-02-16 11:40:32', 3);
INSERT INTO comment VALUES (4, '666', '2019-02-16 11:44:15', 4);
INSERT INTO comment VALUES (5, '好！', '2019-02-16 11:44:42', 4);
INSERT INTO comment VALUES (6, '666', '2019-02-16 11:44:56', 4);
INSERT INTO comment VALUES (7, '很好', '2019-02-16 11:45:13', 4);
INSERT INTO comment VALUES (8, '666', '2019-02-16 11:48:10', 5);
INSERT INTO comment VALUES (9, '学习一个', '2019-02-16 11:48:34', 5);
INSERT INTO comment VALUES (10, '明天去面试，刚好看到这篇文章', '2019-02-16 11:48:54', 5);
INSERT INTO comment VALUES (11, '很全面', '2019-02-16 11:49:03', 5);
INSERT INTO comment VALUES (12, '写的太好了', '2019-02-16 11:49:19', 5);
INSERT INTO comment VALUES (13, '真棒', '2019-02-16 11:49:35', 5);

INSERT INTO blog VALUES (1, 3, '## 一、基础知识\n\n### 1.1 问题求解的关键\n\n- **建模**：对输入参数和解给出形式化和版形式化的描述\n- **设计算法**：采用算法设计技术满足对所有的实例都获得正确解\n- **分析算法**：效率\n\n### 1.2 算法及其时间复杂度\n\n- **算法**：有限条指令的序列，每步的计算是确定性的，能够再有限步结束算法，输出实例的正确解\n- **算法时间复杂度**：针对基本运算，计算算法所作的运算次数\n- **时间复杂度种类**\n  - 最坏时间复杂度\n  - 平均时间复杂度\n\n### 1.3 算法的伪码表示\n\n- **赋值语句**：←\n- **分支语句**：if ... then ... [else ...]\n- **循环语句**：while,for\n- **转向语句**：goto\n- **输出语句**：return\n- **调用**：直接写过程的名字\n- **注释**：//\n- **向上取整**：⌈ ⌉ \n- **向下取整**：⌊ ⌋ \n\n## 二、算法的数学基础\n\n### 2.1  递归树\n\n- **概念**： 递归树是迭代计算的模型，递归树的生成过程和迭代过程一致，树上所有项恰好是迭代之后产生和式值中的项，对递归树上的项求和就是迭代后方程的解\n- **生成规则**\n  - 初始，递归树只有根节点，其值为W(n)\n  - 不断继续下述过程：将函数项叶节点的迭代式W(m)表示成二层子树，用改子树代替叶节点\n  - 继续递归树的生成，直到树中无函数项\n\n### 2.2 主定理\n\n- **递推方程**：对于递推方程：T(n)=a*T(n/b)+f(n)，其中a为归约后的子问题个数，n/b为归约后子问题的规模，f(n)为归约过程及组合子问题的解的工作量，如二分检索的地推方程为：T(n)=T(n/2)+1，二分归并排序的递推方程为：T(n)=2T(n/2)+n-1\n\n- **主定理**：若递推公式满足T(n)=a*T(n/b)+f(n)，则：\n\n  - 若f(n)中n的阶小于log_ba，那么时间复杂度为n^(/log_ba)\n\n  - 若f(n)中n的阶等于log_ba，那么时间复杂度为(n^(/log_ba)*logn)\n  - 若f(n)中n的阶大于log_ba，那么时间复杂度为f(n)\n\n## 三、分治算法\n\n### 3.1 分治策略的基本思想\n\n- **分治策略**\n\n  - 将原问题划分为规模较小的子问题\n  - 递归或者迭代求解每个子问题\n  - 将子问题的解综合得到原问题的解\n\n- **注意**\n\n  - 子问题与原问题性质完全一样\n  - 子问题之间可以彼此独立的求解\n  - 递归停止时子问题可以直接求解\n\n- **排列问题**\n\n  - 第一种分析思路\n\n    - 分析：假设元素个数n=1，全排列只有这一个元素，假设n>1，对于每个元素规模为n的数组的全排列是轮流取出这n个元素的一个作为前缀，其他n-1个元素的全排列作为后缀（一棵n叉树）\n\n    - 输入：数组T，全排列起始元素序号l，全排列终止元素序号r\n\n    - 输出：前缀是T[0:l-1]，后缀是T[l-1,r]的全排列的所有排列\n\n    - Java实现代码\n\n      java\n      public static void perm(int []T,int l,int r){\n          //如果已经产生了全排列，就打印出来\n          if(l==r){\n              for(int i=0;i<r;i++){\n                  System.out.println(T[i]);\n              }\n          }\n          else\n          	//轮流取出数组T下标为l到r之间的元素作为前缀，下标为l到r之间的其他元素的全排列作为后缀\n              for(int i=l;i<=r;i++){\n                  swap(T,i,l);\n                  perm(T,l+1,m);\n                  swap(T,i,l);\n              }\n          }\n      }\n      \n\n  - 第二种分析思路\n\n    - 分析：当m=1时，全排列为T[0]这个元素，当m>1时，全排列为前m-1个元素的全排列的每种排列方式又可以分为在每种排列方式的每个元素前面分别插入第m个元素和最后一个元素后面插入第m个元素这n种情况。如数组[1,2,3]，当m=1时，全排列只有{[1]}这一种情况，当m=2时，对于m=1的每个全排列又能分为将元素2插入1的前面和后面，情况有{[1,2],[2,1]}两种全排列，当m=3时，对于m=2的每种情况又能分为将元素3插入每个元素的前面和后面，情况有{[3,1,2],[1,3,2],[1,2,3],[3,2,1],[2,3,1],[2,1,3]}\n\n    - 输入：数组a，全排列结束位置m\n\n    - 输出：一个List，List的每个元素也为一个存储一种全排列的List\n\n    - Java实现代码\n\n      java\n      public static List<List> perm(int a[],int m){\n      		//当m=0，只有一个元素时，全排列为a[0]\n              if(m==0){\n                  List numList=new ArrayList();\n                  List listList=new ArrayList();\n                  numList.add(a[0]);\n                  listList.add(numList);\n                  return listList;\n              }\n            	//当m>1对数组的m个元素进行全排列\n              else {\n              	//取出前m-1个元素的全排列\n                  List listList=perm(a,m-1);\n                  //新建一个存储全排列List的List\n                  List newListList=new ArrayList();\n                  //分别取出m-1个元素的每个全排列\n                  for(int i=0;i<listList.size();i++){\n                      List numList= (List) listList.get(i);\n                      //对于前m-1个元素的每个全排列，分别将第m个元素插入到全排列每个元素的前面以及最后一个元素的后面形成m个新的全排列\n                      for(int j=0;j<=numList.size();j++){\n                          List newNumList=new ArrayList();\n                          for(int k=0;k<numList.size();k++){\n                              if(k==j){\n                                  newNumList.add(a[m]);\n                              }\n                              newNumList.add(numList.get(k));\n                          }\n                          if(j==numList.size()){\n                              newNumList.add(a[m]);\n                          }\n                          newListList.add(newNumList);\n                      }\n                  }\n                  return newListList;\n              }\n          }\n      \n\n-  **整数划分问题**\n\n  - 分析：将要划分的整数设为n，划分时式子中最大的数小于m，将n划分为一系列整数之和，整数种最大值小于m的划分个数记作q(n,m)\n\n    - 当m=1时，q(n,m)=1，n由n个1组成，只有一种情况\n    - 当m>n时，q(n,m)=q(n,n)，若是m大于n，则总划分数还是q(n,n)\n    - 当m=n时，q(n,n)=1+q(n,n-1)，若是m等于n，总划分数为m为n-1时的总划分数加上只能划分为n这一种情况之和\n    - 当m<n时，q(n,m)=q(n,m-1)+q(n-m,m)，当m<n时，总划分数位m-1时的总划分时加上m=m时的划分数，而当m=m时的划分数其实是将n-m划分，m为上限的划分数。如将6划分，式子中最大数都小于4时的总划分数等于式子中最大数都小于3时的总划分数加上式子中最大值等于4时的总划分数。式子中最大值等于4的总划分数其实等于将2划分，式子中最大值小于4的总划分数\n\n  - 输入：被划分数n，划分式子中最大值小于m\n\n  - 输出：将n划分为一系列整数之和，整数中最大值小于m的划分个数q(n,m)\n\n  - Java代码\n\n    java\n    public staitc int q(n,m){\n        if(m==1)\n        	return 1;\n        else if(m>n)\n        	return q(n,n);\n        else if(m==n)\n        	return 1+q(n,n-1);\n        else\n        	return q(n,m-1)+q(n-m,m);\n    }\n    \n\n- **二分检索算法 BinarySearch(T,l,r,x)**\n\n  - 输入：已排序数组T，下标从l到r，查找元素x\n\n  - 输出：元素x的下标，如果没找到输出-1\n\n    java\n    public static int BinarySearch(int []T,int l,int r,int x){\n        if(l==r)\n            if(T[l]==x)\n                return x;\n        	else\n                return -1;\n        m=(l+r)/2;\n        if(T[m]==x)\n        	return m;\n        else if(T[m]>x)\n        	return BinarySearch(T,l,m,x);\n        else \n            return BinarySearch(T,m,r,x);\n    }\n    \n\n- **二分归并排序 MergeSort(A,p,r)**\n\n  - 输入：数组A[p...r]\n\n  - 输出：元素按从小到大排序的数组A\n\n  - 算法伪码\n\n    pseudocode\n    if p<r\n    then q←⌊(p+r)/2⌋           //对半划分\n    	MergeSort(A,p,q);	  //子问题1\n    	MergeSort(A,q+1,r)	  //子问题2\n    	Merge(A,p,q,r);		  //综合解\n    \n\n- **汉诺塔的递归算法 ** \n\n  - 输入：盘子的原始底座A，盘子的目标底座C，盘子的数量n\n\n  - 输出：盘子的移动顺序\n\n  - Java代码\n\n    java\n    public static void hanio(int n,char a,char c){\n        if(n==1)\n        	move(a,c);\n        else\n        	hanio(n-1,a,b);\n        	move(a,c);\n        	hanio(n-1,b,c);\n    }\n    \n\n- **分治算法的特点**\n\n  - 将原问题归约为规模小的子问题，子问题与原问题具有相同的性质\n  - 子问题规模足够小时可以直接求解\n  - 算法可以递归或者迭代实现\n\n### 3.2 分治算法的一般性描述\n\n- **分治算法 Divide-and-Conquer(P)**\n\n  pseudocode\n  //如果问题P的规模很小时，采用直接求解算法S(P)求解\n  if |P|<=c then S(P)\n  //如果问题P的规模足够大时，将问题P分解为若干个子问题\n  divide P into P_1,P_2,...P_k\n  //迭代或递归求解子问题\n  for i←1 to k\n  	y_i←Divide-and-Conquer(P_i)\n  //合并子问题的解\n  return Merge(y_1,y_2,...y_n)\n  \n\n### 3.3 芯片测试\n\n- **测试方法**：将2片芯片放于测试台上，互相进行测试，测试报告是“好”或“坏”，好芯片的报告一定是正确的，坏芯片的报告一定是坏的\n\n- **测试结果分析**\n\n  |  A报告  |  B报告  |            结论            |\n  | :-----: | :-----: | :------------------------: |\n  | B是好的 | A是好的 | A、B都是好的或A、B都是坏的 |\n  | B是好的 | A是坏的 |       至少一个是坏的       |\n  | B是坏的 | A是好的 |       至少一个是坏的       |\n  | B是坏的 | A是坏的 |       至少一个是坏的       |\n\n- **输入**：n片芯片，其中好芯片至少比坏芯片多一片\n\n- **问题**：设计一种测试方法，通过测试从n片芯片中挑选出一片好芯片，要求最少的测试次数\n\n- **算法设计思想**：假设n为偶数，将n个芯片两两一组做测试淘汰，剩下芯片构成子问题进入下一轮测试，淘汰规则为若两片芯片的报告都是好，则任留一片芯片进入下一轮，若两片芯片的报告是其他情况，则全部丢弃。递归截止条件为当n<=3时，选出其中两片进行测试，如果一好一坏，选择剩余的一片芯片，如果都是好，选择其中一片芯片即可；当n为奇数时，先将最后一片芯片使用其他芯片对其进行测试，如果是好的，则取这片芯片，如果是坏的，则丢弃这片芯片，其他芯片进行分治测试\n\n- **伪码描述**\n\n  pseudocode\n  k←n\n  while k>3 do\n  	if k%2==1\n  		then 使用其他芯片对最后一片芯片进行测试\n  		if 最后一片芯片是好的\n  			then 返回这片芯片\n  		else\n  			丢弃这片芯片\n  			k←n-1\n  	else\n  		then 将芯片分为k/2组\n  	for i←1 to ⌊k/2⌋ do\n  		if 每组芯片的报告都是好\n  			then 任取一片留下\n  		else\n  			then 全部丢弃\n  	k←剩下的芯片数\n  if k=3 then \n  	任取两片芯片进行测试\n  	if 1好1坏\n  		then 取没测的芯片返回\n  	else\n  		任取一片被测芯片\n  if k=2 or 1\n  	then 任取一片芯片\n  		\n  \n\n### 3.4 幂乘算法\n\n- **输入**：a为给定实数，n为自然数\n\n- **输出**：a^n\n\n- **算法设计思想**：n个a相乘，如果用穷举法计算需要进行n次乘法，可以采用分治的思想，将n个a分为规模为n/2的两个子问题，计算一个子问题的值然后对这个值进行平方，这里需要考虑n为奇数或者偶数的情况，当n为偶数直接进行归约子问题即可，当n为奇数，则考虑将n-1的问题进行分治求解再乘以a\n\n- **伪码描述**\n\n  pseudocode\n  if n<2\n  	then return a\n  l←⌊log(n)⌋\n  sum←a*a\n  for i←0 to l do\n  	sum=sum*sum\n  if n%2=0\n  	then return sum\n  else\n  	return a*sum\n  \n\n### 3.5 选第二大数算法\n\n- **输入**：n个数组成的数组L\n\n- **输出**：第二大数second\n\n- **算法设计思想**：第二大数只能在数字的两两比较中被第一大数淘汰，因此找到最大的数并记录最大数比较的过程中淘汰的数，在这些淘汰的数记录中选择最大的数就是所有数组中第二大数\n\n- **算法伪码**\n\n  pseudocode\n  k←n	//数组长度\n  将k个元素两两分组，分为⌊k/2⌋组\n  每组的2个元素进行比较，找到最大数\n  将被淘汰的数计入较大数的链表\n  max←最大数\n  second←max的链表中最大的数\n  return second\n  \n\n### 3.6 平面点集的凸包\n\n- **问题**：给定大量离散点的集合Q，求一个最小的凸多边形能将Q中的点在该多边形的边上或者内部\n- **分治算法**：首先找到点集中纵坐标最大和最小的点连线P，将点集分为两个子问题，对于每个子问题，在点集中找到离P最远的点和P的端点连线A，B形成三角形，然后删除三角形内部的点，A、B外部的点又形成子问题\n\n## 四、动态规划\n\n### 4.1 概念\n\n- **动态规划**：求解过程是多阶段决策过程，每步处理一个子问题，用于求解组合优化问题\n- **适用条件**：问题要满足优化原则，即一个优化决策序列的任何子序列本身一定是一个相对于子序列的初始和结束状态的最优决策序列\n\n### 4.2 动态规划的算法设计 \n\n- **设计要素**\n\n  - 多阶段决策过程，每步处理一个子问题，界定子问题的边界\n  - 列出优化函数的递推方程及初值\n  - 问题要满足最优化原则 \n\n- **动态规划算法的实现（以矩阵链乘法问题为例）**\n\n  - **问题**：$A_1,A_2,...An$为矩阵序列，$A_i$为$P_{i-1} \\cdot P_i$阶矩阵，$i=1,2,..n$。试确定矩阵的乘法顺序，使得元素想成的总次数最少\n\n  - **输入**：向量$P=<P_0,P_1,...,P_n>$，其中$P_0,P_1,...,P_n$为$n$个矩阵的行数和列数\n\n  - **输出**：矩阵链乘法加括号的位置和最少乘法次数\n\n  - **算法步骤**\n\n    - 子问题划分\n\n      - $矩阵链：A_{i..j}$，边界$i,j$\n      - $输入向量：<P_{i-1},P_i,...,P_j>$\n      - $最少乘法次数：m[i,j]$\n\n    - $子问题依赖关系：假设最优划分的最后一次相乘发生在矩阵k的位置，即$\n      $$\n      A_{i..j}=A_{i..k}A_{k+1..j}\n      $$\n      $A_{i..j}最优运算次数依赖于A_{i..k}与A_{k+1..j}的最优运算次数$\n\n    - 递推方程\n\n      $m[i,j]=0，i=j$\n\n      $m[i,j]=min_{i=<k<=j}\\{m[i,k]+m[k+1,j]+P_{i-1}P_kP_j\\}，i<j$\n\n  - **递归实现 RecurMartixChain(P,i,j)**\n\n    pseudocode\n    m[i,j]←∞\n    s[i,j]⬅i\n    for k←i to j-1 do\n    	q←RecurMartixChain(P,i,k)+RecurMartixChain(P,k+1,j)+P(i-1)PkPj\n    if q<m[i,j]\n    then m[i,j]←q\n         s[i,j]←k\n    return m[i,j]\n    \n\n    - 动态规划算法与蛮力算法比较，利用子问题优化函数间的依赖关系，时间复杂度有所降低。但是动态规划算法的递归实现效率不高，原因是同一子问题多次重复出现，采取空间换时间的策略，记录每个子问题的首次计算结果，后面用时直接取，每个子问题只算一次\n\n  - **迭代实现 MartixChain(P,n)**\n\n    - 迭代计算的关键\n\n      - 每个子问题计算一次\n      - 迭代过程：从最小子问题算起。考虑计算顺序，存储结构保存计算结果\n      - 解的追踪：设计标记函数标记每步的决策，考虑根据标记函数追踪解的算法\n\n    - 算法伪码\n\n      pseudocode\n      令所有的m[i,i]初值为0\n      for r⬅2 to n do \n      	for i⬅1 to n-r+1\n      		j⬅i+r-1\n      		m[i,j]⬅m[i+1,j]+P(i-1)PiPj\n      		s[i,j]⬅i\n      		for k⬅i+1 to j-1 do \n      			t⬅m[i,k]+m[k+1,j]+P(i-1)PkPj\n      			if t<m[i,j]\n      				then m[i,j]⬅t\n                    		  s[i,j]⬅k  \n      \n\n### 4.3 投资问题\n\n- **问题**：$m元钱，n项投资，f_i(x)为将x元投入第i个项目的效益$，求使得总效益最大的投资方案\n\n- **算法步骤**\n\n  - 建模\n\n    - $x_i是投资给项目i的钱数，i=1,2,...,n$\n    - 目标函数：$max\\{f_1(x_1)+f_2(x_2)+...+f_n(x_n)\\}$\n    - 约束条件：$x_1+x_2+...+x_n=m$\n\n  - 子问题界定\n\n    - 由参数k和x界定，其中k为对项目1到k的投资，x为投资钱总数\n    - 输入：$x，k$\n    - 输出：$F_k(x)表示将x元钱投资给前k个项目的最大收益$\n\n  - 递推方程\n\n    ​	$F_k(x)=max_{0<=x_k<=x}\\{f_k(x_k)+F_{k-1}(x-x_k)\\}$\n\n    ​	$F_1(x)=f_1(x)$\n\n- **算法伪码**\n\n  pseudocode\n  \n  \n\n### 4.4 背包问题 \n\n- **问题**：一个旅行者随身携带一个背包，可以放入的物品有n种，每种物品的重量和价值分别为$w_i，v_i$。如果背包的重量限制为b，每种物品可以放多个，怎么样选择放入背包的物品使得背包的价值最大\n- **算法步骤**\n  - 建模\n    - 解是$<x_1,x_2,...,x_n>$，其中$x_i$是装入背包的第$i$种物品的个数\n    - 目标函数：$max\\sum_{i=1}^{n}v_ix_i$\n    - 约束条件：$\\sum_{i=1}^nw_ix_i<=b$\n\n  - 子问题界定\n    - 由参数$k和y界定，k表示对物品1到k的选择，y表示背包总重量不超过y$\n    - 输入：$k，y$\n    - 输出：$F_k(y)，表示装前k种物品，总重量不超过y，背包达到的最大价值$\n    - 子问题计算顺序：给定$k=1，2，...，n，对于给定的k，y=1，2，...，b$\n\n  - 递推方程\n\n    ​	$F_k(y)=max\\{F_{k-1}(y),F_k(y-w_k)+v_k\\}$\n\n    ​	$F_0(y)=0，F_k(0)=0$\n\n    ​	$F_1(y)=⌊\\frac{y}{w_1}⌋v_1$\n\n  - 标记函数：$i_k(y)$表示装前k个物品，总重量不超过y，背包达到最大价值时装入物品的最大标号\n\n    ​	$i_k(y)=i_{k-1}(y)，F_{k-1}(y)>F_k(y-w_k)+v_k$\n\n    ​	$i_k(y)=k，           F_{k-1}(y)<F_k(y-w_k)+v_k$\n\n    ​	$i_1(y)=0，y<w_1 $\n\n    ​	$i_1(y)=1，y>=w_1$\n\n- **算法伪码**\n\n  - 动态规划算法伪码\n\n  - 追踪算法 TrackSoultion($i_k(y)$) 伪码\n\n    pseudocode\n    for j⬅1 to n do xj⬅0\n    	y⬅b,j←n\n    	j←ij(y)\n    	xj←1\n    	y←y-wj\n    	while(ij(y)=j) do\n    		y←y-wj\n    		xj←xj+1\n    	if(ij(y)!=0)\n    		then goto 3\n    \n\n- **时间复杂度**：$O(nb)$\n\n### 4.5 最长公共子序列问题\n\n- **问题**： 若一个序列A里所有元素都属于序列B，且A中元素在B中的相对顺序是一致的，则A叫做B的子序列。已知给定序列$X=<x_1,x_2,...,x_n>，Y=<y_1,y_2,...,y_n>$求$X和Y$的最长公共子序列 \n\n- **算法步骤**\n\n  - 子问题界定\n\n    - 假设序列$X$的终止个数为$i$，$Y$的终止位置为$j$\n    - 输入：$X_i=<x_1,x_2,...,x_i>$，$Y_j=<y_1,y_2,...,y_j>$\n    - 输出：$Z_i=<z_1,z_2,...,z_n>$，$C[i,j]表示X_i和Y_j的LCS长度$，$B[i,j]为标$$记函数$\n\n  - 子问题依赖关系\n\n    - 若$x_m=y_n，则z_k=x_m=y_n，且Z_{k-1}是X_{m-1}和Y_{n-1}的LCS$\n    - 若$x_m!=y_n，则z_k!=x_m，且Z_{k}是X_{m-1}和Y_{n}的LCS$\n    - 若$x_m!=y_n，则z_k!=y_n，且Z_{k}是X_{m}和Y_{n-1}的LCS$\n\n  - 优化函数的递推方程\n\n    ​	$C[i,j]=0，i=0或j=0$\n\n    ​	$C[i,j]=C[i-1,j-1]+1，x_i=y_j$\n\n    ​	$C[i,j]=max\\{C[i,j-1],C[i-1,j]\\}，i,j>0,x_i!=y_j$\n\n  - 标记函数\n\n    ​	$B[i,j]=b，当C[i,j]=C[i-1,j-1]$\n\n    ​	$B[i,j]=l，当C[i,j]=C[i-1,j]$\n\n    ​	$B[i,j]=u，当C[i,j]=C[i,j-1]$\n\n- **算法伪码**\n\n  - 动态规划算法$LCS(X,Y,m,n)$\n\n    pseudocode\n    for i←1 to m do C[i,0]=0\n    for j←1 to n do c[0,j]=0\n    for i←1 to m do\n    	for j←1 to n do \n    		if (Xi=yj)\n    			then c[i,j]⬅c[i-1,j-1]+1\n    				 b[i,j]←b\n    		else if C[i-1,j]>c[i,j-1]\n    			then c[i,j]=c[i-1,j]\n    				 b[i,j]=l\n    		else\n    			c[i,j]=c[i,j-1]\n    			b[i,j]=u\n    \n\n  - 追踪算法$StructSequence(B,i,j)$\n\n    pseudocode\n    if i=0 or j=0   //序列为空\n    	then return \n    if B[i,j]=b\n    	then 输出xi\n    	StructSequence(B,i-1,j-1)\n    else if B[i,j]=l\n    	then StructSequence(B,i-1,j)\n    else\n    	StructSequence(B,i,j-1)\n    \n\n- **时间复杂度**：$\\Theta(mn)$\n\n### 4.6 最大子列和问题\n\n- **问题**：给定一个序列A，求出序列A中连续的和最大的子列\n\n- **算法步骤**\n\n  - 子问题界定\n\n    - 前边界为1，后边界为$i$，$C[i]表示A[1...i]中必须包含元素A[i]$的向前连续延伸的最大子段和，$C[i]=max_{1\\leq k \\leq i}\\{\\sum_{j=k}^iA[j]\\}$\n    - 输入：$序列A[1..n]$\n    - 输出：最大子列和$sum，子段最后位置c$\n\n  - 递推方程\n\n    ​	$C[i]=max\\{C[i-1],A[i]\\}$\n\n    ​	$C[1]=A[1]，A[1]>0$\n\n    ​	$C[1]=0，A[1]\\leq0$\n\n  - 最优解：$max_{1\\leq i \\leq n}\\{C[i]\\}$\n\n- **算法伪码**\n\n  pseudocode\n  sum←0\n  b←0\n  for i←1 to n do\n  	if b>0\n  		then b←b+A[i]\n  	else b←A[i]\n  	if b>sum\n  		then sum←b\n  			 c←i\n  return sum,c\n  \n\n- **时间复杂度**：$O(n)$\n\n### 4.7 序列比对问题\n\n- **问题**：给定两个序列$S_1和S_2$，通过一系列的字符编辑（插入、删除、替换）等操作，将$S_1转变成S_2$，完成这种转换所需要的最少编辑次数称为两个序列的编辑距离\n\n- **算法步骤**\n\n  - 子问题划分和界定\n\n    - $S_1[1...n]和S_2[1...m]表示两个序列​$，那么子问题就是$S_1[1...i]和S_2[1...j]​$，边界为$(i,j)​$\n    - 输入：序列$S_1，S_2，i，j$\n    - 输出：最少编辑距离$C[i,j]$\n\n  - 子问题归约\n\n    |          操作          |  归约子问题  | 编辑距离 |\n    | :--------------------: | :----------: | :------: |\n    |      删除$S_1[i]$      |  $(i-1,j)$   |    +1    |\n    | $S_1[i]后面插入S_2[j]$ |  $(i,j-1)$   |    +1    |\n    |  $S_1[i]替换为S_2[j]$  | $(i-1，j-1)$ |    +1    |\n    |    $S_1[i]=S_2[j]$     | $(i-1，j-1)$ |    0     |\n\n  - 优化函数的递推方程\n\n    ​	$C[i,j]=min\\{C[i-1,j]+1,C[i,j-1]+1,C[i-1,j-1]+t[i,j]\\}$\n\n    ​	$C[0,j]=j$\n\n    ​	$C[i,0]=i$\n\n    ​	$t[i,j]=0，S_1[i]=S_2[j]$\n\n    ​	$t[i,j]=1，S_1[i]!=S_2[j]$\n\n- 算法伪码\n\n  \n  \n  \n\n- **时间复杂度**：$O(mn)$\n\n### 4.8 动态规划算法设计总结\n\n- 引入参数来界定子问题的边界，注意子问题的重叠程度\n- 给出带边界参数的优化函数定义与优化函数的递推关系，找出递推关系的初值\n- 判断该优化问题是否满足优化原则\n- 考虑是否需要标记函数\n- 采用自底向上的实现奇数，从最小的子问题开始迭代计算，计算中用备忘录保留优化函数和标记函数的值\n- 动态规划的时间复杂度是对所有子问题（备忘录）的计算量求和（可能需要追踪解的工作量）\n- 动态规划算法一般使用较多的存储空间，这往往成为限制动态规划算法使用的瓶颈因素\n\n## 五、贪心算法\n\n### 5.1 贪心算法的基本思想\n\n- **设计要素**\n  - 贪心法适用于组合优化问题\n  - 求解过程是多步判断，最终的判断序列对应于问题的最优解\n  - 依据某种短视的贪心选择性质判断，性质好坏决定算法的成败\n  - 贪心法必须进行正确性证明\n  - 证明贪心算法不正确的技巧：举反例\n- **优势**：算法简单，时间和空间复杂性低\n\n### 5.2 二元前缀码与哈夫曼算法\n\n- **问题**：用0-1字符串作为代码表示字符，要求任何字符的代码都不能作为其他字符代码的前缀叫做二元前缀码。给定字符集$C=\\{x_1,x_2,...,x_n\\}$和每个字符的频率$f(x_i)，i=1,2,...,n$，求关于$C$的最优前缀码（平均传输位数最少）\n\n- **输入**：$C=\\{x_1,x_2,...,x_n\\}，f(x_i)，i=1,2,...,n$\n\n- **输出**：队列$Q$\n\n- **哈夫曼算法Huffman(C)**：将所有字符按照频率从小到大的顺序排列，每次取其中最小的两个字符构成一棵二叉树，父节点为两个字符频率之和，然后将这棵树放入集合中，直到集合最后只剩下一棵树\n\n- **算法伪码**\n\n  pseudocode\n  n←|C|	//求序列C的长度n\n  Q←C		//将序列C按照频率递增排序\n  for i←1 to n-1 do\n  	z←AllocateNode()		//生成节点z\n  	z.left←Q中最小元素		//从Q中取出最小元素放入z的左子树\n  	z.right←Q中最小元素		//从Q中取出最小元素放入z的右子树\n  	f(z)=f(x)+f(y)			//z的节点值为左右子树节点值之和\n  	insert(Q,z)				//将z节点插入到Q中\n  return Q			//返回Q序列，每个元素的编码为父节点到左节点为0到右节点为1\n  \n\n### 5.3 最小生成树\n\n- **问题**：无向连通带权图$G=(V,E,W)$，其中$W为边E的权的集合，G的最小生成树T是包含了G$的所有顶点的树，树中各边权之和$W(T)$称为树的权，具有最小权的生成树称为$G$的最小生成树\n\n- **输入**：$G=(V,E,W)$\n\n- **输出**：$T$\n\n- **算法步骤**：选择边\n\n- **约束条件**：不构成回路\n\n- **截至条件**：边数达到$n-1$\n\n- **Prim算法**\n\n  - 设计思想：初始集合$S只包括一个节点，然后选择连接集合S和V-S的最短边e=\\{i,j\\}，$其中$顶点i在集合S中，顶点j在集合V-S中，将e加入T，j加入S。$不断的执行上述过程一直到$S=V$为止\n\n  - 算法$Prim(G,E,W)$伪码\n\n    pseudocode\n    S←{1}	//将第一个顶点放入S集合\n    while V-S！=NULL do\n    	从V-S中选择j使得j到S中某一顶点i的边权最小\n    	将连通i,j的边加入T\n    	将j加入S\n    return T\n    \n\n- **Kruskal算法**\n\n  - 设计思想：按照边长从小到大排序，依次考虑当前最短边$e$，如果$e与T的边不构成回路$，则把$e加入树T，否则跳过e，直到选择了n-1条边为止$\n\n  - 算法$Kruskal(G,E,W)$伪码\n\n    \n    权从小到大排序E的边，E={e1,e2,...,en}\n    T←∞\n    repeat\n    	e←E中的嘴短编\n    	if e的两端点不在同一连通分支\n    	then 将e加入T\n    	E←E-{e}\n    until T包含了n-1条边\n    \n\n### 5.4 单源最短路径问题\n\n- **问题**：给定带权有向网络$G=(V,E,W)$，每条边$e=<i,j>的权w(e)为非负实数，表示从i到j$的距离，源点$s在集合V中，求s到其他各个节点的最短路径$\n- **输入**：带权有向图$G=(V,E,W)，源点s$\n- **输出**：$源点s到有向图其他各个顶点的距离$\n- **Dijkstra算法**\n  - 设计思想\n    1. 初始$S={s}，s到V-S中各个点i相对S的最短路为dist[i]，如果s和i没有边则设为∞$\n\n    2. 选择其中$dist[i]最小的点j，然后将j加入S，重新计算s到V-S中各个点相对于S的最短$路径$dist值$\n    3. 重复2，直到$S=V为止的dist[i]就是s到其他各个顶点的最短距离$\n\n  - 算法伪码\n\n    pseudocode\n    S←{s}\n    dist{s}←0\n    for i in V-S do\n    	dist[i]←w(s,i)	//s到i没边，w(s,i)=∞\n    while V-S！=NULL do\n    	从V-S取dist最小的点j\n    	S←S+j\n    	for i in V-S do\n    		if dist[j]+w[j,i]<dist[i]\n    		then dist[i]←dist[j]+w(j,i)\n    \n\n## 六、回溯算法\n\n### 6.1 回溯算法的基本思想\n\n- **适用**：求解组合搜索问题和优化问题\n- **求解条件**：满足多米诺性质\n  - 多米诺性质：当向量从$x_1,...,x_{n+1}满足约束条件，则x_1,...,x_n满足约束条件，如果n维$向量不满组约束条件，则$n+1维向量也不满足约束条件，可以回溯$\n- **解的表示**：解向量，求解是不断扩充解向量的过程\n- **回溯条件**\n  - 搜索问题：约束条件\n  - 优化问题：约束条件+代价函数\n- **搜索空间**：树、节点对应部分解向量，可行解在树叶上\n- **搜索过程**：采用系统的方法隐含遍历搜索树\n- **搜索策略**：深度优先、广度优先、函数优先、广深结合等\n- **节点分支判定条件**\n  - 满足约束条件：扩张解向量\n  - 不满足约束条件：回溯到该节点的父节点\n- **节点状态** \n  - 白节点：尚未访问\n  - 灰节点：正在访问该节点为根的子树\n  - 黑节点：该节点为根的子树遍历访问完成\n- **存储**：当前路径\n- **设计步骤**\n  - 定义解向量和每个分量的取值范围，解向量为$<x_1,x_2,...,x_n>，确定x_i的取值集合X_i$\n  - 在$<x_1,x_2,...,x_{k-1}>确定后计算x_k的取值集合S_k,S_k是X_k的子集$\n  - 确定节点儿子的排列顺序（$S_k的值的排列顺序$）\n  - 判断是否满足多米诺性质\n  - 确定每个节点分支的约束条件\n  - 确定搜索策略：深度优先、广度优先\n  - 确定存储搜索路径的数据结构\n\n### 6.2 回溯算法的实现\n\n- **回溯算法的递归实现**\n\n  - 算法 $ReBack(k)$\n\n    - 算法伪码\n\n      pseudocode\n      if k>n \n      then <x1,x2,..,xn>是解\n      else while Sk!=null do\n      	xk←Sk中最小值\n      	Sk←Sk-{xk}\n      	计算S(k+1)\n      	ReBack(k+1)\n      \n\n  - 算法 $ReBackTrack(n)$\n\n    - 输入：n\n\n    - 输出：所有的解\n\n    - 算法伪码\n\n      pseudocode\n      for k←1 to n \n      	计算Xk且Sk←Xk\n      ReBack(1)\n      \n\n- **回溯算法的迭代实现**\n\n  - 算法 $BackTrace(n )$\n\n    - 输入：n\n\n    - 输出：所有的解\n\n    - 算法伪码\n\n      pseudocode\n      对于i=1,2,...,n确定Xi\n      k←1\n      计算Sk\n      while Sk!=null do\n      	xk←Sk中最小值\n      	Sk←Sk-{xk}\n      	if k<n \n      	then k←k+1\n      		 计算Sk\n      	else\n      		<x1,x2,...,xn>是解\n      if k>1 \n      then k←k-1\n      	 goto 4\n      \n\n### 6.3 组合搜索问题\n\n1. **船装载问题**\n\n   - 问题：$有n个集装箱，需要装上两艘载重分别是c_1和c_2的轮船，w_i为第i个集装箱的重量，问：$是否存在一种合理的装载方案讲$n$个集装箱装上船\n\n   - 输入：$W=<w_1,w_2,...,w_n>为集装箱重量，c_1和c_2为船的最大载重量$\n\n   - 输出：集装箱装载方案\n\n   - 算法思想：令第一艘船的装载量为$W_1$\n\n     - 用回溯法求使得$c_1-W_1$达到最小的装载方案\n     - 满足$w_1+w_2+...+w_n-W_1<=c_2$，则返回方案，否则回溯\n\n   - 算法伪码**\n\n     - 算法 $Load(W,c_1)$\n\n       pseudocode\n       Sort(W)		//对各个集装箱重量进行排序\n       B←c1\n       best←c1\n       i←1\n       while i<=n do\n       	if 装入i后重量不超过c1\n       	then B←B-wi\n       		 x[i]←1		//数组下标为i设为1代表装入第i种货物\n       		 i=i+1\n       	else\n       		 x[i]=0		//数组下标为i设为0代表不装入第i种货物\n       		 i=i+1\n       if B<best \n       then 记录解\n       	 best←B\n       Backtrace(i)		//回溯i到其父节点\n       if i=1\n       then return 最优解\n       esle goto 5\n       \n\n     - 算法 $Backtrack(i)$\n\n       pseudocode\n       while i>1 and x[i]=0 do\n       	i=i-1\n       if x[i]=1\n       then x[i]←0\n            B←B+wi\n            i←i+1\n       \n\n   - 时间复杂度：$O(2^n)$\n\n2. **图的着色问题**\n\n   - 问题：输入一个无向连通图$G$和$m$种颜色的集合，用这些颜色给图的顶点着色，要求每条边的两个顶点着不同颜色，输出所有的着色方案\n   - 输入：$图G=(V,E)，V={1,2,...,n}，颜色编号1,2,...,m$\n   - 输出：$解向量<x_1,x_2,...,x_n>，x_1,x_2,..,x_n的值为顶点i的颜色编号$\n   - 约束条件：在节点$<x_1,x_2,...,x_n>$处顶点$k+1$的邻接表中节点已用过颜色不能再用，如果邻接表中节点已经使用过$m$中颜色，则节点$k+1$没法着色，从该节点回溯到其父节点\n   - 搜索策略：深度优先\n   - 时间复杂度：$O(nm^n)$\n\n### 6.4 组合优化问题\n\n1. **分支限界**\n\n   - 代价函数：在搜索树的节点计算以该点为根的子树所有可行解的目标函数值的上界（极小化问题为下界），对极大化问题父节点代价函数值不小于子节点的代价函数值（极小化问题相反）\n   - 界：当前得到可行解的目标函数值的最大值（极小化问题相反），当得到更好的可行解时，需要对当前界进行更新\n   - 分支限界停止分支回溯父节点的依据\n     - 不满足约束条件\n     - 对于极大化问题，代价函数值小于当前界（极小化问题相反）\n\n2. **货郎问题**\n\n   - 问题：有穷个城市，已知每两个城市之间的距离，要求找到一条合适的路线，从某一个城市出发，途径所有城市且每个城市只经过一次再回到起点城市的路径最短\n\n   - 输入：$城市集合C=\\{c_1,c_2,...,c_n\\}，距离d(c_i,c_j)=d(c_j,c_i)$\n\n   - 输出：$1,2,...,n的排列k_1,k_2,...,k_n使得：min\\{\\sum_{i=1}^{n-1}d(c_{k_i},c_{k_{i+1}})+d(c_{k_n},c_{k_1})\\}$\n\n   - 算法设计\n     - 解向量为：$<i_1,i_2,...,i_n>$\n\n     - 约束条件：$令B={i_1,i_2,...,i_k}，则i_{k+1}应该是<i_1,i_2,...,i_n>-B集合中的一个$\n\n     - 界：当前得到的最短巡回路线长度\n\n     - 代价函数\n       $$\n       L=\\sum_{j=1}^kd_j+第j个城市到其他城市的最短距离+所有没走到城市到其他城市的最短距离之和\n       $$\n\n   - 时间复杂度：$O(n!)$\n\n3. **圆排列问题**\n\n   - 问题：给定$n$个圆的半径序列，各圆与底线相切排列，求具有最小长度$l_n$的圆排列顺序\n\n   - 输入：$n$个圆的半径序列，$<r_1,r_2,...,r_n>$\n\n   - 输出：圆的排列顺序序列，$<i_1,i_2,...,i_n>$\n\n   - 算法设计\n\n     - 解向量为：$<i_1,i_2,...,i_n>$\n\n     - 约束条件：$令B={i_1,i_2,...,i_k}，则i_{k+1}应该是<i_1,i_2,...,i_n>-B集合中的一个$\n\n     - 界：当前得到的最小圆排列长度\n\n     - 代价函数\n       $$\n       l_n=x_k+d_{k+1}+d_{k+2}+...+d_n+r_n+r_1\n       $$\n       其中，$k:$算法已经选择了第1-$k$个圆\n\n       ​	   $r_k：$第$k$个圆半径\n\n       ​	   $d_k$：第$k-1$个圆到第$k$个圆的圆心水平距离\n\n       ​	   $x_k$：第$k$个圆的圆心坐标，规定$x_1=0$\n\n       ​	   $d_k=\\sqrt{(r_k+r_{k-1})^2-(r_k-r_{k-1})^2}=2\\sqrt{r_{k-1}r_k}$\n\n       因此，代价函数有\n       $$\n       l_n=x_k+2\\sqrt{r_kr_{k+1}}+2\\sqrt{r_{k+1}r_{k+2}}+...+2\\sqrt{r_{n-1}r_n}+r_n+r_1>=x_k+2(n-k)r+r+r_1\n       $$\n       其中，$r$：剩下圆中最小的半径\n\n   - 时间复杂度：$O((n+1)!)$\n\n4. **连续邮资问题**\n\n   - 问题：给定$n$种不同面值的邮票，每个信封至多贴$m$张，试给出邮票的最佳设计，使得信封上邮票的邮资从1开始，增量为1的连续最大区间\n   - 输入：邮票面值种数：$n$，信封最多贴邮票数：$m$\n   - 输出：使得信封上邮资连续递增区间最大的邮票面值序列$<x_1,x_2,...,x_n>，$其中$x_1=1$\n   - 约束条件：在节点$<x_1,x_2,...,x_i>$处，邮资最大连续区间为$\\{1,...,r_i\\}$，则$x_i$的取值范围为$\\{x_i+1,...,r_i+1\\}$\n   - \n\n\n\n\n', '2019-02-16 11:36:26', '<h2>一、基础知识</h2>\n<h3>1.1 问题求解的关键</h3>\n<ul>\n<li><strong>建模</strong>：对输入参数和解给出形式化和版形式化的描述</li>\n<li><strong>设计算法</strong>：采用算法设计技术满足对所有的实例都获得正确解</li>\n<li><strong>分析算法</strong>：效率</li>\n</ul>\n<h3>1.2 算法及其时间复杂度</h3>\n<ul>\n<li><strong>算法</strong>：有限条指令的序列，每步的计算是确定性的，能够再有限步结束算法，输出实例的正确解</li>\n<li><strong>算法时间复杂度</strong>：针对基本运算，计算算法所作的运算次数</li>\n<li><strong>时间复杂度种类</strong></li>\n<li>最坏时间复杂度</li>\n<li>平均时间复杂度</li>\n</ul>\n<h3>1.3 算法的伪码表示</h3>\n<ul>\n<li><strong>赋值语句</strong>：←</li>\n<li><strong>分支语句</strong>：if ... then ... [else ...]</li>\n<li><strong>循环语句</strong>：while,for</li>\n<li><strong>转向语句</strong>：goto</li>\n<li><strong>输出语句</strong>：return</li>\n<li><strong>调用</strong>：直接写过程的名字</li>\n<li><strong>注释</strong>：//</li>\n<li><strong>向上取整</strong>：⌈ ⌉</li>\n<li><strong>向下取整</strong>：⌊ ⌋</li>\n</ul>\n<h2>二、算法的数学基础</h2>\n<h3>2.1  递归树</h3>\n<ul>\n<li><strong>概念</strong>： 递归树是迭代计算的模型，递归树的生成过程和迭代过程一致，树上所有项恰好是迭代之后产生和式值中的项，对递归树上的项求和就是迭代后方程的解</li>\n<li><strong>生成规则</strong></li>\n<li>初始，递归树只有根节点，其值为W(n)</li>\n<li>不断继续下述过程：将函数项叶节点的迭代式W(m)表示成二层子树，用改子树代替叶节点</li>\n<li>继续递归树的生成，直到树中无函数项</li>\n</ul>\n<h3>2.2 主定理</h3>\n<ul>\n<li><p><strong>递推方程</strong>：对于递推方程：T(n)=a*T(n/b)+f(n)，其中a为归约后的子问题个数，n/b为归约后子问题的规模，f(n)为归约过程及组合子问题的解的工作量，如二分检索的地推方程为：T(n)=T(n/2)+1，二分归并排序的递推方程为：T(n)=2T(n/2)+n-1</p>\n</li>\n<li><p><strong>主定理</strong>：若递推公式满足T(n)=a*T(n/b)+f(n)，则：</p>\n</li>\n<li><p>若f(n)中n的阶小于log<em>ba，那么时间复杂度为n^(/log</em>ba)</p>\n</li>\n<li><p>若f(n)中n的阶等于log<em>ba，那么时间复杂度为(n^(/log</em>ba)*logn)</p>\n</li>\n<li><p>若f(n)中n的阶大于log_ba，那么时间复杂度为f(n)</p>\n</li>\n</ul>\n<h2>三、分治算法</h2>\n<h3>3.1 分治策略的基本思想</h3>\n<ul>\n<li><p><strong>分治策略</strong></p>\n</li>\n<li><p>将原问题划分为规模较小的子问题</p>\n</li>\n<li><p>递归或者迭代求解每个子问题</p>\n</li>\n<li><p>将子问题的解综合得到原问题的解</p>\n</li>\n<li><p><strong>注意</strong></p>\n</li>\n<li><p>子问题与原问题性质完全一样</p>\n</li>\n<li><p>子问题之间可以彼此独立的求解</p>\n</li>\n<li><p>递归停止时子问题可以直接求解</p>\n</li>\n<li><p><strong>排列问题</strong></p>\n</li>\n<li><p>第一种分析思路</p>\n<ul>\n<li><p>分析：假设元素个数n=1，全排列只有这一个元素，假设n>1，对于每个元素规模为n的数组的全排列是轮流取出这n个元素的一个作为前缀，其他n-1个元素的全排列作为后缀（一棵n叉树）</p>\n</li>\n<li><p>输入：数组T，全排列起始元素序号l，全排列终止元素序号r</p>\n</li>\n<li><p>输出：前缀是T[0:l-1]，后缀是T[l-1,r]的全排列的所有排列</p>\n</li>\n<li><p>Java实现代码</p>\n<p><code>java\npublic static void perm(int []T,int l,int r){\n//如果已经产生了全排列，就打印出来\nif(l==r){\nfor(int i=0;i&lt;r;i++){\nSystem.out.println(T[i]);\n}\n}\nelse\n//轮流取出数组T下标为l到r之间的元素作为前缀，下标为l到r之间的其他元素的全排列作为后缀\nfor(int i=l;i&lt;=r;i++){\nswap(T,i,l);\nperm(T,l+1,m);\nswap(T,i,l);\n}\n}\n}\n</code></p>\n</li>\n</ul>\n</li>\n<li><p>第二种分析思路</p>\n<ul>\n<li><p>分析：当m=1时，全排列为T[0]这个元素，当m>1时，全排列为前m-1个元素的全排列的每种排列方式又可以分为在每种排列方式的每个元素前面分别插入第m个元素和最后一个元素后面插入第m个元素这n种情况。如数组[1,2,3]，当m=1时，全排列只有{[1]}这一种情况，当m=2时，对于m=1的每个全排列又能分为将元素2插入1的前面和后面，情况有{[1,2],[2,1]}两种全排列，当m=3时，对于m=2的每种情况又能分为将元素3插入每个元素的前面和后面，情况有{[3,1,2],[1,3,2],[1,2,3],[3,2,1],[2,3,1],[2,1,3]}</p>\n</li>\n<li><p>输入：数组a，全排列结束位置m</p>\n</li>\n<li><p>输出：一个List，List的每个元素也为一个存储一种全排列的List</p>\n</li>\n<li><p>Java实现代码</p>\n<p><code>java\npublic static List&lt;List&gt; perm(int a[],int m){\n//当m=0，只有一个元素时，全排列为a[0]\nif(m==0){\nList numList=new ArrayList();\nList listList=new ArrayList();\nnumList.add(a[0]);\nlistList.add(numList);\nreturn listList;\n}\n//当m&gt;1对数组的m个元素进行全排列\nelse {\n//取出前m-1个元素的全排列\nList listList=perm(a,m-1);\n//新建一个存储全排列List的List\nList newListList=new ArrayList();\n//分别取出m-1个元素的每个全排列\nfor(int i=0;i&lt;listList.size();i++){\nList numList= (List) listList.get(i);\n//对于前m-1个元素的每个全排列，分别将第m个元素插入到全排列每个元素的前面以及最后一个元素的后面形成m个新的全排列\nfor(int j=0;j&lt;=numList.size();j++){\nList newNumList=new ArrayList();\nfor(int k=0;k&lt;numList.size();k++){\nif(k==j){\nnewNumList.add(a[m]);\n}\nnewNumList.add(numList.get(k));\n}\nif(j==numList.size()){\nnewNumList.add(a[m]);\n}\nnewListList.add(newNumList);\n}\n}\nreturn newListList;\n}\n}\n</code></p>\n</li>\n</ul>\n</li>\n<li><p><strong>整数划分问题</strong></p>\n</li>\n<li><p>分析：将要划分的整数设为n，划分时式子中最大的数小于m，将n划分为一系列整数之和，整数种最大值小于m的划分个数记作q(n,m)</p>\n<ul>\n<li>当m=1时，q(n,m)=1，n由n个1组成，只有一种情况</li>\n<li>当m>n时，q(n,m)=q(n,n)，若是m大于n，则总划分数还是q(n,n)</li>\n<li>当m=n时，q(n,n)=1+q(n,n-1)，若是m等于n，总划分数为m为n-1时的总划分数加上只能划分为n这一种情况之和</li>\n<li>当m&lt;n时，q(n,m)=q(n,m-1)+q(n-m,m)，当m&lt;n时，总划分数位m-1时的总划分时加上m=m时的划分数，而当m=m时的划分数其实是将n-m划分，m为上限的划分数。如将6划分，式子中最大数都小于4时的总划分数等于式子中最大数都小于3时的总划分数加上式子中最大值等于4时的总划分数。式子中最大值等于4的总划分数其实等于将2划分，式子中最大值小于4的总划分数</li>\n</ul>\n</li>\n<li><p>输入：被划分数n，划分式子中最大值小于m</p>\n</li>\n<li><p>输出：将n划分为一系列整数之和，整数中最大值小于m的划分个数q(n,m)</p>\n</li>\n<li><p>Java代码</p>\n<p><code>java\npublic staitc int q(n,m){\nif(m==1)\nreturn 1;\nelse if(m&gt;n)\nreturn q(n,n);\nelse if(m==n)\nreturn 1+q(n,n-1);\nelse\nreturn q(n,m-1)+q(n-m,m);\n}\n</code></p>\n</li>\n<li><p><strong>二分检索算法 BinarySearch(T,l,r,x)</strong></p>\n</li>\n<li><p>输入：已排序数组T，下标从l到r，查找元素x</p>\n</li>\n<li><p>输出：元素x的下标，如果没找到输出-1</p>\n<p><code>java\npublic static int BinarySearch(int []T,int l,int r,int x){\nif(l==r)\nif(T[l]==x)\nreturn x;\nelse\nreturn -1;\nm=(l+r)/2;\nif(T[m]==x)\nreturn m;\nelse if(T[m]&gt;x)\nreturn BinarySearch(T,l,m,x);\nelse\nreturn BinarySearch(T,m,r,x);\n}\n</code></p>\n</li>\n<li><p><strong>二分归并排序 MergeSort(A,p,r)</strong></p>\n</li>\n<li><p>输入：数组A[p...r]</p>\n</li>\n<li><p>输出：元素按从小到大排序的数组A</p>\n</li>\n<li><p>算法伪码</p>\n<p><code>pseudocode\nif p&lt;r\nthen q←⌊(p+r)/2⌋           //对半划分\nMergeSort(A,p,q);     //子问题1\nMergeSort(A,q+1,r)    //子问题2\nMerge(A,p,q,r);       //综合解\n</code></p>\n</li>\n<li><p>*<em>汉诺塔的递归算法 </em>*</p>\n</li>\n<li><p>输入：盘子的原始底座A，盘子的目标底座C，盘子的数量n</p>\n</li>\n<li><p>输出：盘子的移动顺序</p>\n</li>\n<li><p>Java代码</p>\n<p><code>java\npublic static void hanio(int n,char a,char c){\nif(n==1)\nmove(a,c);\nelse\nhanio(n-1,a,b);\nmove(a,c);\nhanio(n-1,b,c);\n}\n</code></p>\n</li>\n<li><p><strong>分治算法的特点</strong></p>\n</li>\n<li><p>将原问题归约为规模小的子问题，子问题与原问题具有相同的性质</p>\n</li>\n<li><p>子问题规模足够小时可以直接求解</p>\n</li>\n<li><p>算法可以递归或者迭代实现</p>\n</li>\n</ul>\n<h3>3.2 分治算法的一般性描述</h3>\n<ul>\n<li><p><strong>分治算法 Divide-and-Conquer(P)</strong></p>\n<p><code>pseudocode\n//如果问题P的规模很小时，采用直接求解算法S(P)求解\nif |P|&lt;=c then S(P)\n//如果问题P的规模足够大时，将问题P分解为若干个子问题\ndivide P into P_1,P_2,...P_k\n//迭代或递归求解子问题\nfor i←1 to k\ny_i←Divide-and-Conquer(P_i)\n//合并子问题的解\nreturn Merge(y_1,y_2,...y_n)\n</code></p>\n</li>\n</ul>\n<h3>3.3 芯片测试</h3>\n<ul>\n<li><p><strong>测试方法</strong>：将2片芯片放于测试台上，互相进行测试，测试报告是“好”或“坏”，好芯片的报告一定是正确的，坏芯片的报告一定是坏的</p>\n</li>\n<li><p><strong>测试结果分析</strong></p>\n<p>|  A报告  |  B报告  |            结论            |\n| :-----: | :-----: | :------------------------: |\n| B是好的 | A是好的 | A、B都是好的或A、B都是坏的 |\n| B是好的 | A是坏的 |       至少一个是坏的       |\n| B是坏的 | A是好的 |       至少一个是坏的       |\n| B是坏的 | A是坏的 |       至少一个是坏的       |</p>\n</li>\n<li><p><strong>输入</strong>：n片芯片，其中好芯片至少比坏芯片多一片</p>\n</li>\n<li><p><strong>问题</strong>：设计一种测试方法，通过测试从n片芯片中挑选出一片好芯片，要求最少的测试次数</p>\n</li>\n<li><p><strong>算法设计思想</strong>：假设n为偶数，将n个芯片两两一组做测试淘汰，剩下芯片构成子问题进入下一轮测试，淘汰规则为若两片芯片的报告都是好，则任留一片芯片进入下一轮，若两片芯片的报告是其他情况，则全部丢弃。递归截止条件为当n&lt;=3时，选出其中两片进行测试，如果一好一坏，选择剩余的一片芯片，如果都是好，选择其中一片芯片即可；当n为奇数时，先将最后一片芯片使用其他芯片对其进行测试，如果是好的，则取这片芯片，如果是坏的，则丢弃这片芯片，其他芯片进行分治测试</p>\n</li>\n<li><p><strong>伪码描述</strong></p>\n<p>pseudocode\nk←n\nwhile k>3 do\nif k%2==1\nthen 使用其他芯片对最后一片芯片进行测试\nif 最后一片芯片是好的\nthen 返回这片芯片\nelse\n丢弃这片芯片\nk←n-1\nelse\nthen 将芯片分为k/2组\nfor i←1 to ⌊k/2⌋ do\nif 每组芯片的报告都是好\nthen 任取一片留下\nelse\nthen 全部丢弃\nk←剩下的芯片数\nif k=3 then\n任取两片芯片进行测试\nif 1好1坏\nthen 取没测的芯片返回\nelse\n任取一片被测芯片\nif k=2 or 1\nthen 任取一片芯片</p>\n<p></p>\n</li>\n</ul>\n<h3>3.4 幂乘算法</h3>\n<ul>\n<li><p><strong>输入</strong>：a为给定实数，n为自然数</p>\n</li>\n<li><p><strong>输出</strong>：a^n</p>\n</li>\n<li><p><strong>算法设计思想</strong>：n个a相乘，如果用穷举法计算需要进行n次乘法，可以采用分治的思想，将n个a分为规模为n/2的两个子问题，计算一个子问题的值然后对这个值进行平方，这里需要考虑n为奇数或者偶数的情况，当n为偶数直接进行归约子问题即可，当n为奇数，则考虑将n-1的问题进行分治求解再乘以a</p>\n</li>\n<li><p><strong>伪码描述</strong></p>\n<p><code>pseudocode\nif n&lt;2\nthen return a\nl←⌊log(n)⌋\nsum←a*a\nfor i←0 to l do\nsum=sum*sum\nif n%2=0\nthen return sum\nelse\nreturn a*sum\n</code></p>\n</li>\n</ul>\n<h3>3.5 选第二大数算法</h3>\n<ul>\n<li><p><strong>输入</strong>：n个数组成的数组L</p>\n</li>\n<li><p><strong>输出</strong>：第二大数second</p>\n</li>\n<li><p><strong>算法设计思想</strong>：第二大数只能在数字的两两比较中被第一大数淘汰，因此找到最大的数并记录最大数比较的过程中淘汰的数，在这些淘汰的数记录中选择最大的数就是所有数组中第二大数</p>\n</li>\n<li><p><strong>算法伪码</strong></p>\n<p><code>pseudocode\nk←n   //数组长度\n将k个元素两两分组，分为⌊k/2⌋组\n每组的2个元素进行比较，找到最大数\n将被淘汰的数计入较大数的链表\nmax←最大数\nsecond←max的链表中最大的数\nreturn second\n</code></p>\n</li>\n</ul>\n<h3>3.6 平面点集的凸包</h3>\n<ul>\n<li><strong>问题</strong>：给定大量离散点的集合Q，求一个最小的凸多边形能将Q中的点在该多边形的边上或者内部</li>\n<li><strong>分治算法</strong>：首先找到点集中纵坐标最大和最小的点连线P，将点集分为两个子问题，对于每个子问题，在点集中找到离P最远的点和P的端点连线A，B形成三角形，然后删除三角形内部的点，A、B外部的点又形成子问题</li>\n</ul>\n<h2>四、动态规划</h2>\n<h3>4.1 概念</h3>\n<ul>\n<li><strong>动态规划</strong>：求解过程是多阶段决策过程，每步处理一个子问题，用于求解组合优化问题</li>\n<li><strong>适用条件</strong>：问题要满足优化原则，即一个优化决策序列的任何子序列本身一定是一个相对于子序列的初始和结束状态的最优决策序列</li>\n</ul>\n<h3>4.2 动态规划的算法设计</h3>\n<ul>\n<li><p><strong>设计要素</strong></p>\n</li>\n<li><p>多阶段决策过程，每步处理一个子问题，界定子问题的边界</p>\n</li>\n<li><p>列出优化函数的递推方程及初值</p>\n</li>\n<li><p>问题要满足最优化原则</p>\n</li>\n<li><p><strong>动态规划算法的实现（以矩阵链乘法问题为例）</strong></p>\n</li>\n<li><p><strong>问题</strong>：$A<em>1,A</em>2,...An$为矩阵序列，$A<em>i$为$P</em>{i-1} \\cdot P_i$阶矩阵，$i=1,2,..n$。试确定矩阵的乘法顺序，使得元素想成的总次数最少</p>\n</li>\n<li><p><strong>输入</strong>：向量$P=<P_0,P_1,...,P_n>$，其中$P<em>0,P</em>1,...,P_n$为$n$个矩阵的行数和列数</p>\n</li>\n<li><p><strong>输出</strong>：矩阵链乘法加括号的位置和最少乘法次数</p>\n</li>\n<li><p><strong>算法步骤</strong></p>\n<ul>\n<li><p>子问题划分</p>\n</li>\n<li><p>$矩阵链：A_{i..j}$，边界$i,j$</p>\n</li>\n<li><p>$输入向量：<P_{i-1},P_i,...,P_j>$</p>\n</li>\n<li><p>$最少乘法次数：m[i,j]$</p>\n</li>\n<li><p>$子问题依赖关系：假设最优划分的最后一次相乘发生在矩阵k的位置，即$\n$$\nA<em>{i..j}=A</em>{i..k}A<em>{k+1..j}\n$$\n$A</em>{i..j}最优运算次数依赖于A<em>{i..k}与A</em>{k+1..j}的最优运算次数$</p>\n</li>\n<li><p>递推方程</p>\n<p>$m[i,j]=0，i=j$</p>\n<p>$m[i,j]=min<em>{i=&lt;k&lt;=j}{m[i,k]+m[k+1,j]+P</em>{i-1}P<em>kP</em>j}，i&lt;j$</p>\n</li>\n</ul>\n</li>\n<li><p><strong>递归实现 RecurMartixChain(P,i,j)</strong></p>\n<p><code>pseudocode\nm[i,j]←∞\ns[i,j]⬅i\nfor k←i to j-1 do\nq←RecurMartixChain(P,i,k)+RecurMartixChain(P,k+1,j)+P(i-1)PkPj\nif q&lt;m[i,j]\nthen m[i,j]←q\ns[i,j]←k\nreturn m[i,j]\n</code></p>\n<ul>\n<li>动态规划算法与蛮力算法比较，利用子问题优化函数间的依赖关系，时间复杂度有所降低。但是动态规划算法的递归实现效率不高，原因是同一子问题多次重复出现，采取空间换时间的策略，记录每个子问题的首次计算结果，后面用时直接取，每个子问题只算一次</li>\n</ul>\n</li>\n<li><p><strong>迭代实现 MartixChain(P,n)</strong></p>\n<ul>\n<li><p>迭代计算的关键</p>\n</li>\n<li><p>每个子问题计算一次</p>\n</li>\n<li><p>迭代过程：从最小子问题算起。考虑计算顺序，存储结构保存计算结果</p>\n</li>\n<li><p>解的追踪：设计标记函数标记每步的决策，考虑根据标记函数追踪解的算法</p>\n</li>\n<li><p>算法伪码</p>\n<p><code>pseudocode\n令所有的m[i,i]初值为0\nfor r⬅2 to n do\nfor i⬅1 to n-r+1\nj⬅i+r-1\nm[i,j]⬅m[i+1,j]+P(i-1)PiPj\ns[i,j]⬅i\nfor k⬅i+1 to j-1 do\nt⬅m[i,k]+m[k+1,j]+P(i-1)PkPj\nif t&lt;m[i,j]\nthen m[i,j]⬅t\ns[i,j]⬅k&lt;br /&gt;\n</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3>4.3 投资问题</h3>\n<ul>\n<li><p><strong>问题</strong>：$m元钱，n项投资，f_i(x)为将x元投入第i个项目的效益$，求使得总效益最大的投资方案</p>\n</li>\n<li><p><strong>算法步骤</strong></p>\n</li>\n<li><p>建模</p>\n<ul>\n<li>$x_i是投资给项目i的钱数，i=1,2,...,n$</li>\n<li>目标函数：$max{f<em>1(x</em>1)+f<em>2(x</em>2)+...+f<em>n(x</em>n)}$</li>\n<li>约束条件：$x<em>1+x</em>2+...+x_n=m$</li>\n</ul>\n</li>\n<li><p>子问题界定</p>\n<ul>\n<li>由参数k和x界定，其中k为对项目1到k的投资，x为投资钱总数</li>\n<li>输入：$x，k$</li>\n<li>输出：$F_k(x)表示将x元钱投资给前k个项目的最大收益$</li>\n</ul>\n</li>\n<li><p>递推方程</p>\n<p>​   $F<em>k(x)=max</em>{0&lt;=x<em>k&lt;=x}{f</em>k(x<em>k)+F</em>{k-1}(x-x_k)}$</p>\n<p>​   $F<em>1(x)=f</em>1(x)$</p>\n</li>\n<li><p><strong>算法伪码</strong></p>\n<p>pseudocode</p>\n<p></p>\n</li>\n</ul>\n<h3>4.4 背包问题</h3>\n<ul>\n<li><p><strong>问题</strong>：一个旅行者随身携带一个背包，可以放入的物品有n种，每种物品的重量和价值分别为$w<em>i，v</em>i$。如果背包的重量限制为b，每种物品可以放多个，怎么样选择放入背包的物品使得背包的价值最大</p>\n</li>\n<li><p><strong>算法步骤</strong></p>\n</li>\n<li><p>建模</p>\n<ul>\n<li>解是$<x_1,x_2,...,x_n>$，其中$x_i$是装入背包的第$i$种物品的个数</li>\n<li>目标函数：$max\\sum<em>{i=1}^{n}v</em>ix_i$</li>\n<li>约束条件：$\\sum<em>{i=1}^nw</em>ix_i&lt;=b$</li>\n</ul>\n</li>\n<li><p>子问题界定</p>\n<ul>\n<li>由参数$k和y界定，k表示对物品1到k的选择，y表示背包总重量不超过y$</li>\n<li>输入：$k，y$</li>\n<li>输出：$F_k(y)，表示装前k种物品，总重量不超过y，背包达到的最大价值$</li>\n<li>子问题计算顺序：给定$k=1，2，...，n，对于给定的k，y=1，2，...，b$</li>\n</ul>\n</li>\n<li><p>递推方程</p>\n<p>​   $F<em>k(y)=max{F</em>{k-1}(y),F<em>k(y-w</em>k)+v_k}$</p>\n<p>​   $F<em>0(y)=0，F</em>k(0)=0$</p>\n<p>​   $F<em>1(y)=⌊\\frac{y}{w</em>1}⌋v_1$</p>\n</li>\n<li><p>标记函数：$i_k(y)$表示装前k个物品，总重量不超过y，背包达到最大价值时装入物品的最大标号</p>\n<p>​   $i<em>k(y)=i</em>{k-1}(y)，F<em>{k-1}(y)>F</em>k(y-w<em>k)+v</em>k$</p>\n<p>​   $i<em>k(y)=k，           F</em>{k-1}(y)&lt;F<em>k(y-w</em>k)+v_k$</p>\n<p>​   $i<em>1(y)=0，y&lt;w</em>1 $</p>\n<p>​   $i<em>1(y)=1，y>=w</em>1$</p>\n</li>\n<li><p><strong>算法伪码</strong></p>\n</li>\n<li><p>动态规划算法伪码</p>\n</li>\n<li><p>追踪算法 TrackSoultion($i_k(y)$) 伪码</p>\n<p><code>pseudocode\nfor j⬅1 to n do xj⬅0\ny⬅b,j←n\nj←ij(y)\nxj←1\ny←y-wj\nwhile(ij(y)=j) do\ny←y-wj\nxj←xj+1\nif(ij(y)!=0)\nthen goto 3\n</code></p>\n</li>\n<li><p><strong>时间复杂度</strong>：$O(nb)$</p>\n</li>\n</ul>\n<h3>4.5 最长公共子序列问题</h3>\n<ul>\n<li><p><strong>问题</strong>： 若一个序列A里所有元素都属于序列B，且A中元素在B中的相对顺序是一致的，则A叫做B的子序列。已知给定序列$X=<x_1,x_2,...,x_n>，Y=<y_1,y_2,...,y_n>$求$X和Y$的最长公共子序列</p>\n</li>\n<li><p><strong>算法步骤</strong></p>\n</li>\n<li><p>子问题界定</p>\n<ul>\n<li>假设序列$X$的终止个数为$i$，$Y$的终止位置为$j$</li>\n<li>输入：$X<em>i=<x_1,x_2,...,x_i>$，$Y</em>j=<y_1,y_2,...,y_j>$</li>\n<li>输出：$Z<em>i=<z_1,z_2,...,z_n>$，$C[i,j]表示X</em>i和Y_j的LCS长度$，$B[i,j]为标$$记函数$</li>\n</ul>\n</li>\n<li><p>子问题依赖关系</p>\n<ul>\n<li>若$x<em>m=y</em>n，则z<em>k=x</em>m=y<em>n，且Z</em>{k-1}是X<em>{m-1}和Y</em>{n-1}的LCS$</li>\n<li>若$x<em>m!=y</em>n，则z<em>k!=x</em>m，且Z<em>{k}是X</em>{m-1}和Y_{n}的LCS$</li>\n<li>若$x<em>m!=y</em>n，则z<em>k!=y</em>n，且Z<em>{k}是X</em>{m}和Y_{n-1}的LCS$</li>\n</ul>\n</li>\n<li><p>优化函数的递推方程</p>\n<p>​   $C[i,j]=0，i=0或j=0$</p>\n<p>​   $C[i,j]=C[i-1,j-1]+1，x<em>i=y</em>j$</p>\n<p>​   $C[i,j]=max{C[i,j-1],C[i-1,j]}，i,j>0,x<em>i!=y</em>j$</p>\n</li>\n<li><p>标记函数</p>\n<p>​   $B[i,j]=b，当C[i,j]=C[i-1,j-1]$</p>\n<p>​   $B[i,j]=l，当C[i,j]=C[i-1,j]$</p>\n<p>​   $B[i,j]=u，当C[i,j]=C[i,j-1]$</p>\n</li>\n<li><p><strong>算法伪码</strong></p>\n</li>\n<li><p>动态规划算法$LCS(X,Y,m,n)$</p>\n<p><code>pseudocode\nfor i←1 to m do C[i,0]=0\nfor j←1 to n do c[0,j]=0\nfor i←1 to m do\nfor j←1 to n do\nif (Xi=yj)\nthen c[i,j]⬅c[i-1,j-1]+1\nb[i,j]←b\nelse if C[i-1,j]&gt;c[i,j-1]\nthen c[i,j]=c[i-1,j]\nb[i,j]=l\nelse\nc[i,j]=c[i,j-1]\nb[i,j]=u\n</code></p>\n</li>\n<li><p>追踪算法$StructSequence(B,i,j)$</p>\n<p><code>pseudocode\nif i=0 or j=0   //序列为空\nthen return\nif B[i,j]=b\nthen 输出xi\nStructSequence(B,i-1,j-1)\nelse if B[i,j]=l\nthen StructSequence(B,i-1,j)\nelse\nStructSequence(B,i,j-1)\n</code></p>\n</li>\n<li><p><strong>时间复杂度</strong>：$\\Theta(mn)$</p>\n</li>\n</ul>\n<h3>4.6 最大子列和问题</h3>\n<ul>\n<li><p><strong>问题</strong>：给定一个序列A，求出序列A中连续的和最大的子列</p>\n</li>\n<li><p><strong>算法步骤</strong></p>\n</li>\n<li><p>子问题界定</p>\n<ul>\n<li>前边界为1，后边界为$i$，$C[i]表示A[1...i]中必须包含元素A[i]$的向前连续延伸的最大子段和，$C[i]=max<em>{1\\leq k \\leq i}{\\sum</em>{j=k}^iA[j]}$</li>\n<li>输入：$序列A[1..n]$</li>\n<li>输出：最大子列和$sum，子段最后位置c$</li>\n</ul>\n</li>\n<li><p>递推方程</p>\n<p>​   $C[i]=max{C[i-1],A[i]}$</p>\n<p>​   $C[1]=A[1]，A[1]>0$</p>\n<p>​   $C[1]=0，A[1]\\leq0$</p>\n</li>\n<li><p>最优解：$max_{1\\leq i \\leq n}{C[i]}$</p>\n</li>\n<li><p><strong>算法伪码</strong></p>\n<p><code>pseudocode\nsum←0\nb←0\nfor i←1 to n do\nif b&gt;0\nthen b←b+A[i]\nelse b←A[i]\nif b&gt;sum\nthen sum←b\nc←i\nreturn sum,c\n</code></p>\n</li>\n<li><p><strong>时间复杂度</strong>：$O(n)$</p>\n</li>\n</ul>\n<h3>4.7 序列比对问题</h3>\n<ul>\n<li><p><strong>问题</strong>：给定两个序列$S<em>1和S</em>2$，通过一系列的字符编辑（插入、删除、替换）等操作，将$S<em>1转变成S</em>2$，完成这种转换所需要的最少编辑次数称为两个序列的编辑距离</p>\n</li>\n<li><p><strong>算法步骤</strong></p>\n</li>\n<li><p>子问题划分和界定</p>\n<ul>\n<li>$S<em>1[1...n]和S</em>2[1...m]表示两个序列​$，那么子问题就是$S<em>1[1...i]和S</em>2[1...j]​$，边界为$(i,j)​$</li>\n<li>输入：序列$S<em>1，S</em>2，i，j$</li>\n<li>输出：最少编辑距离$C[i,j]$</li>\n</ul>\n</li>\n<li><p>子问题归约</p>\n<p>|          操作          |  归约子问题  | 编辑距离 |\n| :--------------------: | :----------: | :------: |\n|      删除$S<em>1[i]$      |  $(i-1,j)$   |    +1    |\n| $S</em>1[i]后面插入S<em>2[j]$ |  $(i,j-1)$   |    +1    |\n|  $S</em>1[i]替换为S<em>2[j]$  | $(i-1，j-1)$ |    +1    |\n|    $S</em>1[i]=S_2[j]$     | $(i-1，j-1)$ |    0     |</p>\n</li>\n<li><p>优化函数的递推方程</p>\n<p>​   $C[i,j]=min{C[i-1,j]+1,C[i,j-1]+1,C[i-1,j-1]+t[i,j]}$</p>\n<p>​   $C[0,j]=j$</p>\n<p>​   $C[i,0]=i$</p>\n<p>​   $t[i,j]=0，S<em>1[i]=S</em>2[j]$</p>\n<p>​   $t[i,j]=1，S<em>1[i]!=S</em>2[j]$</p>\n</li>\n<li><p>算法伪码</p>\n<p></p>\n<p></p>\n</li>\n<li><p><strong>时间复杂度</strong>：$O(mn)$</p>\n</li>\n</ul>\n<h3>4.8 动态规划算法设计总结</h3>\n<ul>\n<li>引入参数来界定子问题的边界，注意子问题的重叠程度</li>\n<li>给出带边界参数的优化函数定义与优化函数的递推关系，找出递推关系的初值</li>\n<li>判断该优化问题是否满足优化原则</li>\n<li>考虑是否需要标记函数</li>\n<li>采用自底向上的实现奇数，从最小的子问题开始迭代计算，计算中用备忘录保留优化函数和标记函数的值</li>\n<li>动态规划的时间复杂度是对所有子问题（备忘录）的计算量求和（可能需要追踪解的工作量）</li>\n<li>动态规划算法一般使用较多的存储空间，这往往成为限制动态规划算法使用的瓶颈因素</li>\n</ul>\n<h2>五、贪心算法</h2>\n<h3>5.1 贪心算法的基本思想</h3>\n<ul>\n<li><strong>设计要素</strong></li>\n<li>贪心法适用于组合优化问题</li>\n<li>求解过程是多步判断，最终的判断序列对应于问题的最优解</li>\n<li>依据某种短视的贪心选择性质判断，性质好坏决定算法的成败</li>\n<li>贪心法必须进行正确性证明</li>\n<li>证明贪心算法不正确的技巧：举反例</li>\n<li><strong>优势</strong>：算法简单，时间和空间复杂性低</li>\n</ul>\n<h3>5.2 二元前缀码与哈夫曼算法</h3>\n<ul>\n<li><p><strong>问题</strong>：用0-1字符串作为代码表示字符，要求任何字符的代码都不能作为其他字符代码的前缀叫做二元前缀码。给定字符集$C={x<em>1,x</em>2,...,x<em>n}$和每个字符的频率$f(x</em>i)，i=1,2,...,n$，求关于$C$的最优前缀码（平均传输位数最少）</p>\n</li>\n<li><p><strong>输入</strong>：$C={x<em>1,x</em>2,...,x<em>n}，f(x</em>i)，i=1,2,...,n$</p>\n</li>\n<li><p><strong>输出</strong>：队列$Q$</p>\n</li>\n<li><p><strong>哈夫曼算法Huffman(C)</strong>：将所有字符按照频率从小到大的顺序排列，每次取其中最小的两个字符构成一棵二叉树，父节点为两个字符频率之和，然后将这棵树放入集合中，直到集合最后只剩下一棵树</p>\n</li>\n<li><p><strong>算法伪码</strong></p>\n<p><code>pseudocode\nn←|C| //求序列C的长度n\nQ←C       //将序列C按照频率递增排序\nfor i←1 to n-1 do\nz←AllocateNode()        //生成节点z\nz.left←Q中最小元素       //从Q中取出最小元素放入z的左子树\nz.right←Q中最小元素      //从Q中取出最小元素放入z的右子树\nf(z)=f(x)+f(y)          //z的节点值为左右子树节点值之和\ninsert(Q,z)             //将z节点插入到Q中\nreturn Q          //返回Q序列，每个元素的编码为父节点到左节点为0到右节点为1\n</code></p>\n</li>\n</ul>\n<h3>5.3 最小生成树</h3>\n<ul>\n<li><p><strong>问题</strong>：无向连通带权图$G=(V,E,W)$，其中$W为边E的权的集合，G的最小生成树T是包含了G$的所有顶点的树，树中各边权之和$W(T)$称为树的权，具有最小权的生成树称为$G$的最小生成树</p>\n</li>\n<li><p><strong>输入</strong>：$G=(V,E,W)$</p>\n</li>\n<li><p><strong>输出</strong>：$T$</p>\n</li>\n<li><p><strong>算法步骤</strong>：选择边</p>\n</li>\n<li><p><strong>约束条件</strong>：不构成回路</p>\n</li>\n<li><p><strong>截至条件</strong>：边数达到$n-1$</p>\n</li>\n<li><p><strong>Prim算法</strong></p>\n</li>\n<li><p>设计思想：初始集合$S只包括一个节点，然后选择连接集合S和V-S的最短边e={i,j}，$其中$顶点i在集合S中，顶点j在集合V-S中，将e加入T，j加入S。$不断的执行上述过程一直到$S=V$为止</p>\n</li>\n<li><p>算法$Prim(G,E,W)$伪码</p>\n<p><code>pseudocode\nS←{1}   //将第一个顶点放入S集合\nwhile V-S！=NULL do\n从V-S中选择j使得j到S中某一顶点i的边权最小\n将连通i,j的边加入T\n将j加入S\nreturn T\n</code></p>\n</li>\n<li><p><strong>Kruskal算法</strong></p>\n</li>\n<li><p>设计思想：按照边长从小到大排序，依次考虑当前最短边$e$，如果$e与T的边不构成回路$，则把$e加入树T，否则跳过e，直到选择了n-1条边为止$</p>\n</li>\n<li><p>算法$Kruskal(G,E,W)$伪码</p>\n<p><code>\n权从小到大排序E的边，E={e1,e2,...,en}\nT←∞\nrepeat\ne←E中的嘴短编\nif e的两端点不在同一连通分支\nthen 将e加入T\nE←E-{e}\nuntil T包含了n-1条边\n</code></p>\n</li>\n</ul>\n<h3>5.4 单源最短路径问题</h3>\n<ul>\n<li><p><strong>问题</strong>：给定带权有向网络$G=(V,E,W)$，每条边$e=<i,j>的权w(e)为非负实数，表示从i到j$的距离，源点$s在集合V中，求s到其他各个节点的最短路径$</p>\n</li>\n<li><p><strong>输入</strong>：带权有向图$G=(V,E,W)，源点s$</p>\n</li>\n<li><p><strong>输出</strong>：$源点s到有向图其他各个顶点的距离$</p>\n</li>\n<li><p><strong>Dijkstra算法</strong></p>\n</li>\n<li><p>设计思想</p>\n<ol>\n<li><p>初始$S={s}，s到V-S中各个点i相对S的最短路为dist[i]，如果s和i没有边则设为∞$</p>\n</li>\n<li><p>选择其中$dist[i]最小的点j，然后将j加入S，重新计算s到V-S中各个点相对于S的最短$路径$dist值$</p>\n</li>\n<li><p>重复2，直到$S=V为止的dist[i]就是s到其他各个顶点的最短距离$</p>\n</li>\n</ol>\n</li>\n<li><p>算法伪码</p>\n<p><code>pseudocode\nS←{s}\ndist{s}←0\nfor i in V-S do\ndist[i]←w(s,i)  //s到i没边，w(s,i)=∞\nwhile V-S！=NULL do\n从V-S取dist最小的点j\nS←S+j\nfor i in V-S do\nif dist[j]+w[j,i]&lt;dist[i]\nthen dist[i]←dist[j]+w(j,i)\n</code></p>\n</li>\n</ul>\n<h2>六、回溯算法</h2>\n<h3>6.1 回溯算法的基本思想</h3>\n<ul>\n<li><strong>适用</strong>：求解组合搜索问题和优化问题</li>\n<li><strong>求解条件</strong>：满足多米诺性质</li>\n<li>多米诺性质：当向量从$x<em>1,...,x</em>{n+1}满足约束条件，则x<em>1,...,x</em>n满足约束条件，如果n维$向量不满组约束条件，则$n+1维向量也不满足约束条件，可以回溯$</li>\n<li><strong>解的表示</strong>：解向量，求解是不断扩充解向量的过程</li>\n<li><strong>回溯条件</strong></li>\n<li>搜索问题：约束条件</li>\n<li>优化问题：约束条件+代价函数</li>\n<li><strong>搜索空间</strong>：树、节点对应部分解向量，可行解在树叶上</li>\n<li><strong>搜索过程</strong>：采用系统的方法隐含遍历搜索树</li>\n<li><strong>搜索策略</strong>：深度优先、广度优先、函数优先、广深结合等</li>\n<li><strong>节点分支判定条件</strong></li>\n<li>满足约束条件：扩张解向量</li>\n<li>不满足约束条件：回溯到该节点的父节点</li>\n<li><strong>节点状态</strong></li>\n<li>白节点：尚未访问</li>\n<li>灰节点：正在访问该节点为根的子树</li>\n<li>黑节点：该节点为根的子树遍历访问完成</li>\n<li><strong>存储</strong>：当前路径</li>\n<li><strong>设计步骤</strong></li>\n<li>定义解向量和每个分量的取值范围，解向量为$<x_1,x_2,...,x_n>，确定x<em>i的取值集合X</em>i$</li>\n<li>在$<x_1,x_2,...,x_{k-1}>确定后计算x<em>k的取值集合S</em>k,S<em>k是X</em>k的子集$</li>\n<li>确定节点儿子的排列顺序（$S_k的值的排列顺序$）</li>\n<li>判断是否满足多米诺性质</li>\n<li>确定每个节点分支的约束条件</li>\n<li>确定搜索策略：深度优先、广度优先</li>\n<li>确定存储搜索路径的数据结构</li>\n</ul>\n<h3>6.2 回溯算法的实现</h3>\n<ul>\n<li><p><strong>回溯算法的递归实现</strong></p>\n</li>\n<li><p>算法 $ReBack(k)$</p>\n<ul>\n<li><p>算法伪码</p>\n<p><code>pseudocode\nif k&gt;n\nthen &lt;x1,x2,..,xn&gt;是解\nelse while Sk!=null do\nxk←Sk中最小值\nSk←Sk-{xk}\n计算S(k+1)\nReBack(k+1)\n</code></p>\n</li>\n</ul>\n</li>\n<li><p>算法 $ReBackTrack(n)$</p>\n<ul>\n<li><p>输入：n</p>\n</li>\n<li><p>输出：所有的解</p>\n</li>\n<li><p>算法伪码</p>\n<p><code>pseudocode\nfor k←1 to n\n计算Xk且Sk←Xk\nReBack(1)\n</code></p>\n</li>\n</ul>\n</li>\n<li><p><strong>回溯算法的迭代实现</strong></p>\n</li>\n<li><p>算法 $BackTrace(n )$</p>\n<ul>\n<li><p>输入：n</p>\n</li>\n<li><p>输出：所有的解</p>\n</li>\n<li><p>算法伪码</p>\n<p><code>pseudocode\n对于i=1,2,...,n确定Xi\nk←1\n计算Sk\nwhile Sk!=null do\nxk←Sk中最小值\nSk←Sk-{xk}\nif k&lt;n\nthen k←k+1\n计算Sk\nelse\n&lt;x1,x2,...,xn&gt;是解\nif k&gt;1\nthen k←k-1\ngoto 4\n</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3>6.3 组合搜索问题</h3>\n<ol>\n<li><p><strong>船装载问题</strong></p>\n</li>\n<li><p>问题：$有n个集装箱，需要装上两艘载重分别是c<em>1和c</em>2的轮船，w_i为第i个集装箱的重量，问：$是否存在一种合理的装载方案讲$n$个集装箱装上船</p>\n</li>\n<li><p>输入：$W=<w_1,w_2,...,w_n>为集装箱重量，c<em>1和c</em>2为船的最大载重量$</p>\n</li>\n<li><p>输出：集装箱装载方案</p>\n</li>\n<li><p>算法思想：令第一艘船的装载量为$W_1$</p>\n<ul>\n<li>用回溯法求使得$c<em>1-W</em>1$达到最小的装载方案</li>\n<li>满足$w<em>1+w</em>2+...+w<em>n-W</em>1&lt;=c_2$，则返回方案，否则回溯</li>\n</ul>\n</li>\n<li><p>算法伪码**</p>\n<ul>\n<li><p>算法 $Load(W,c_1)$</p>\n<p><code>pseudocode\nSort(W)      //对各个集装箱重量进行排序\nB←c1\nbest←c1\ni←1\nwhile i&lt;=n do\nif 装入i后重量不超过c1\nthen B←B-wi\nx[i]←1     //数组下标为i设为1代表装入第i种货物\ni=i+1\nelse\nx[i]=0     //数组下标为i设为0代表不装入第i种货物\ni=i+1\nif B&lt;best\nthen 记录解\nbest←B\nBacktrace(i)     //回溯i到其父节点\nif i=1\nthen return 最优解\nesle goto 5\n</code></p>\n</li>\n<li><p>算法 $Backtrack(i)$</p>\n<p><code>pseudocode\nwhile i&gt;1 and x[i]=0 do\ni=i-1\nif x[i]=1\nthen x[i]←0\nB←B+wi\ni←i+1\n</code></p>\n</li>\n</ul>\n</li>\n<li><p>时间复杂度：$O(2^n)$</p>\n</li>\n<li><p><strong>图的着色问题</strong></p>\n</li>\n<li><p>问题：输入一个无向连通图$G$和$m$种颜色的集合，用这些颜色给图的顶点着色，要求每条边的两个顶点着不同颜色，输出所有的着色方案</p>\n</li>\n<li><p>输入：$图G=(V,E)，V={1,2,...,n}，颜色编号1,2,...,m$</p>\n</li>\n<li><p>输出：$解向量<x_1,x_2,...,x_n>，x<em>1,x</em>2,..,x_n的值为顶点i的颜色编号$</p>\n</li>\n<li><p>约束条件：在节点$<x_1,x_2,...,x_n>$处顶点$k+1$的邻接表中节点已用过颜色不能再用，如果邻接表中节点已经使用过$m$中颜色，则节点$k+1$没法着色，从该节点回溯到其父节点</p>\n</li>\n<li><p>搜索策略：深度优先</p>\n</li>\n<li><p>时间复杂度：$O(nm^n)$</p>\n</li>\n</ol>\n<h3>6.4 组合优化问题</h3>\n<ol>\n<li><p><strong>分支限界</strong></p>\n</li>\n<li><p>代价函数：在搜索树的节点计算以该点为根的子树所有可行解的目标函数值的上界（极小化问题为下界），对极大化问题父节点代价函数值不小于子节点的代价函数值（极小化问题相反）</p>\n</li>\n<li><p>界：当前得到可行解的目标函数值的最大值（极小化问题相反），当得到更好的可行解时，需要对当前界进行更新</p>\n</li>\n<li><p>分支限界停止分支回溯父节点的依据</p>\n<ul>\n<li>不满足约束条件</li>\n<li>对于极大化问题，代价函数值小于当前界（极小化问题相反）</li>\n</ul>\n</li>\n<li><p><strong>货郎问题</strong></p>\n</li>\n<li><p>问题：有穷个城市，已知每两个城市之间的距离，要求找到一条合适的路线，从某一个城市出发，途径所有城市且每个城市只经过一次再回到起点城市的路径最短</p>\n</li>\n<li><p>输入：$城市集合C={c<em>1,c</em>2,...,c<em>n}，距离d(c</em>i,c<em>j)=d(c</em>j,c_i)$</p>\n</li>\n<li><p>输出：$1,2,...,n的排列k<em>1,k</em>2,...,k<em>n使得：min{\\sum</em>{i=1}^{n-1}d(c<em>{k</em>i},c<em>{k</em>{i+1}})+d(c<em>{k</em>n},c<em>{k</em>1})}$</p>\n</li>\n<li><p>算法设计</p>\n<ul>\n<li><p>解向量为：$<i_1,i_2,...,i_n>$</p>\n</li>\n<li><p>约束条件：$令B={i<em>1,i</em>2,...,i<em>k}，则i</em>{k+1}应该是<i_1,i_2,...,i_n>-B集合中的一个$</p>\n</li>\n<li><p>界：当前得到的最短巡回路线长度</p>\n</li>\n<li><p>代价函数\n$$\nL=\\sum<em>{j=1}^kd</em>j+第j个城市到其他城市的最短距离+所有没走到城市到其他城市的最短距离之和\n$$</p>\n</li>\n</ul>\n</li>\n<li><p>时间复杂度：$O(n!)$</p>\n</li>\n<li><p><strong>圆排列问题</strong></p>\n</li>\n<li><p>问题：给定$n$个圆的半径序列，各圆与底线相切排列，求具有最小长度$l_n$的圆排列顺序</p>\n</li>\n<li><p>输入：$n$个圆的半径序列，$<r_1,r_2,...,r_n>$</p>\n</li>\n<li><p>输出：圆的排列顺序序列，$<i_1,i_2,...,i_n>$</p>\n</li>\n<li><p>算法设计</p>\n<ul>\n<li><p>解向量为：$<i_1,i_2,...,i_n>$</p>\n</li>\n<li><p>约束条件：$令B={i<em>1,i</em>2,...,i<em>k}，则i</em>{k+1}应该是<i_1,i_2,...,i_n>-B集合中的一个$</p>\n</li>\n<li><p>界：当前得到的最小圆排列长度</p>\n</li>\n<li><p>代价函数\n$$\nl<em>n=x</em>k+d<em>{k+1}+d</em>{k+2}+...+d<em>n+r</em>n+r_1\n$$\n其中，$k:$算法已经选择了第1-$k$个圆</p>\n<p>​       $r_k：$第$k$个圆半径</p>\n<p>​       $d_k$：第$k-1$个圆到第$k$个圆的圆心水平距离</p>\n<p>​       $x<em>k$：第$k$个圆的圆心坐标，规定$x</em>1=0$</p>\n<p>​       $d<em>k=\\sqrt{(r</em>k+r<em>{k-1})^2-(r</em>k-r<em>{k-1})^2}=2\\sqrt{r</em>{k-1}r_k}$</p>\n<p>因此，代价函数有\n$$\nl<em>n=x</em>k+2\\sqrt{r<em>kr</em>{k+1}}+2\\sqrt{r<em>{k+1}r</em>{k+2}}+...+2\\sqrt{r<em>{n-1}r</em>n}+r<em>n+r</em>1>=x<em>k+2(n-k)r+r+r</em>1\n$$\n其中，$r$：剩下圆中最小的半径</p>\n</li>\n</ul>\n</li>\n<li><p>时间复杂度：$O((n+1)!)$</p>\n</li>\n<li><p><strong>连续邮资问题</strong></p>\n</li>\n<li><p>问题：给定$n$种不同面值的邮票，每个信封至多贴$m$张，试给出邮票的最佳设计，使得信封上邮票的邮资从1开始，增量为1的连续最大区间</p>\n</li>\n<li><p>输入：邮票面值种数：$n$，信封最多贴邮票数：$m$</p>\n</li>\n<li><p>输出：使得信封上邮资连续递增区间最大的邮票面值序列$<x_1,x_2,...,x_n>，$其中$x_1=1$</p>\n</li>\n<li><p>约束条件：在节点$<x_1,x_2,...,x_i>$处，邮资最大连续区间为${1,...,r<em>i}$，则$x</em>i$的取值范围为${x<em>i+1,...,r</em>i+1}$</p>\n</li>\n<li></li>\n</ol>\n', 3, '贪心算法、动态规划、二分法、回溯法', 'algorithm', '算法分析与设计', 1, 1, 2);
INSERT INTO blog VALUES (2, 3, '## 一、绪论\n\n### 1.1 数据模型\n\n#### 1.1.1 两类数据模型\n\n- **概念模型**：按用户的观点对数据和信息建模，主要用于数据库设计\n- **逻辑模型和物理模型**：逻辑模型是按计算机系统的观点建模，主要用于数据库管理系统的实现。物理模型是对数据最底层的抽象，主要描述数据在系统内部的表示方式和存取方法\n\n#### 1.1.2 概念模型\n\n- **信息世界的基本概念**\n  - **实体**：客观存在且可以相互区分的事物，如人、事、物\n  - **属性**：实体所具有的某一特性，如学生的学号、姓名等\n  - **码**：又称键码，是唯一标识实体的属性，如学生的学号\n  - **实体型**：具有相同属性的实体，用实体名和其属性名集合表示\n  - **实体集**：同一类型的实体，如全体学生\n  - **联系**：实体之间的联系常指不同实体集之间的关系，有一对一、一对多、多对多的关系\n- **概念模型的表示方法**：E-R模型\n\n### 1.2 数据库系统的结构\n\n#### 1.2.1 数据库系统的三级模式\n\n- **模式**：也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。一个数据库只有一个模式。定义模式时不仅要定义数据的逻辑结构还要定义数据之间的关系和安全性、完整性要求。使用模式DDL定义模式\n- **外模式**：也称用户模式，是数据库用户可以看见和使用的局部数据的逻辑和特征的描述，是用户的数据视图，一个数据库可以有多个外模式，使用外模式DDL定义外模式\n- **内模式**：也称存储模式，一个数据库只有一个内模式，是数据物理结构和存储的描述，如数据按升/降存储、使用索引类型、数据是否压缩等\n\n#### 1.2.2 数据库的二级映像\n\n- **外模式/模式映像**：定义了外模式和模式的对应关系，每一个外模式都有一个外模式/模式印象定义其与模式的关系。当模式改变时，改变外模式/模式映像保存外模式不变，从而使应用程序不变\n- **模式/内模式映像**：一个数据库的模式/内模式映像是唯一的，当内模式改变时，改变模式/内模式映像使模式不变，则应用程序不变\n\n## 二、关系数据库 \n\n### 2.1 关系数据结构\n\n#### 2.1.1 关系\n\n- **属性**：表中的一列，每个属性名称叫做属性名\n- **域**：属性值的集合，如学生的年龄在15-25岁，性别的域为男、女\n- **笛卡儿积**：所有域的所有取值的任意组合\n- **关系**：笛卡儿积的子集，一个n目关系必须有n个属性，一个关系对应一张二维表\n- **分量**：元组中的一个属性值\n- **元组**：表中的一行\n- **候选码**：关系中的某一属性组能唯一标识一个元组，而其子集不能，则该属性组称为候选码\n- **主码**：候选码中的一个\n- **主属性**：候选码的属性\n- **非主属性**：不包含在任何候选码的属性\n- **全码**：所有属性都是这个关系的候选码\n- **关系的基本规范条件**：关系的每一个分量必须是一个不可分的数据项，不允许表中还有表\n\n#### 2.1.2 关系模式\n\n- **关系模式**：对关系的描述，一般描述为：关系名(属性1,属性2,...,属性n)，如：学生(学号,性别,年龄,年级)\n\n### 2.2 关系的完整性\n\n- **实体完整性**：关系的主属性值不能为空值\n- **参照完整性**：关系的外码数属性值要么是外码在其表中的某个元组的主属性值，要么是空值\n- **用户定义的完整性**：针对某一具体应用涉及的数据所满足的语义要求，如某个属性值唯一、某个非主属性非空等\n\n## 三、SQL\n\n### 3.1 数据定义\n\n#### 3.1.1 模式的定义与删除\n\n- **定义模式**\n  - 在SQL中，模式定义语句如下\n\n    sql\n    CREATE SCHEMA [<模式名>] AUTHORIZATION <用户名>\n    \n\n    如果模式名缺省，则使用用户名作为模式名，且一个模式相当于一个命名空间，在这个空间可以进一步定义该模式包含的基本表、视图、所有等\n\n- **删除模式**\n\n  - 在SQL中，模式删除语句如下\n\n    sql\n    DROP SCHEMA <模式名> <CASCADE|RESTRICT>\n    \n\n    - CASCADE(级联)：删除模式的同时删除该模式下数据库对象全部删除\n    - RESTRICT(限制)：只有在该模式下没有任何数据库对象才删除，否则拒绝删除\n\n#### 3.1.2 基本表的定义、删除、修改\n\n- **定义基本表**\n\n  - 使用CREATE TABLE定义基本表\n\n    sql\n    CREATE TABLE <表名>(\n    <列名> <数据类> <列级完整性约束条件>,\n    ...\n    <表级完整性约束条件>\n    );\n    \n\n    例如\n\n    sql\n    CREATE TABLE SC(\n    Sno CHAR(9),\n    Cno CHAR(4),\n    Grade SMALLINT NOT NULL,\n    PRIMARY KEY(Sno,Cno),\n    FOREIGN KEY(Sno) REFERENCES Student(Sno),\n    FOREIGN KEY(Cno) REFERENCES Course(Cno)\n    );\n    \n\n    表SC的主键是Sno和Cno两个字段，Sno是外码，参照表是Student表，Cno也是外码，参照表是Course表\n\n- **数据类型**\n\n  |   数据类型   |             描述             |\n  | :----------: | :--------------------------: |\n  |   CHAR(n)    |   定义长度为n的定长字符串    |\n  |  VARCHAR(n)  | 定义最大长度为n的变长字符串  |\n  |     BLOB     |         二进制大文件         |\n  |   SMALLINT   |          2字节整数           |\n  |     INT      |          4字节整数           |\n  |    BIGINT    |          8字节整数           |\n  | DECIMAL(p,d) | p位数字，小数点后面数字为d位 |\n  |   FLOAT(n)   |       精度为n的浮点数        |\n  |  TIMESTAMP   |            时间戳            |\n\n- **修改基本表**\n\n  - SQL使用ALTER TABLE来修改基本表，一般格式为\n\n    sql\n    ALTER TABLE <表名> \n    [ADD <新列名> <数据类型> [完整性约束]]\n    [ADD <表级完整性约束>]\n    [ALTER COLUMN <列名> <数据类型>]\n    [DROP <列名> [RESTRICT|CASCADE]]\n    [DROP CONSTRAINT <完整性约束名> [RESTRICT|CASCADE]]\n    \n\n- **删除基本表**\n\n  - SQL使用DROP TABLE删除基本表，一般格式为\n\n    sql\n    DROP TABLE 表名 [RESTRICT|CASCADE]\n    \n\n#### 3.1.3 索引的建立与删除\n\n- **建立索引**\n\n  - SQL使用CREATE INDEX语句建立索引，一般格式为\n\n    sql\n    CREATE [UNIQUE] [CLUSTER] INDEX <索引名> ON <表名> (列名,列名,...)\n    \n\n- **重命名索引**\n\n  sql\n  ALTER INDEX <旧索引名> RENAME TO <新索引名>\n  \n\n- **删除索引**\n\n  sql\n  DROP INDEX <索引名>\n  \n\n#### 3.1.4 实验用例表\n\n- **学生表**\n\n  |  学号Sno  | 姓名Sname | 性别Ssex | 年龄Sage | 所在系Sdept |\n  | :-------: | :-------: | :------: | :------: | :---------: |\n  | 201215121 |   李勇    |    男    |    20    |     CS      |\n  | 201215122 |   刘晨    |    女    |    19    |     CS      |\n  | 201215123 |   王敏    |    女    |    18    |     MA      |\n  | 201215125 |   张立    |    男    |    19    |     IS      |\n\n- **课程表**\n\n  | 课程号Cno | 课程名Cname | 先行课Cpno | 学分Ccredit |\n  | :-------: | :---------: | :--------: | :---------: |\n  |     1     |   数据库    |     5      |      4      |\n  |     2     |    数学     |            |      2      |\n  |     3     |  信息系统   |     1      |      4      |\n  |     4     |  操作系统   |     6      |      3      |\n  |     5     |  数据结构   |     7      |      4      |\n  |     6     |  数据处理   |            |      2      |\n  |     7     | PASCAL语言  |     6      |      4      |\n\n- **学生选课表**\n\n  |  学号Sno  | 课程号Cno | 成绩Grade |\n  | :-------: | :-------: | :-------: |\n  | 201215121 |     1     |    92     |\n  | 201215121 |     2     |    85     |\n  | 201215121 |     3     |    88     |\n  | 201215122 |     2     |    90     |\n  | 201215122 |     3     |    80     |\n\n### 3.2 数据查询\n\n#### 3.2.1 单表查询                                                                                                                                                                                                                                                                                                                                                                                                                                                \n\n- **选择表中若干列**\n\n  - 查询指定列：查询学生学号和姓名\n\n    sql\n    SELECT Sno,Sname FROM Student;\n    \n\n  - 查询所有列：查询所有学生信息\n\n    sql\n    SELECT * FROM Student;\n    \n\n  - 查询计算过的值\n\n    - 目标表达式为计算公式并起别名：查询所有学生姓名，使用2014-年龄作为Birtday值\n\n      sql\n      SELECT Sname,2018-Sage Birthday FROM Student;\n      \n\n    - 目标表达式为字符串常量和函数：查出所有学生姓名、加上一列为Year of Birth，并将所在系名全部小写\n\n      sql\n      SELECT Sname,\'Year of Birth\'，Lower(Sdept) FROM Student;\n      \n\n    - 去除重复值：查询选课表中学生不重复学号\n\n      sql\n      SELECT DISTINCT Sno FROM SC;\n      \n\n- **WHERE子句**\n\n  - 常用的查询条件\n\n    | 查询条件 |                谓词                 |\n    | :------: | :---------------------------------: |\n    |   比较   |           =,>,<,>=,<=,!=            |\n    | 确定范围 |     BETWEEN AND,NOT BETWEEN AND     |\n    | 确定集合 | IN(值1,值2,...),NOT IN(值1,值2,...) |\n    | 字符匹配 |            LIKE,NOT LIKE            |\n    |   空值   |         IS NULL,IS NOT NULL         |\n    | 多重条件 |             AND,OR,NOT              |\n\n  - 确定范围：查询年龄在20-23岁之间的所有学生信息\n\n    sql\n    SELECT * FROM Student WHERE Sage BETWEEN 20 AND 23;\n    \n\n  - 确定集合：查询CS系、MA系和IS系的所有学生信息\n\n    sql\n    SELECT * FROM Student WHERE Sdept IN(\'CS\',\'MA\',\'IS\');\n    \n\n  - 字符匹配\n\n    - LIKE：匹配任意长度字符\n\n    - _：匹配单个字符\n\n    - 匹配‘_’：查询DB_Design这门课的学分和课程号\n\n      sql\n      SELECT Cno,Ccredit FROM Course where Cname LIKE \'DB\\_%\' ESCAPE \'\\\';\n      \n\n  - 空值查询：使用IS NULL或者IS NOT NULL，不能使用=代替IS\n\n  - 多重条件查询：AND的优先级比OR高，IN实际上可以使用多个OR代替\n\n- **ORDER BY子句**\n\n  - 默认升序ASC，降序为DESC，当按多个字段排序时，前面字段的优先级高于后面字段优先级\n\n  - 查询全体学生情况，按照所在系的系名升序排序，同一系按照年龄降序排序\n\n    \n    SELECT * FROM Student ORDER BY Sdept,Sage DESC;\n    \n\n- **聚合函数**\n\n  - 主要的聚合函数\n\n    |           函数           |                 描述                 |\n    | :----------------------: | :----------------------------------: |\n    |         COUNT(*)         |             统计元组行数             |\n    | COUNT([DISTINCT] <列名>) |           统计某列数据行数           |\n    |  SUM([DISTINCT] <列名>)  |  统计某列总和，该列元素必须是数值型  |\n    |  AVG([DISTINCT] <列名>)  | 统计某列平均值，该列元素必须是数值型 |\n    |  MAX([DISTINCT] <列名>)  |            统计某列最大值            |\n    |  MIN([DISTINCT] <列名>)  |            统计某列最小值            |\n\n  - 查询选修1号课程的学生最高分数\n\n    sql\n    SELECT MAX(Grade) FROM SC WHERE Cno=\'1\';\n    \n\n  - 除了COUNT(*)外，其他聚合函数只处理非NULL值，某个元组中部分元素为NULL不影响COUNT(\\*)\n\n  - 聚合函数主要用于SELECT子句和GROUP BY中的HAVING子句中，不能出现在WHERE子句中\n\n- **GROUP BUY子句**\n\n  - GROUP BY子句会将查询结果按某一列或多列值进行分组，值相等的为为一组，分组后在HAVING子句中聚合函数作用于每一个分组\n\n  - 查询修了三门课以上的学生的学号\n\n    sql\n    SELECT Sno FROM SC GROUP BY Sno HAVING COUNT(*)>3; \n    \n\n  - WHERE和HAVING的区别\n\n    - WHERE子句作用的对象是基本表或者视图，HAVING作用于分组\n\n#### 3.2.2 连接查询\n\n- **关系数据库执行连接查询的两种方式**\n\n  - 套嵌循环连接：如果没有索引，则对于表1的每个元组，遍历表2所有元组，找到符合条件的元组和表一元组拼接起来，直到将表1的所有元组都处理完毕\n  - 如果表2建立了索引，则每次不需要扫描表2全表，而是根据索引值找到表2相应的元组和表1的元组拼接起来\n\n- **等值连接和非等值连接**：当连接条件中出现“=”为等值连接，使用其他运算符为非等值连接，若在等值连接中，将目标中重复的属性列去掉为自然连接\n\n  - 使用自然连接查询选课学生的情况\n\n    sql\n    SELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade FROM Student,SC WHERE Student.Sno=SC.Sno;\n    \n\n  - 使用复合条件查询选修2号课程且成绩大于90分的学生学号和姓名\n\n    sql\n    SELECT Student.Sno,Sname FROM Student,SC Where Student.Sno=SC.Sno AND Cno=\'2\' AND Grade>\'90\';\n    \n\n- **自连接**：基本表自己和自己进行连接操作，需要给自己起两个别名进行区分\n\n  - 查询所有课程和其第二直接先行课（先行课的先行课）\n\n    sql\n    SELECT FIRST.Cno,SECOND.Cpno FROM Course FIRST,Course SECOND WHERE FISRST.Cpno=SECOND.Cno;\n    \n\n- **外连接**：分为左连接和右连接，左连接列出左边的表的所有元组，右连接列出右边的表的所有元组\n\n  - 查询所有学生的选课信息，如果某学生没有选课则该学生的课程信息为NULL\n\n    sql\n    SELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade FROM Student LEFT OUTER JOIN SC ON (Student.Sno=SC.Sno);  \n    \n\n- **多表连接**：两个以上的表进行连接\n\n  - 查询所有学生的选课信息，包括学生学号、姓名、课程名、成绩等\n\n    sql\n    SELECT Student.Sno,Sname,Cname,Grade FROM Student,Course,SC WHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno;\n    \n\n#### 3.2.3 嵌套查询\n\n- **概念**：一个\"SELECT-FROM-WHERE\"为一个查询块，将一个查询块嵌套到另一个查询块的WHERE或HAVING子句中称为嵌套查询，外层查询块叫做父查询，内层查询块叫做子查询，子查询块不能使用ORDER BY语句\n\n- **带IN的子查询**\n\n  - 查询与“刘晨在同一系的所有学生信息”\n\n    sql\n    SELECT * FROM Student WHERE Sdept IN(SELECT Sdept FORM Student WHERE Sname=\'刘晨\';)\n    \n\n    此条子查询的查询条件不依赖父查询，称作不相关子查询。也可以使用自连接：\n\n    sql\n    SELECT FIRST.* FROM Student FIRST,Student SECOND WHERE FIRST.Sdept=SECONDE.Sdept AND SECOND.Sname=\'刘晨\';\n    \n\n  - 查询选修了信息系统这门课的学生学号和姓名\n\n    sql\n    SELECT Sno,Sname FROM Student WHERE Sno IN(SELECT Sno FROM SC WHERE Cno IN(SELECT Cno FROM Course WHERE Cno=\'信息系统\'));\n    \n\n    此条子查询语句也是不相关子查询，也可以使用自查询实现，且由于目前关系型数据库对子查询的优化做的还不够完善，在实际应用中能使用连接查询尽量使用连接查询\n\n    sql\n    SELECT Student.Sno,Sname FROM Student,Course,SC WHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno AND Course.Cname=\'信息系统\';\n    \n\n- **带运算符的子查询**：当用户确切知道内层查询返回的是单个值时，可以使用“>”、“<”、“=”、“>=”、“<=”、“!=”、\"=\"等比较运算符进行比较\n\n  - 查询每个学生成绩超过他平均成绩的课程号\n\n    sql\n    SELECT Sno,Cno FROM SC FIRST WHERE Grade>(SELECT AVG(Grade) FROM SC SECOND WHERE FIRST.Sno=SECOND.Sno);\n    \n\n    此种子查询的查询条件和父查询块有关，也叫做相关子查询\n\n- **带ANY或者ALL的子查询**：当子查询返回值为多值时，需要使用比较运算符和ANY或ALL配合进行查询\n\n  - 查询非计算机系中比计算机系任意一个学生年龄都小的学生姓名和年龄\n\n    sql\n    SELECT Sname,Sage FROM Student WHERE Sage<ANY(SELECT Sage FROM Student WHERE Sdept=\'CS\') AND Sdept!=\'CS\';\n    \n\n    上述子查询也可以使用聚合函数实现\n\n    sql\n    SELECT Sname,Sage FROM Student WHERE Sage<(SELECT MAX(Sage) FROM Student WHERE Sdept=\'CS\') AND Sdept!=\'CS\';\n    \n\n  - 查询非计算机系中比计算机系所有学生年龄都小的学生姓名和年龄\n\n    sql\n    SELECT Sname,Sage FROM Student WHERE Sage<ALL(SELECT Sage FROM Student WHERE Sdept=\'CS\') AND Sdept=\'CS\';\n    \n\n    上述子查询也可以使用聚合函数实现\n\n    sql\n    SELECT Sname,Sage FROM Student WHERE Sage<(SELECT MIN(Sage) FROM Student WHERE Sdept=\'CS\') AND Sdept!=\'CS\';\n    \n\n  - ANY或ALL的子查询都可以转换成带MAX或MIN以及IN的子查询\n\n- **带EXISTS或NOT EXISTS的子查询**：带EXISTS或NOT EXISTS的子查询只返回True或者False，且带EXISTS或NOT EXISTS的子查询目标列表达式一般都为“*”\n\n  - 查询所有选修了1号课程的学生姓名\n\n    sql\n    SELECT Sname FROM Student WHERE EXISTS(SELECT * FROM SC WHERE Student.Sno=SC.Sno AND Cno=\'1\');\n    \n\n    该条查询语句的查询执行过程为先从父查询取出一个元组，将元组的信息放入子查询的判断条件，若返回true，则将这个元组放入结果表，直到父查询表检查完\n\n- **基于派生的子查询**：子查询不仅可以出现在WHERE或者HAVING子句中，也可以出现在FROM子句中\n\n#### 3.2.4 集合查询\n\n- **集合查询**：使用UNION（并）、INTERSECT（交）、EXCEPT（差）连接两个SELECT语句\n\n  - 查询计算机系年龄不大于19岁的学生\n\n    sql\n    SELECT * FROM Student WHERE Sdept=\'CS\' UNION SELECT * FROM Student WHERE Sage<=19;\n    \n\n    上述查询也可以直接使用AND在一条SELECT语句实现\n\n### 3.3 数据更新\n\n#### 3.3.1 插入数据\n\n- **插入元组**\n\n  - 将一个新生学生元组（学号：201215128，姓名：陈冬，性别：男，所在系：IS，年龄：18岁）插入到Student表中\n\n    sql\n    INSERT INTO Student(Sno,Sname,Sage,Sdept,Sage) values(\'201215128\',\'陈冬\',\'男\',\'IS\',18);\n    \n\n- **插入子查询结果**\n\n  - 有一个新表Dept_age，表中一个属性为系名，另一个属性为该系的学生平均年龄，从Student表将数据插入到Sdept_age表中\n\n    sql\n    INSERT INTO Sdept_age(Sdept,Sage) SELECT Sdept,AVG(age) FROM Student GROUP BY Sdept;\n    \n\n### 3.3.2 修改数据\n\n- **修改元组**\n\n  - 将学号为201215121的学生年龄改为22岁\n\n    sql\n    UPDATE Student SET Sage=22 WHERE Sno=201215121;\n    \n\n- **带子查询的修改元组**\n\n  - 将计算机系全体学生的成绩置为0\n\n    sql\n    UPDATE SC SET Grade=0 WHERE Sno IN(SELECT Sno FROM Student WHERE Sdept=\'CS\'); \n    \n\n### 3.3.3 删除数据\n\n- **删除元组**\n\n  - 删除学号为201215128的学生记录\n\n    sql\n    DELETE FROM Student WHERE Sno=201215128;\n    \n\n- **带子查询的删除元组**\n\n  - 删除计算机系的所有同学的选课记录\n\n    sql\n    DELETE FROM SC WHERE Sno IN(SELECT Sno FROM Student WHERE Sdept=\'CS\');\n    \n\n### 3.4 视图\n\n- **建立视图**\n\n  - 建立视图的一般格式为\n\n    sql\n    CREATE VIEW <视图名> ([<列名1>,[<列名2>],...) AS <子查询> [WITH CHECK OPTION];\n    \n\n    WITH CHECK OPTION的作用是要求在对视图进行INSERT、UPDATE、DELETE等操作时更新的数据需要满足子查询中的条件表达式\n\n- **删除视图**\n\n  - 删除视图的一般格式为\n\n    sql\n    DROP VIEW <视图名> [CASCADE];\n    \n\n- **视图的作用**\n\n  - 简化用户的操作\n  - 使用户以多种角度看待同一数据\n  - 对重构数据库提供了一定逻辑独立性\n  - 对机密数据提供安全保护\n  - 更清晰的查询表达\n\n### 3.5 数据库的授权与收回\n\n#### 3.5.1 授权\n\n- SQL授权的格式为：GRANT <权限> [,<权限>...] ON <对象类型> <对象名> [,<对象类型> <对象名>...] TO <用户> [<用户>...] \\[WITH GRANT OPTION]\n\n  - 如果指定了WITH GRANT OPTION子句，则获得某种权限的用户还可以将次权限授权给其他用户\n\n- 权限可以是表的所有属性的操作，如将查询Student表的权限授权给U1\n\n  sql\n  GRANT SELECT ON TABLE Student TO U1;\n  \n\n- 权限也可以是对表中的某一个属性，如将查询Student表的学号的权限授权给U2\n\n  sql\n  GRANT SELECT(Sno) ON TABLE Student TO U2;\n  \n\n- 也可以同时将所有权限授权，所有权限使用ALL PRIVILEGES，如将表Student的所有权限授权给U3\n\n  sql\n  GRANT ALL PRIVILEGES ON TABLE Student TO U3;\n  \n\n- 也可以同时将权限授权给所有人，所有用户使用PUBLIC，如将Student表的查询权限授权给所有用户\n\n  sql\n  GRANT SELECT ON TABLE Student TO PUBLIC;\n  \n\n#### 3.5.2 回收权限\n\n- SQL回收权限的格式为：REVOKE <权限> [,<权限>...] ON <对象类型> <对象名> [,<对象类型> <对象名>...] FROM  <用户> [,<用户>...] \\[CASCADE|RESTRICT]\n\n#### 3.5.3 数据库角色\n\n- 数据库角色是某一类权限的集合，可以采用将权限授权给某一角色，然后使用角色授权给用户的方法简化授权过程\n- 数据库角色授权过程为\n  - 创建角色：CREATE ROLE <角色名>;\n  - 授权给角色：GRANT <权限> [,<权限>...] ON <对象类型> <对象> [,<对象类型> <对象>...] TO <角色> [,<角色>...] \\[WITH ADMIN OPTION]\n  - 将角色授权给用户：GRANT <角色> TO <用户>\n- 数据库角色的回收使用REVOKE\n\n## 四、数据库完整性\n\n### 4.1 实体完整性\n\n- **实体完整性的定义**：在创建表语句中使用PRIMARY KEY定义实体完整性，当有多个属性构成的码需要使用表级约束条件\n- **实体完整性检查和违约处理**：定义完实体完整性后，对每条插入的记录都对主码列进行检查，检查的内部包括：非空检查和唯一检查。检查的方法之一是进行全表扫描，但是十分费时。一般关系型数据库都会在主码上建立索引，通过索引从B+树进行查找\n\n### 4.2 参照完整性\n\n- **参照完整性的定义**：在创建表语句中使用FOREIGN KEY...REFERENCE语句定义外码\n\n- **参照完整性检查和违约处理**：对于被参照表和参照表中的某些操作可能破坏参照完整性的情况和违约处理如下表\n\n  |                    被参照表（如Student）                     |                 参照表（如SC）                 |      违约处理      |\n  | :----------------------------------------------------------: | :--------------------------------------------: | :----------------: |\n  |                                                              |      插入元素（外键值在被参照表中不存在）      |        拒绝        |\n  |                                                              | 修改外码值（修改后的外键值在被参照表中不存在） |        拒绝        |\n  | 修改主码值（导致参照表中引用原主码值的外键值在被参照表中不存在） |                                                | 拒绝/级联/设为空值 |\n  | 删除元组（导致参照表中引用删除元组主码值的外键值在被参照表中不存在） |                                                | 拒绝/级联/设为空值 |\n\n  - 拒绝：当发生不一致时，不允许执行该操作，该策略一般为默认策略\n  - 级联：当删除或修改被参照表的一个元组导致与参照表不一致时，删除或修改参照表中所有不一致的元组\n  - 设为空值：当删除或修改被参照的一个元组导致与参照表不一致时，将参照表的所有不一致的对应属性设为NULL\n\n### 4.3 用户定义的完整性\n\n- **用户定义的完整性的定义**：可以定为列级或者表级约束，包括\n  - NOT NULL（非空）\n  - UNIQUE（唯一）\n  - CHECK（检查值是否满足条件表达式）\n- **违约处理**：如果行级或者表级的完整性约束没有被满足时，操作将会被拒绝执行\n\n## 五、关系数据理论\n\n### 5.1 关系数据库\n\n#### 5.1.1 数据依赖\n\n- **函数依赖**：在属性之间，当某一个属性被确定以后，其他的属性也能唯一的确定，则其他属性函数依赖于某一属性。如学生表包括学号（Sno）、姓名（Sname）、系（Sdept），当学号确定之后，学生姓名和系也能唯一确定，记作Sno→Sname，Sno→Sdept，Sname和Sdept依赖于Sno\n- **完全函数依赖**：X→Y，X中的每个属性都能完全唯一的确定Y，如Sno→Sdept\n- **部分函数依赖**：X→Y，X中的部分属性能完全唯一确定Y，如(Sno,Cno)→Sdept\n- **传递函数依赖**：如果X→Y，Y→Z，则Z传递依赖于X，如Sno→Sdept，Sdept→Mname，则Mnae传递依赖于Sno\n\n#### 5.1.2 存在的问题\n\n- 如果只考虑函数依赖这一种数据依赖，将所有属性放到一张表中，会出现以下问题，加入有学生学号（Sno）、课程号（Cno）、课程成绩（Grade）、系名（Sdept）、系主任（Mname）等属性\n  - **数据冗余**：比如每个系的系主任姓名重复出现\n  - **更新异常**：当某个系换主任时，必须修改所有该系的学生的每个元组\n  - **插入异常**：若一个系刚成立，有系名、系主任，但是还没有学生，就无法将系的信息保存进数据库\n  - **删除异常**：如果某个系的学生全部毕业了，删除这些学生的信息会将系名和系主任一同删除\n\n### 5.2 规范化\n\n- **范式**：关系数据库满足不同程度要求的为不同范式，一个低一级的范式可以通过模式分解为若干个高一级范式的集合\n- **第一范式**：属性不可分，每一个分量都是不可分的数据项\n- **第二范式**：在满足第一范式的基础上，每一个非主属性完全依赖于任何一个候选码，如果一个关系满足第一范式不满组第二范式，则可以通过投影分解将其分解为若干个满足第二范式的关系\n- **第三范式**：在满足第二范式的基础上，每一个非主属性不传递依赖于候选码，可以通过投影分解将满足第二范式而不满足第三范式的关系分解为多个满足第三范式的关系集合\n- **BC范式**\n- **第五范式**\n\n## 六、数据库设计\n\n### 6.1 数据库设计的一般步骤\n\n- 需求分析\n- 概念结构设计\n- 逻辑结构设计\n- 物理结构设计\n- 数据库实施\n- 数据库运行和维护\n\n### 6.2 概念结构设计\n\n#### 6.2.1 E-R模型\n\n- **实体之间的联系**\n  - 一对一联系（1:1）\n  - 一对多联系（1:n）\n  - 多对多联系（n:m）\n- **E-R图**\n  - 实体使用矩形表示，矩形框内写明实体名\n  - 属性用椭圆表示，并用无向边将其对应的实体连接起来\n  - 联系用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1、1:n、n:m）\n\n#### 6.2.2 概念结构设计\n\n- 属性划分原则\n  - 作为属性，不能再具有需要描述的性质\n  - 属性与其他实物不能具有联系\n\n### 6.3 逻辑结构设计\n\n#### 6.3.1 E-R图向关系转换\n\n- 一个1:1的联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并\n- 一个1:n的联系可以转换为一个独立的关系模式，也可以与n端对应的关系合并\n- 一个m:n的联系转换为一个关系模式\n- 三个三个以上实体间的一个多元联系可以转换为一个关系模式\n- 具有相同的码的关系可以合并\n\n#### 6.3.2 数据模型的优化\n\n- 确定数据依赖\n- 对各关系间的数据依赖进行极小化处理\n- 确定各关系模式属于第几范式\n- 进某些模式进行合并和分解\n- 对关系模式进行必要分解，常用的有水平分解和垂直分解\n\n### 6.4 物理结构设计\n\n#### 6.4.1 关系模式存取方法选择\n\n- **索引**\n  - B+树索引存取方法的选择\n    - 如果一个或一组属性经常在查询条件出现，考虑在这个或这组属性建立索引或者组合索引\n    - 如果一个属性经常作为最大值和最小值等聚集函数的参数，考虑在这个属性建立索引\n    - 如果一个或一组属性经常在连接操作的连接条件中出现，则考虑在这个或这组属性上添加 索引\n  - hash索引存取方法的选择：如果一个或一组属性主要出现在等值连接条件中或者等值比较选择条件中，而且满足以下情况之一，则可以选择hash索引方法\n    - 一个关系的大小可预知而且不变\n    - 关系的大小动态改变，但是数据库管理系统提供了动态hash存取方法\n- **聚簇**\n  - 概念：为了提高某个或某组属性的查询速度，将这些属性上具有相同值的元组放在连续的物理块中称为聚簇，该属性称为聚簇码，一个数据库可以有多个聚簇，一个关系只能有一个聚簇\n  - 聚簇方法的选取\n    - 首先设计候选聚簇\n      - 对经常在一起进行连接操作的关系可以建立聚簇\n      - 如果一个关系的一组属性经常出现在连接操作中，该单个关系可以建立聚簇\n      - 如果一个关系的一组属性重复的值比较多，此关系可以建立聚簇\n    - 从候选聚簇取消不必要的关系\n      - 从聚簇中删除经常全表扫描的关系\n      - 从聚簇中删除连接远小于更新的关系\n      - 从多个聚簇方案选择最优聚簇\n\n## 七、关系查询处理和查询优化\n\n### 7.1 查询处理\n\n#### 7.1.1 选择操作的实现\n\n- **简单的全表扫描算法**：只需要较少的内存就能实现，当表的规模较小时，这种算法十分有效，当表的规模很大且选择率低时效率很低\n- **索引扫描算法**：如果条件中的属性上有索引，通过索引先找到满足条件的元组指针，再通过元组指针在查询的基本表中找到元组，当选择率低时，采用索引的选择算法效率高于全表扫描算法\n\n#### 7.1.2 连接操作的实现\n\n- **嵌套循环法**：对外层表的每一个元组，检查内层表的所有元组，满足连接条件的作为结果输出，知道外层表的所有元组处理完毕\n- **排序-合并算法**：先将参与连接的表按照连接属性排序，对于外表的每个元组，依次扫描内层表中具有相同连接属性值的元素知道扫描到与外层表元组连接属性不同的元组时，返回外层表的下一个元组，然后再对内层表进行扫描，重复直到外层表都被扫描\n- **索引连接算法**：在内层表对连接属性建立起索引，对于外层表的每个元组，在内层表通过索引查找对应的元组，重复直到外层表都被扫描\n- **hash连接算法**：将连接属性作为hash码，用同一个hash函数将外层表和内层表进行散列，然后通过相同hash值进行连接\n\n### 7.2 查询优化\n\n#### 7.2.1 代数优化\n\n- 代数优化就是通过对关系代数表达式的等价交换来提高查询效率\n\n#### 7.2.2 物理优化\n\n- **基于启发式规则的存取路径选择优化**\n  - 选择操作的启发式规则\n    - 对于小关系，进行全表扫描，即使选择列上有索引\n    - 对于大关系\n      - 对于选择条件是“主码=值”的查询，查询结果只有一个元组，可以选择主码索引\n      - 对于选择条件是“非主属性=值”，并且选择列上有索引，估算查询结果的元组数目，如果比例较小（<10%）可以使用索引扫描，否则使用全表扫描\n      - 对于选择条件是属性上的非等值查询或者范围查询，估算查询结果元组数目，如果比例小于10%，使用索引扫描，否则依然是全表扫描\n      - 对于用AND连接的组合条件，如果有涉及这些条件的组合索引，则优先选择组合索引，如果某些属性上有索引，则可以先使用索引找到满足相应条件的元组，再从这些元组中使用全表扫描得到满足剩下条件的元组，否则使用全表扫描\n      - 用OR连接的选择条件，一般使用全表扫描\n  - 连接操作的启发式规则\n    - 如果两个表已经按照连接条件排好序，使用排序-合并算法\n    - 如果一个边在连接属性上有索引，采用索引连接法\n    - 如果其中一张表比较小，上述都不适用，采用hash连接算法\n    - 最后使用嵌套循环算法，选择较小的那张表为外层表\n- **基于代价估算的优化**\n  - 统计信息\n  - 代价估算\n  - 选择代价最小的方式\n\n## 八、数据库恢复技术\n\n### 8.1 事务的基本概念\n\n#### 8.1.1 事务\n\n- 事务是用户定义的一个数据库操作序列，这些操作要么全部执行，要么全不执行\n\n#### 8.1.2 事务的特性\n\n- **原子性**：事务是数据库的逻辑工作基本单位，事务中包含的操作要么都做，要么都不做\n- **一致性**：事务的执行结果必须使数据库从一个一致性状态编导另一个一致性状态\n- **隔离性**：并发的各个事务之间是隔离的，互不影响\n- **永久性**：一个事务一旦提交，其对数据库的改变是永久的\n\n### 8.2 故障的种类\n\n- 事务内部的故障\n- 系统故障\n- 介质故障\n- 计算机病毒\n\n### 8.3 恢复的实现技术\n\n- 数据转储\n- 登记日志文件\n\n## 九、并发控制\n\n### 9.1 并发操作带来的数据库不一致性问题\n\n#### 9.1.1 丢失修改\n\n- 并发操作下，某一事务的提交破坏其他事务对同一数据的修改\n\n#### 9.1.2 不可重复读\n\n- 指事务A读取数据后，事务B对数据进行修改，导致数据A无法再现前一次读取结果，主要包括三种情况\n  - 事务A读取某个数据的值，事务B修改这一数据的值导致事务A再次读取这一数据的值发生了改变\n  - 事务A读取了某些数据记录后，事务B将这些数据删除一部分，事务A再次读取这些数据时，发现数据数量发生了改变\n  - 事务A读取了某些数据记录后，事务B插入一些记录，当事务A再次以相同的条件查询数据时，发现多了一些记录\n- 后两种也叫幻影读\n\n#### 9.1.3 读脏数据\n\n- 主要是指事务读取到其他事物未提交的数据\n\n### 9.2 事物的隔离级别\n\n- 读未提交：事务中的修改即使没有提交对其他事务也是可见的，会出现脏读、不可重复读、幻读\n- 读已提交：一个事务所作的修改在提交之间对其他事务是不可见的，会出现不可重复读、幻读\n- 可重复读：保证同一个事务多次读取同样的数据的结果是一样的，会出现幻读\n- 可串行化：强制事务串行执行\n\n### 9.3 封锁和封锁协议\n\n#### 9.3.1 封锁类型\n\n- 排他锁（写锁/X锁）：当某一事物对数据对象加上X锁，则只允许该事务对此数据对象进行读和写，不允许其他事务对此数据对象加X锁或者S锁\n- 共享锁（读锁/S锁）：当某一事物对数据对象加上S锁，则该事务可以对数据对象读不允许写，其他事务也可以对数据对象加S锁不能加X锁\n\n#### 9.3 .2 封锁协议\n\n- **一级封锁协议**：事务在修改数据前必须加X锁，直到事务结束才释放。不能保证不可重复读和脏读\n- **二级封锁协议**：在一级封锁协议的基础上加上事务在读取数据前必须加S锁，直到读完。不能保证不可重复读\n- **三级封锁协议**：在一级封锁协议的基础上加上事务在读取数据前必须加S锁，直到事务结束\n\n### 9.4 活锁和死锁\n\n#### 9.4.1 活锁\n\n- 当多个事务请求同一个锁时，某个事物可能会永远都在等待而获取不到锁\n- 避免活锁的简单办法是采用先到先服务的策略\n\n#### 9.4.2 死锁\n\n- 事物A1申请了锁R1，事物A2申请了锁R2，紧接着事物A1又想申请R2，A2又想申请R1，两个事物都互相等待对方释放锁，形成死锁\n- **死锁的预防**\n  - 一次封锁法：要求每个事物将其索要使用的数据一次全部加锁。这种方法会加大封锁范围，降低并发度\n  - 顺序封锁法：对数据对象规定一个封锁顺序，所有的事务都按照这个顺序进行封锁\n- **死锁的诊断**\n  - 超时法：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁\n  - 等待图法：事务的等待图是一个有向图，如果存在回路就认为发生了死锁\n- **死锁解除**\n  - 选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有的锁，是其他事务运行下去\n\n### 9.5 两段封锁协议\n\n- 目前数据库使用两段封锁协议实现并发的可串行化，两段封锁协议是指所有事物分两个阶段对数据进行加锁和解锁\n  - 在对任何事物读、写操作之前，首先要申请获得对该数据的加锁\n  - 在释放一个封锁之后，事务不再申请和获得其他任何封锁\n\n### 9.6 封锁的粒度\n\n#### 9.6.1 多粒度封锁\n\n- **封锁粒度**：封锁对象的大小，封锁粒度越大，并发度越小，系统开销越小，封锁粒度越小，并发度越大，系统开销越大\n- **多粒度封锁**：一个系统中支持多种封锁的粒度供不同的事物选择，这种封锁称为多粒度封锁\n- **多粒度树**：多粒度树的根节点为整个数据库，表示最大粒度，叶节点为最小粒度。如三级粒度树从根节点到叶节点分别为：数据库-关系-元组。\n- **多粒度封锁协议**：多粒度封锁协议允许多粒度树种每个节点被独立加锁，则该节点的子孙节点也被加以同样的锁。因此分为显式加锁和隐式加锁\n  - 显式加锁：应事物的要求直接加到数据对象上的锁\n  - 隐式加锁：该数据对象没有被独立加锁，而是由于其上级节点加锁而使该对象加了锁\n  - 缺点：多粒度加锁中，显式加锁和隐式加锁的效果都是一样的，因此系统在检查锁冲突时不仅要检查显式加锁还要检查隐式加锁。如果某一个事物需要对数据对象加锁，首先检查该数据对象上是否有无显式加锁与之冲突，再检查该数据对象的上级节点，看本事务的显式加锁是否与该数据对象上的隐式加锁冲突，最后检查其所有的下级节点，看它们的显式加锁是否和本事务的显式加锁冲突\n\n#### 9.6.2 意向锁\n\n- **意向锁**：为了解决多粒度封锁协议加锁不仅要检查数据对象上的锁还要检查其上级节点和下级节点的显式加锁，引入了意向锁，如果对一个节点加意向锁，则说明该节点的下层节点正在被加锁。对任一节点加锁必须先对其上层节点加意向锁，例如对任一元组加锁时，必须先对其所在数据库和关系加意向锁\n- **意向锁的分类**\n  - IS锁：对一个数据对象加IS锁，表示它的子孙节点将加S锁\n  - IX锁：对一个数据对象加IX锁，表示它的子孙节点将加X锁\n  - SIX锁：对一个数据对象加SIX锁，表示对它加S锁再加IX锁\n\n### 9.7 多版本并发控制（MVCC）\n\n#### 9.7.1 多版本并发控制概念及实现\n\n- **概念**：是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别，而读未提交这种隔离级别总是读取最新的数据行，无需用MVCC，可串行化隔离级别需要对所有读取的行都加锁，单纯的使用MVCC无法实现\n\n- **版本**：是指数据库中数据对象的一个快照，记录了数据对象在某个时刻的状态\n\n  - 系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增\n  - 事物版本号：事务开始时的系统版本号\n\n- **隐藏的列**：MVCC在每行记录后面都保存着两个隐藏的列，用来存储两个版本号\n\n  - 创建版本号：创建一个数据行的快照时的系统版本号\n  - 删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除\n\n- **实现过程**\n\n  - 当开启一个新的事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号\n\n  1. SELECT：多个事务必须读取到同一个数据行最近的一个有效快照，该快照的创建版本号必须小于事务的版本号，快照的删除版本号必须大于事务的版本号\n  2. INSERT：将当前系统版本号作为快照创建版本号\n  3. DELETE：将当前系统版本号作为快照删除版本号\n  4. UPDATE：将当前系统版本号作为更新前数据行快照的删除版本号，并将当前系统版本号作为更新后数据行的快照创建版本号，可以理解先执行DELETE再执行INSERT\n\n#### 9.7.2 NEXT-KEY LOCKS\n\n- 是指MySQL的InnoDB存储引擎的一种锁实现，MVCC不能解决幻读的问题，Next-Key Locks就是为了解决幻读，在可重复读隔离级别下，使用MVCC+Next-Key Locks可以解决幻读\n- Next-Key Locks不仅锁定一个记录上的所有还锁定索引之间的间隙', '2019-02-16 11:38:03', '<h2>一、绪论</h2>\n<h3>1.1 数据模型</h3>\n<h4>1.1.1 两类数据模型</h4>\n<ul>\n<li><strong>概念模型</strong>：按用户的观点对数据和信息建模，主要用于数据库设计</li>\n<li><strong>逻辑模型和物理模型</strong>：逻辑模型是按计算机系统的观点建模，主要用于数据库管理系统的实现。物理模型是对数据最底层的抽象，主要描述数据在系统内部的表示方式和存取方法</li>\n</ul>\n<h4>1.1.2 概念模型</h4>\n<ul>\n<li><strong>信息世界的基本概念</strong></li>\n<li><strong>实体</strong>：客观存在且可以相互区分的事物，如人、事、物</li>\n<li><strong>属性</strong>：实体所具有的某一特性，如学生的学号、姓名等</li>\n<li><strong>码</strong>：又称键码，是唯一标识实体的属性，如学生的学号</li>\n<li><strong>实体型</strong>：具有相同属性的实体，用实体名和其属性名集合表示</li>\n<li><strong>实体集</strong>：同一类型的实体，如全体学生</li>\n<li><strong>联系</strong>：实体之间的联系常指不同实体集之间的关系，有一对一、一对多、多对多的关系</li>\n<li><strong>概念模型的表示方法</strong>：E-R模型</li>\n</ul>\n<h3>1.2 数据库系统的结构</h3>\n<h4>1.2.1 数据库系统的三级模式</h4>\n<ul>\n<li><strong>模式</strong>：也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。一个数据库只有一个模式。定义模式时不仅要定义数据的逻辑结构还要定义数据之间的关系和安全性、完整性要求。使用模式DDL定义模式</li>\n<li><strong>外模式</strong>：也称用户模式，是数据库用户可以看见和使用的局部数据的逻辑和特征的描述，是用户的数据视图，一个数据库可以有多个外模式，使用外模式DDL定义外模式</li>\n<li><strong>内模式</strong>：也称存储模式，一个数据库只有一个内模式，是数据物理结构和存储的描述，如数据按升/降存储、使用索引类型、数据是否压缩等</li>\n</ul>\n<h4>1.2.2 数据库的二级映像</h4>\n<ul>\n<li><strong>外模式/模式映像</strong>：定义了外模式和模式的对应关系，每一个外模式都有一个外模式/模式印象定义其与模式的关系。当模式改变时，改变外模式/模式映像保存外模式不变，从而使应用程序不变</li>\n<li><strong>模式/内模式映像</strong>：一个数据库的模式/内模式映像是唯一的，当内模式改变时，改变模式/内模式映像使模式不变，则应用程序不变</li>\n</ul>\n<h2>二、关系数据库</h2>\n<h3>2.1 关系数据结构</h3>\n<h4>2.1.1 关系</h4>\n<ul>\n<li><strong>属性</strong>：表中的一列，每个属性名称叫做属性名</li>\n<li><strong>域</strong>：属性值的集合，如学生的年龄在15-25岁，性别的域为男、女</li>\n<li><strong>笛卡儿积</strong>：所有域的所有取值的任意组合</li>\n<li><strong>关系</strong>：笛卡儿积的子集，一个n目关系必须有n个属性，一个关系对应一张二维表</li>\n<li><strong>分量</strong>：元组中的一个属性值</li>\n<li><strong>元组</strong>：表中的一行</li>\n<li><strong>候选码</strong>：关系中的某一属性组能唯一标识一个元组，而其子集不能，则该属性组称为候选码</li>\n<li><strong>主码</strong>：候选码中的一个</li>\n<li><strong>主属性</strong>：候选码的属性</li>\n<li><strong>非主属性</strong>：不包含在任何候选码的属性</li>\n<li><strong>全码</strong>：所有属性都是这个关系的候选码</li>\n<li><strong>关系的基本规范条件</strong>：关系的每一个分量必须是一个不可分的数据项，不允许表中还有表</li>\n</ul>\n<h4>2.1.2 关系模式</h4>\n<ul>\n<li><strong>关系模式</strong>：对关系的描述，一般描述为：关系名(属性1,属性2,...,属性n)，如：学生(学号,性别,年龄,年级)</li>\n</ul>\n<h3>2.2 关系的完整性</h3>\n<ul>\n<li><strong>实体完整性</strong>：关系的主属性值不能为空值</li>\n<li><strong>参照完整性</strong>：关系的外码数属性值要么是外码在其表中的某个元组的主属性值，要么是空值</li>\n<li><strong>用户定义的完整性</strong>：针对某一具体应用涉及的数据所满足的语义要求，如某个属性值唯一、某个非主属性非空等</li>\n</ul>\n<h2>三、SQL</h2>\n<h3>3.1 数据定义</h3>\n<h4>3.1.1 模式的定义与删除</h4>\n<ul>\n<li><p><strong>定义模式</strong></p>\n</li>\n<li><p>在SQL中，模式定义语句如下</p>\n<p><code>sql\nCREATE SCHEMA [&lt;模式名&gt;] AUTHORIZATION &lt;用户名&gt;\n</code></p>\n<p>如果模式名缺省，则使用用户名作为模式名，且一个模式相当于一个命名空间，在这个空间可以进一步定义该模式包含的基本表、视图、所有等</p>\n</li>\n<li><p><strong>删除模式</strong></p>\n</li>\n<li><p>在SQL中，模式删除语句如下</p>\n<p><code>sql\nDROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;\n</code></p>\n<ul>\n<li>CASCADE(级联)：删除模式的同时删除该模式下数据库对象全部删除</li>\n<li>RESTRICT(限制)：只有在该模式下没有任何数据库对象才删除，否则拒绝删除</li>\n</ul>\n</li>\n</ul>\n<h4>3.1.2 基本表的定义、删除、修改</h4>\n<ul>\n<li><p><strong>定义基本表</strong></p>\n</li>\n<li><p>使用CREATE TABLE定义基本表</p>\n<p><code>sql\nCREATE TABLE &lt;表名&gt;(\n&lt;列名&gt; &lt;数据类&gt; &lt;列级完整性约束条件&gt;,\n...\n&lt;表级完整性约束条件&gt;\n);\n</code></p>\n<p>例如</p>\n<p><code>sql\nCREATE TABLE SC(\nSno CHAR(9),\nCno CHAR(4),\nGrade SMALLINT NOT NULL,\nPRIMARY KEY(Sno,Cno),\nFOREIGN KEY(Sno) REFERENCES Student(Sno),\nFOREIGN KEY(Cno) REFERENCES Course(Cno)\n);\n</code></p>\n<p>表SC的主键是Sno和Cno两个字段，Sno是外码，参照表是Student表，Cno也是外码，参照表是Course表</p>\n</li>\n<li><p><strong>数据类型</strong></p>\n<p>|   数据类型   |             描述             |\n| :----------: | :--------------------------: |\n|   CHAR(n)    |   定义长度为n的定长字符串    |\n|  VARCHAR(n)  | 定义最大长度为n的变长字符串  |\n|     BLOB     |         二进制大文件         |\n|   SMALLINT   |          2字节整数           |\n|     INT      |          4字节整数           |\n|    BIGINT    |          8字节整数           |\n| DECIMAL(p,d) | p位数字，小数点后面数字为d位 |\n|   FLOAT(n)   |       精度为n的浮点数        |\n|  TIMESTAMP   |            时间戳            |</p>\n</li>\n<li><p><strong>修改基本表</strong></p>\n</li>\n<li><p>SQL使用ALTER TABLE来修改基本表，一般格式为</p>\n<p><code>sql\nALTER TABLE &lt;表名&gt;\n[ADD &lt;新列名&gt; &lt;数据类型&gt; [完整性约束]]\n[ADD &lt;表级完整性约束&gt;]\n[ALTER COLUMN &lt;列名&gt; &lt;数据类型&gt;]\n[DROP &lt;列名&gt; [RESTRICT|CASCADE]]\n[DROP CONSTRAINT &lt;完整性约束名&gt; [RESTRICT|CASCADE]]\n</code></p>\n</li>\n<li><p><strong>删除基本表</strong></p>\n</li>\n<li><p>SQL使用DROP TABLE删除基本表，一般格式为</p>\n<p><code>sql\nDROP TABLE 表名 [RESTRICT|CASCADE]\n</code></p>\n</li>\n</ul>\n<h4>3.1.3 索引的建立与删除</h4>\n<ul>\n<li><p><strong>建立索引</strong></p>\n</li>\n<li><p>SQL使用CREATE INDEX语句建立索引，一般格式为</p>\n<p><code>sql\nCREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt; (列名,列名,...)\n</code></p>\n</li>\n<li><p><strong>重命名索引</strong></p>\n<p><code>sql\nALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;\n</code></p>\n</li>\n<li><p><strong>删除索引</strong></p>\n<p><code>sql\nDROP INDEX &lt;索引名&gt;\n</code></p>\n</li>\n</ul>\n<h4>3.1.4 实验用例表</h4>\n<ul>\n<li><p><strong>学生表</strong></p>\n<p>|  学号Sno  | 姓名Sname | 性别Ssex | 年龄Sage | 所在系Sdept |\n| :-------: | :-------: | :------: | :------: | :---------: |\n| 201215121 |   李勇    |    男    |    20    |     CS      |\n| 201215122 |   刘晨    |    女    |    19    |     CS      |\n| 201215123 |   王敏    |    女    |    18    |     MA      |\n| 201215125 |   张立    |    男    |    19    |     IS      |</p>\n</li>\n<li><p><strong>课程表</strong></p>\n<p>| 课程号Cno | 课程名Cname | 先行课Cpno | 学分Ccredit |\n| :-------: | :---------: | :--------: | :---------: |\n|     1     |   数据库    |     5      |      4      |\n|     2     |    数学     |            |      2      |\n|     3     |  信息系统   |     1      |      4      |\n|     4     |  操作系统   |     6      |      3      |\n|     5     |  数据结构   |     7      |      4      |\n|     6     |  数据处理   |            |      2      |\n|     7     | PASCAL语言  |     6      |      4      |</p>\n</li>\n<li><p><strong>学生选课表</strong></p>\n<p>|  学号Sno  | 课程号Cno | 成绩Grade |\n| :-------: | :-------: | :-------: |\n| 201215121 |     1     |    92     |\n| 201215121 |     2     |    85     |\n| 201215121 |     3     |    88     |\n| 201215122 |     2     |    90     |\n| 201215122 |     3     |    80     |</p>\n</li>\n</ul>\n<h3>3.2 数据查询</h3>\n<h4>3.2.1 单表查询</h4>\n<ul>\n<li><p><strong>选择表中若干列</strong></p>\n</li>\n<li><p>查询指定列：查询学生学号和姓名</p>\n<p><code>sql\nSELECT Sno,Sname FROM Student;\n</code></p>\n</li>\n<li><p>查询所有列：查询所有学生信息</p>\n<p><code>sql\nSELECT * FROM Student;\n</code></p>\n</li>\n<li><p>查询计算过的值</p>\n<ul>\n<li><p>目标表达式为计算公式并起别名：查询所有学生姓名，使用2014-年龄作为Birtday值</p>\n<p><code>sql\nSELECT Sname,2018-Sage Birthday FROM Student;\n</code></p>\n</li>\n<li><p>目标表达式为字符串常量和函数：查出所有学生姓名、加上一列为Year of Birth，并将所在系名全部小写</p>\n<p><code>sql\nSELECT Sname,\'Year of Birth\'，Lower(Sdept) FROM Student;\n</code></p>\n</li>\n<li><p>去除重复值：查询选课表中学生不重复学号</p>\n<p><code>sql\nSELECT DISTINCT Sno FROM SC;\n</code></p>\n</li>\n</ul>\n</li>\n<li><p><strong>WHERE子句</strong></p>\n</li>\n<li><p>常用的查询条件</p>\n<p>| 查询条件 |                谓词                 |\n| :------: | :---------------------------------: |\n|   比较   |           =,>,<,>=,&lt;=,!=            |\n| 确定范围 |     BETWEEN AND,NOT BETWEEN AND     |\n| 确定集合 | IN(值1,值2,...),NOT IN(值1,值2,...) |\n| 字符匹配 |            LIKE,NOT LIKE            |\n|   空值   |         IS NULL,IS NOT NULL         |\n| 多重条件 |             AND,OR,NOT              |</p>\n</li>\n<li><p>确定范围：查询年龄在20-23岁之间的所有学生信息</p>\n<p><code>sql\nSELECT * FROM Student WHERE Sage BETWEEN 20 AND 23;\n</code></p>\n</li>\n<li><p>确定集合：查询CS系、MA系和IS系的所有学生信息</p>\n<p><code>sql\nSELECT * FROM Student WHERE Sdept IN(\'CS\',\'MA\',\'IS\');\n</code></p>\n</li>\n<li><p>字符匹配</p>\n<ul>\n<li><p>LIKE：匹配任意长度字符</p>\n</li>\n<li><p>_：匹配单个字符</p>\n</li>\n<li><p>匹配‘<em>’：查询DB</em>Design这门课的学分和课程号</p>\n<p><code>sql\nSELECT Cno,Ccredit FROM Course where Cname LIKE \'DB\\_%\' ESCAPE \'\\\';\n</code></p>\n</li>\n</ul>\n</li>\n<li><p>空值查询：使用IS NULL或者IS NOT NULL，不能使用=代替IS</p>\n</li>\n<li><p>多重条件查询：AND的优先级比OR高，IN实际上可以使用多个OR代替</p>\n</li>\n<li><p><strong>ORDER BY子句</strong></p>\n</li>\n<li><p>默认升序ASC，降序为DESC，当按多个字段排序时，前面字段的优先级高于后面字段优先级</p>\n</li>\n<li><p>查询全体学生情况，按照所在系的系名升序排序，同一系按照年龄降序排序</p>\n<p><code>\nSELECT * FROM Student ORDER BY Sdept,Sage DESC;\n</code></p>\n</li>\n<li><p><strong>聚合函数</strong></p>\n</li>\n<li><p>主要的聚合函数</p>\n<p>|           函数           |                 描述                 |\n| :----------------------: | :----------------------------------: |\n|         COUNT(*)         |             统计元组行数             |\n| COUNT([DISTINCT] <列名>) |           统计某列数据行数           |\n|  SUM([DISTINCT] <列名>)  |  统计某列总和，该列元素必须是数值型  |\n|  AVG([DISTINCT] <列名>)  | 统计某列平均值，该列元素必须是数值型 |\n|  MAX([DISTINCT] <列名>)  |            统计某列最大值            |\n|  MIN([DISTINCT] <列名>)  |            统计某列最小值            |</p>\n</li>\n<li><p>查询选修1号课程的学生最高分数</p>\n<p><code>sql\nSELECT MAX(Grade) FROM SC WHERE Cno=\'1\';\n</code></p>\n</li>\n<li><p>除了COUNT(*)外，其他聚合函数只处理非NULL值，某个元组中部分元素为NULL不影响COUNT(*)</p>\n</li>\n<li><p>聚合函数主要用于SELECT子句和GROUP BY中的HAVING子句中，不能出现在WHERE子句中</p>\n</li>\n<li><p><strong>GROUP BUY子句</strong></p>\n</li>\n<li><p>GROUP BY子句会将查询结果按某一列或多列值进行分组，值相等的为为一组，分组后在HAVING子句中聚合函数作用于每一个分组</p>\n</li>\n<li><p>查询修了三门课以上的学生的学号</p>\n<p><code>sql\nSELECT Sno FROM SC GROUP BY Sno HAVING COUNT(*)&gt;3;\n</code></p>\n</li>\n<li><p>WHERE和HAVING的区别</p>\n<ul>\n<li>WHERE子句作用的对象是基本表或者视图，HAVING作用于分组</li>\n</ul>\n</li>\n</ul>\n<h4>3.2.2 连接查询</h4>\n<ul>\n<li><p><strong>关系数据库执行连接查询的两种方式</strong></p>\n</li>\n<li><p>套嵌循环连接：如果没有索引，则对于表1的每个元组，遍历表2所有元组，找到符合条件的元组和表一元组拼接起来，直到将表1的所有元组都处理完毕</p>\n</li>\n<li><p>如果表2建立了索引，则每次不需要扫描表2全表，而是根据索引值找到表2相应的元组和表1的元组拼接起来</p>\n</li>\n<li><p><strong>等值连接和非等值连接</strong>：当连接条件中出现“=”为等值连接，使用其他运算符为非等值连接，若在等值连接中，将目标中重复的属性列去掉为自然连接</p>\n</li>\n<li><p>使用自然连接查询选课学生的情况</p>\n<p><code>sql\nSELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade FROM Student,SC WHERE Student.Sno=SC.Sno;\n</code></p>\n</li>\n<li><p>使用复合条件查询选修2号课程且成绩大于90分的学生学号和姓名</p>\n<p><code>sql\nSELECT Student.Sno,Sname FROM Student,SC Where Student.Sno=SC.Sno AND Cno=\'2\' AND Grade&gt;\'90\';\n</code></p>\n</li>\n<li><p><strong>自连接</strong>：基本表自己和自己进行连接操作，需要给自己起两个别名进行区分</p>\n</li>\n<li><p>查询所有课程和其第二直接先行课（先行课的先行课）</p>\n<p><code>sql\nSELECT FIRST.Cno,SECOND.Cpno FROM Course FIRST,Course SECOND WHERE FISRST.Cpno=SECOND.Cno;\n</code></p>\n</li>\n<li><p><strong>外连接</strong>：分为左连接和右连接，左连接列出左边的表的所有元组，右连接列出右边的表的所有元组</p>\n</li>\n<li><p>查询所有学生的选课信息，如果某学生没有选课则该学生的课程信息为NULL</p>\n<p><code>sql\nSELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade FROM Student LEFT OUTER JOIN SC ON (Student.Sno=SC.Sno);&lt;br /&gt;\n</code></p>\n</li>\n<li><p><strong>多表连接</strong>：两个以上的表进行连接</p>\n</li>\n<li><p>查询所有学生的选课信息，包括学生学号、姓名、课程名、成绩等</p>\n<p><code>sql\nSELECT Student.Sno,Sname,Cname,Grade FROM Student,Course,SC WHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno;\n</code></p>\n</li>\n</ul>\n<h4>3.2.3 嵌套查询</h4>\n<ul>\n<li><p><strong>概念</strong>：一个\"SELECT-FROM-WHERE\"为一个查询块，将一个查询块嵌套到另一个查询块的WHERE或HAVING子句中称为嵌套查询，外层查询块叫做父查询，内层查询块叫做子查询，子查询块不能使用ORDER BY语句</p>\n</li>\n<li><p><strong>带IN的子查询</strong></p>\n</li>\n<li><p>查询与“刘晨在同一系的所有学生信息”</p>\n<p><code>sql\nSELECT * FROM Student WHERE Sdept IN(SELECT Sdept FORM Student WHERE Sname=\'刘晨\';)\n</code></p>\n<p>此条子查询的查询条件不依赖父查询，称作不相关子查询。也可以使用自连接：</p>\n<p><code>sql\nSELECT FIRST.* FROM Student FIRST,Student SECOND WHERE FIRST.Sdept=SECONDE.Sdept AND SECOND.Sname=\'刘晨\';\n</code></p>\n</li>\n<li><p>查询选修了信息系统这门课的学生学号和姓名</p>\n<p><code>sql\nSELECT Sno,Sname FROM Student WHERE Sno IN(SELECT Sno FROM SC WHERE Cno IN(SELECT Cno FROM Course WHERE Cno=\'信息系统\'));\n</code></p>\n<p>此条子查询语句也是不相关子查询，也可以使用自查询实现，且由于目前关系型数据库对子查询的优化做的还不够完善，在实际应用中能使用连接查询尽量使用连接查询</p>\n<p><code>sql\nSELECT Student.Sno,Sname FROM Student,Course,SC WHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno AND Course.Cname=\'信息系统\';\n</code></p>\n</li>\n<li><p><strong>带运算符的子查询</strong>：当用户确切知道内层查询返回的是单个值时，可以使用“>”、“<”、“=”、“>=”、“&lt;=”、“!=”、\"=\"等比较运算符进行比较</p>\n</li>\n<li><p>查询每个学生成绩超过他平均成绩的课程号</p>\n<p><code>sql\nSELECT Sno,Cno FROM SC FIRST WHERE Grade&gt;(SELECT AVG(Grade) FROM SC SECOND WHERE FIRST.Sno=SECOND.Sno);\n</code></p>\n<p>此种子查询的查询条件和父查询块有关，也叫做相关子查询</p>\n</li>\n<li><p><strong>带ANY或者ALL的子查询</strong>：当子查询返回值为多值时，需要使用比较运算符和ANY或ALL配合进行查询</p>\n</li>\n<li><p>查询非计算机系中比计算机系任意一个学生年龄都小的学生姓名和年龄</p>\n<p><code>sql\nSELECT Sname,Sage FROM Student WHERE Sage&lt;ANY(SELECT Sage FROM Student WHERE Sdept=\'CS\') AND Sdept!=\'CS\';\n</code></p>\n<p>上述子查询也可以使用聚合函数实现</p>\n<p><code>sql\nSELECT Sname,Sage FROM Student WHERE Sage&lt;(SELECT MAX(Sage) FROM Student WHERE Sdept=\'CS\') AND Sdept!=\'CS\';\n</code></p>\n</li>\n<li><p>查询非计算机系中比计算机系所有学生年龄都小的学生姓名和年龄</p>\n<p><code>sql\nSELECT Sname,Sage FROM Student WHERE Sage&lt;ALL(SELECT Sage FROM Student WHERE Sdept=\'CS\') AND Sdept=\'CS\';\n</code></p>\n<p>上述子查询也可以使用聚合函数实现</p>\n<p><code>sql\nSELECT Sname,Sage FROM Student WHERE Sage&lt;(SELECT MIN(Sage) FROM Student WHERE Sdept=\'CS\') AND Sdept!=\'CS\';\n</code></p>\n</li>\n<li><p>ANY或ALL的子查询都可以转换成带MAX或MIN以及IN的子查询</p>\n</li>\n<li><p><strong>带EXISTS或NOT EXISTS的子查询</strong>：带EXISTS或NOT EXISTS的子查询只返回True或者False，且带EXISTS或NOT EXISTS的子查询目标列表达式一般都为“*”</p>\n</li>\n<li><p>查询所有选修了1号课程的学生姓名</p>\n<p><code>sql\nSELECT Sname FROM Student WHERE EXISTS(SELECT * FROM SC WHERE Student.Sno=SC.Sno AND Cno=\'1\');\n</code></p>\n<p>该条查询语句的查询执行过程为先从父查询取出一个元组，将元组的信息放入子查询的判断条件，若返回true，则将这个元组放入结果表，直到父查询表检查完</p>\n</li>\n<li><p><strong>基于派生的子查询</strong>：子查询不仅可以出现在WHERE或者HAVING子句中，也可以出现在FROM子句中</p>\n</li>\n</ul>\n<h4>3.2.4 集合查询</h4>\n<ul>\n<li><p><strong>集合查询</strong>：使用UNION（并）、INTERSECT（交）、EXCEPT（差）连接两个SELECT语句</p>\n</li>\n<li><p>查询计算机系年龄不大于19岁的学生</p>\n<p><code>sql\nSELECT * FROM Student WHERE Sdept=\'CS\' UNION SELECT * FROM Student WHERE Sage&lt;=19;\n</code></p>\n<p>上述查询也可以直接使用AND在一条SELECT语句实现</p>\n</li>\n</ul>\n<h3>3.3 数据更新</h3>\n<h4>3.3.1 插入数据</h4>\n<ul>\n<li><p><strong>插入元组</strong></p>\n</li>\n<li><p>将一个新生学生元组（学号：201215128，姓名：陈冬，性别：男，所在系：IS，年龄：18岁）插入到Student表中</p>\n<p><code>sql\nINSERT INTO Student(Sno,Sname,Sage,Sdept,Sage) values(\'201215128\',\'陈冬\',\'男\',\'IS\',18);\n</code></p>\n</li>\n<li><p><strong>插入子查询结果</strong></p>\n</li>\n<li><p>有一个新表Dept<em>age，表中一个属性为系名，另一个属性为该系的学生平均年龄，从Student表将数据插入到Sdept</em>age表中</p>\n<p><code>sql\nINSERT INTO Sdept_age(Sdept,Sage) SELECT Sdept,AVG(age) FROM Student GROUP BY Sdept;\n</code></p>\n</li>\n</ul>\n<h3>3.3.2 修改数据</h3>\n<ul>\n<li><p><strong>修改元组</strong></p>\n</li>\n<li><p>将学号为201215121的学生年龄改为22岁</p>\n<p><code>sql\nUPDATE Student SET Sage=22 WHERE Sno=201215121;\n</code></p>\n</li>\n<li><p><strong>带子查询的修改元组</strong></p>\n</li>\n<li><p>将计算机系全体学生的成绩置为0</p>\n<p><code>sql\nUPDATE SC SET Grade=0 WHERE Sno IN(SELECT Sno FROM Student WHERE Sdept=\'CS\');\n</code></p>\n</li>\n</ul>\n<h3>3.3.3 删除数据</h3>\n<ul>\n<li><p><strong>删除元组</strong></p>\n</li>\n<li><p>删除学号为201215128的学生记录</p>\n<p><code>sql\nDELETE FROM Student WHERE Sno=201215128;\n</code></p>\n</li>\n<li><p><strong>带子查询的删除元组</strong></p>\n</li>\n<li><p>删除计算机系的所有同学的选课记录</p>\n<p><code>sql\nDELETE FROM SC WHERE Sno IN(SELECT Sno FROM Student WHERE Sdept=\'CS\');\n</code></p>\n</li>\n</ul>\n<h3>3.4 视图</h3>\n<ul>\n<li><p><strong>建立视图</strong></p>\n</li>\n<li><p>建立视图的一般格式为</p>\n<p><code>sql\nCREATE VIEW &lt;视图名&gt; ([&lt;列名1&gt;,[&lt;列名2&gt;],...) AS &lt;子查询&gt; [WITH CHECK OPTION];\n</code></p>\n<p>WITH CHECK OPTION的作用是要求在对视图进行INSERT、UPDATE、DELETE等操作时更新的数据需要满足子查询中的条件表达式</p>\n</li>\n<li><p><strong>删除视图</strong></p>\n</li>\n<li><p>删除视图的一般格式为</p>\n<p><code>sql\nDROP VIEW &lt;视图名&gt; [CASCADE];\n</code></p>\n</li>\n<li><p><strong>视图的作用</strong></p>\n</li>\n<li><p>简化用户的操作</p>\n</li>\n<li><p>使用户以多种角度看待同一数据</p>\n</li>\n<li><p>对重构数据库提供了一定逻辑独立性</p>\n</li>\n<li><p>对机密数据提供安全保护</p>\n</li>\n<li><p>更清晰的查询表达</p>\n</li>\n</ul>\n<h3>3.5 数据库的授权与收回</h3>\n<h4>3.5.1 授权</h4>\n<ul>\n<li><p>SQL授权的格式为：GRANT <权限> [,<权限>...] ON <对象类型> <对象名> [,<对象类型> <对象名>...] TO <用户> [<用户>...] [WITH GRANT OPTION]</p>\n</li>\n<li><p>如果指定了WITH GRANT OPTION子句，则获得某种权限的用户还可以将次权限授权给其他用户</p>\n</li>\n<li><p>权限可以是表的所有属性的操作，如将查询Student表的权限授权给U1</p>\n<p><code>sql\nGRANT SELECT ON TABLE Student TO U1;\n</code></p>\n</li>\n<li><p>权限也可以是对表中的某一个属性，如将查询Student表的学号的权限授权给U2</p>\n<p><code>sql\nGRANT SELECT(Sno) ON TABLE Student TO U2;\n</code></p>\n</li>\n<li><p>也可以同时将所有权限授权，所有权限使用ALL PRIVILEGES，如将表Student的所有权限授权给U3</p>\n<p><code>sql\nGRANT ALL PRIVILEGES ON TABLE Student TO U3;\n</code></p>\n</li>\n<li><p>也可以同时将权限授权给所有人，所有用户使用PUBLIC，如将Student表的查询权限授权给所有用户</p>\n<p><code>sql\nGRANT SELECT ON TABLE Student TO PUBLIC;\n</code></p>\n</li>\n</ul>\n<h4>3.5.2 回收权限</h4>\n<ul>\n<li>SQL回收权限的格式为：REVOKE <权限> [,<权限>...] ON <对象类型> <对象名> [,<对象类型> <对象名>...] FROM  <用户> [,<用户>...] [CASCADE|RESTRICT]</li>\n</ul>\n<h4>3.5.3 数据库角色</h4>\n<ul>\n<li>数据库角色是某一类权限的集合，可以采用将权限授权给某一角色，然后使用角色授权给用户的方法简化授权过程</li>\n<li>数据库角色授权过程为</li>\n<li>创建角色：CREATE ROLE <角色名>;</li>\n<li>授权给角色：GRANT <权限> [,<权限>...] ON <对象类型> <对象> [,<对象类型> <对象>...] TO <角色> [,<角色>...] [WITH ADMIN OPTION]</li>\n<li>将角色授权给用户：GRANT <角色> TO <用户></li>\n<li>数据库角色的回收使用REVOKE</li>\n</ul>\n<h2>四、数据库完整性</h2>\n<h3>4.1 实体完整性</h3>\n<ul>\n<li><strong>实体完整性的定义</strong>：在创建表语句中使用PRIMARY KEY定义实体完整性，当有多个属性构成的码需要使用表级约束条件</li>\n<li><strong>实体完整性检查和违约处理</strong>：定义完实体完整性后，对每条插入的记录都对主码列进行检查，检查的内部包括：非空检查和唯一检查。检查的方法之一是进行全表扫描，但是十分费时。一般关系型数据库都会在主码上建立索引，通过索引从B+树进行查找</li>\n</ul>\n<h3>4.2 参照完整性</h3>\n<ul>\n<li><p><strong>参照完整性的定义</strong>：在创建表语句中使用FOREIGN KEY...REFERENCE语句定义外码</p>\n</li>\n<li><p><strong>参照完整性检查和违约处理</strong>：对于被参照表和参照表中的某些操作可能破坏参照完整性的情况和违约处理如下表</p>\n<p>|                    被参照表（如Student）                     |                 参照表（如SC）                 |      违约处理      |\n| :----------------------------------------------------------: | :--------------------------------------------: | :----------------: |\n|                                                              |      插入元素（外键值在被参照表中不存在）      |        拒绝        |\n|                                                              | 修改外码值（修改后的外键值在被参照表中不存在） |        拒绝        |\n| 修改主码值（导致参照表中引用原主码值的外键值在被参照表中不存在） |                                                | 拒绝/级联/设为空值 |\n| 删除元组（导致参照表中引用删除元组主码值的外键值在被参照表中不存在） |                                                | 拒绝/级联/设为空值 |</p>\n</li>\n<li><p>拒绝：当发生不一致时，不允许执行该操作，该策略一般为默认策略</p>\n</li>\n<li><p>级联：当删除或修改被参照表的一个元组导致与参照表不一致时，删除或修改参照表中所有不一致的元组</p>\n</li>\n<li><p>设为空值：当删除或修改被参照的一个元组导致与参照表不一致时，将参照表的所有不一致的对应属性设为NULL</p>\n</li>\n</ul>\n<h3>4.3 用户定义的完整性</h3>\n<ul>\n<li><strong>用户定义的完整性的定义</strong>：可以定为列级或者表级约束，包括</li>\n<li>NOT NULL（非空）</li>\n<li>UNIQUE（唯一）</li>\n<li>CHECK（检查值是否满足条件表达式）</li>\n<li><strong>违约处理</strong>：如果行级或者表级的完整性约束没有被满足时，操作将会被拒绝执行</li>\n</ul>\n<h2>五、关系数据理论</h2>\n<h3>5.1 关系数据库</h3>\n<h4>5.1.1 数据依赖</h4>\n<ul>\n<li><strong>函数依赖</strong>：在属性之间，当某一个属性被确定以后，其他的属性也能唯一的确定，则其他属性函数依赖于某一属性。如学生表包括学号（Sno）、姓名（Sname）、系（Sdept），当学号确定之后，学生姓名和系也能唯一确定，记作Sno→Sname，Sno→Sdept，Sname和Sdept依赖于Sno</li>\n<li><strong>完全函数依赖</strong>：X→Y，X中的每个属性都能完全唯一的确定Y，如Sno→Sdept</li>\n<li><strong>部分函数依赖</strong>：X→Y，X中的部分属性能完全唯一确定Y，如(Sno,Cno)→Sdept</li>\n<li><strong>传递函数依赖</strong>：如果X→Y，Y→Z，则Z传递依赖于X，如Sno→Sdept，Sdept→Mname，则Mnae传递依赖于Sno</li>\n</ul>\n<h4>5.1.2 存在的问题</h4>\n<ul>\n<li>如果只考虑函数依赖这一种数据依赖，将所有属性放到一张表中，会出现以下问题，加入有学生学号（Sno）、课程号（Cno）、课程成绩（Grade）、系名（Sdept）、系主任（Mname）等属性</li>\n<li><strong>数据冗余</strong>：比如每个系的系主任姓名重复出现</li>\n<li><strong>更新异常</strong>：当某个系换主任时，必须修改所有该系的学生的每个元组</li>\n<li><strong>插入异常</strong>：若一个系刚成立，有系名、系主任，但是还没有学生，就无法将系的信息保存进数据库</li>\n<li><strong>删除异常</strong>：如果某个系的学生全部毕业了，删除这些学生的信息会将系名和系主任一同删除</li>\n</ul>\n<h3>5.2 规范化</h3>\n<ul>\n<li><strong>范式</strong>：关系数据库满足不同程度要求的为不同范式，一个低一级的范式可以通过模式分解为若干个高一级范式的集合</li>\n<li><strong>第一范式</strong>：属性不可分，每一个分量都是不可分的数据项</li>\n<li><strong>第二范式</strong>：在满足第一范式的基础上，每一个非主属性完全依赖于任何一个候选码，如果一个关系满足第一范式不满组第二范式，则可以通过投影分解将其分解为若干个满足第二范式的关系</li>\n<li><strong>第三范式</strong>：在满足第二范式的基础上，每一个非主属性不传递依赖于候选码，可以通过投影分解将满足第二范式而不满足第三范式的关系分解为多个满足第三范式的关系集合</li>\n<li><strong>BC范式</strong></li>\n<li><strong>第五范式</strong></li>\n</ul>\n<h2>六、数据库设计</h2>\n<h3>6.1 数据库设计的一般步骤</h3>\n<ul>\n<li>需求分析</li>\n<li>概念结构设计</li>\n<li>逻辑结构设计</li>\n<li>物理结构设计</li>\n<li>数据库实施</li>\n<li>数据库运行和维护</li>\n</ul>\n<h3>6.2 概念结构设计</h3>\n<h4>6.2.1 E-R模型</h4>\n<ul>\n<li><strong>实体之间的联系</strong></li>\n<li>一对一联系（1:1）</li>\n<li>一对多联系（1:n）</li>\n<li>多对多联系（n:m）</li>\n<li><strong>E-R图</strong></li>\n<li>实体使用矩形表示，矩形框内写明实体名</li>\n<li>属性用椭圆表示，并用无向边将其对应的实体连接起来</li>\n<li>联系用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1、1:n、n:m）</li>\n</ul>\n<h4>6.2.2 概念结构设计</h4>\n<ul>\n<li>属性划分原则</li>\n<li>作为属性，不能再具有需要描述的性质</li>\n<li>属性与其他实物不能具有联系</li>\n</ul>\n<h3>6.3 逻辑结构设计</h3>\n<h4>6.3.1 E-R图向关系转换</h4>\n<ul>\n<li>一个1:1的联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并</li>\n<li>一个1:n的联系可以转换为一个独立的关系模式，也可以与n端对应的关系合并</li>\n<li>一个m:n的联系转换为一个关系模式</li>\n<li>三个三个以上实体间的一个多元联系可以转换为一个关系模式</li>\n<li>具有相同的码的关系可以合并</li>\n</ul>\n<h4>6.3.2 数据模型的优化</h4>\n<ul>\n<li>确定数据依赖</li>\n<li>对各关系间的数据依赖进行极小化处理</li>\n<li>确定各关系模式属于第几范式</li>\n<li>进某些模式进行合并和分解</li>\n<li>对关系模式进行必要分解，常用的有水平分解和垂直分解</li>\n</ul>\n<h3>6.4 物理结构设计</h3>\n<h4>6.4.1 关系模式存取方法选择</h4>\n<ul>\n<li><strong>索引</strong></li>\n<li>B+树索引存取方法的选择<ul>\n<li>如果一个或一组属性经常在查询条件出现，考虑在这个或这组属性建立索引或者组合索引</li>\n<li>如果一个属性经常作为最大值和最小值等聚集函数的参数，考虑在这个属性建立索引</li>\n<li>如果一个或一组属性经常在连接操作的连接条件中出现，则考虑在这个或这组属性上添加 索引</li>\n</ul>\n</li>\n<li>hash索引存取方法的选择：如果一个或一组属性主要出现在等值连接条件中或者等值比较选择条件中，而且满足以下情况之一，则可以选择hash索引方法<ul>\n<li>一个关系的大小可预知而且不变</li>\n<li>关系的大小动态改变，但是数据库管理系统提供了动态hash存取方法</li>\n</ul>\n</li>\n<li><strong>聚簇</strong></li>\n<li>概念：为了提高某个或某组属性的查询速度，将这些属性上具有相同值的元组放在连续的物理块中称为聚簇，该属性称为聚簇码，一个数据库可以有多个聚簇，一个关系只能有一个聚簇</li>\n<li>聚簇方法的选取<ul>\n<li>首先设计候选聚簇</li>\n<li>对经常在一起进行连接操作的关系可以建立聚簇</li>\n<li>如果一个关系的一组属性经常出现在连接操作中，该单个关系可以建立聚簇</li>\n<li>如果一个关系的一组属性重复的值比较多，此关系可以建立聚簇</li>\n<li>从候选聚簇取消不必要的关系</li>\n<li>从聚簇中删除经常全表扫描的关系</li>\n<li>从聚簇中删除连接远小于更新的关系</li>\n<li>从多个聚簇方案选择最优聚簇</li>\n</ul>\n</li>\n</ul>\n<h2>七、关系查询处理和查询优化</h2>\n<h3>7.1 查询处理</h3>\n<h4>7.1.1 选择操作的实现</h4>\n<ul>\n<li><strong>简单的全表扫描算法</strong>：只需要较少的内存就能实现，当表的规模较小时，这种算法十分有效，当表的规模很大且选择率低时效率很低</li>\n<li><strong>索引扫描算法</strong>：如果条件中的属性上有索引，通过索引先找到满足条件的元组指针，再通过元组指针在查询的基本表中找到元组，当选择率低时，采用索引的选择算法效率高于全表扫描算法</li>\n</ul>\n<h4>7.1.2 连接操作的实现</h4>\n<ul>\n<li><strong>嵌套循环法</strong>：对外层表的每一个元组，检查内层表的所有元组，满足连接条件的作为结果输出，知道外层表的所有元组处理完毕</li>\n<li><strong>排序-合并算法</strong>：先将参与连接的表按照连接属性排序，对于外表的每个元组，依次扫描内层表中具有相同连接属性值的元素知道扫描到与外层表元组连接属性不同的元组时，返回外层表的下一个元组，然后再对内层表进行扫描，重复直到外层表都被扫描</li>\n<li><strong>索引连接算法</strong>：在内层表对连接属性建立起索引，对于外层表的每个元组，在内层表通过索引查找对应的元组，重复直到外层表都被扫描</li>\n<li><strong>hash连接算法</strong>：将连接属性作为hash码，用同一个hash函数将外层表和内层表进行散列，然后通过相同hash值进行连接</li>\n</ul>\n<h3>7.2 查询优化</h3>\n<h4>7.2.1 代数优化</h4>\n<ul>\n<li>代数优化就是通过对关系代数表达式的等价交换来提高查询效率</li>\n</ul>\n<h4>7.2.2 物理优化</h4>\n<ul>\n<li><strong>基于启发式规则的存取路径选择优化</strong></li>\n<li>选择操作的启发式规则<ul>\n<li>对于小关系，进行全表扫描，即使选择列上有索引</li>\n<li>对于大关系</li>\n<li>对于选择条件是“主码=值”的查询，查询结果只有一个元组，可以选择主码索引</li>\n<li>对于选择条件是“非主属性=值”，并且选择列上有索引，估算查询结果的元组数目，如果比例较小（&lt;10%）可以使用索引扫描，否则使用全表扫描</li>\n<li>对于选择条件是属性上的非等值查询或者范围查询，估算查询结果元组数目，如果比例小于10%，使用索引扫描，否则依然是全表扫描</li>\n<li>对于用AND连接的组合条件，如果有涉及这些条件的组合索引，则优先选择组合索引，如果某些属性上有索引，则可以先使用索引找到满足相应条件的元组，再从这些元组中使用全表扫描得到满足剩下条件的元组，否则使用全表扫描</li>\n<li>用OR连接的选择条件，一般使用全表扫描</li>\n</ul>\n</li>\n<li>连接操作的启发式规则<ul>\n<li>如果两个表已经按照连接条件排好序，使用排序-合并算法</li>\n<li>如果一个边在连接属性上有索引，采用索引连接法</li>\n<li>如果其中一张表比较小，上述都不适用，采用hash连接算法</li>\n<li>最后使用嵌套循环算法，选择较小的那张表为外层表</li>\n</ul>\n</li>\n<li><strong>基于代价估算的优化</strong></li>\n<li>统计信息</li>\n<li>代价估算</li>\n<li>选择代价最小的方式</li>\n</ul>\n<h2>八、数据库恢复技术</h2>\n<h3>8.1 事务的基本概念</h3>\n<h4>8.1.1 事务</h4>\n<ul>\n<li>事务是用户定义的一个数据库操作序列，这些操作要么全部执行，要么全不执行</li>\n</ul>\n<h4>8.1.2 事务的特性</h4>\n<ul>\n<li><strong>原子性</strong>：事务是数据库的逻辑工作基本单位，事务中包含的操作要么都做，要么都不做</li>\n<li><strong>一致性</strong>：事务的执行结果必须使数据库从一个一致性状态编导另一个一致性状态</li>\n<li><strong>隔离性</strong>：并发的各个事务之间是隔离的，互不影响</li>\n<li><strong>永久性</strong>：一个事务一旦提交，其对数据库的改变是永久的</li>\n</ul>\n<h3>8.2 故障的种类</h3>\n<ul>\n<li>事务内部的故障</li>\n<li>系统故障</li>\n<li>介质故障</li>\n<li>计算机病毒</li>\n</ul>\n<h3>8.3 恢复的实现技术</h3>\n<ul>\n<li>数据转储</li>\n<li>登记日志文件</li>\n</ul>\n<h2>九、并发控制</h2>\n<h3>9.1 并发操作带来的数据库不一致性问题</h3>\n<h4>9.1.1 丢失修改</h4>\n<ul>\n<li>并发操作下，某一事务的提交破坏其他事务对同一数据的修改</li>\n</ul>\n<h4>9.1.2 不可重复读</h4>\n<ul>\n<li>指事务A读取数据后，事务B对数据进行修改，导致数据A无法再现前一次读取结果，主要包括三种情况</li>\n<li>事务A读取某个数据的值，事务B修改这一数据的值导致事务A再次读取这一数据的值发生了改变</li>\n<li>事务A读取了某些数据记录后，事务B将这些数据删除一部分，事务A再次读取这些数据时，发现数据数量发生了改变</li>\n<li>事务A读取了某些数据记录后，事务B插入一些记录，当事务A再次以相同的条件查询数据时，发现多了一些记录</li>\n<li>后两种也叫幻影读</li>\n</ul>\n<h4>9.1.3 读脏数据</h4>\n<ul>\n<li>主要是指事务读取到其他事物未提交的数据</li>\n</ul>\n<h3>9.2 事物的隔离级别</h3>\n<ul>\n<li>读未提交：事务中的修改即使没有提交对其他事务也是可见的，会出现脏读、不可重复读、幻读</li>\n<li>读已提交：一个事务所作的修改在提交之间对其他事务是不可见的，会出现不可重复读、幻读</li>\n<li>可重复读：保证同一个事务多次读取同样的数据的结果是一样的，会出现幻读</li>\n<li>可串行化：强制事务串行执行</li>\n</ul>\n<h3>9.3 封锁和封锁协议</h3>\n<h4>9.3.1 封锁类型</h4>\n<ul>\n<li>排他锁（写锁/X锁）：当某一事物对数据对象加上X锁，则只允许该事务对此数据对象进行读和写，不允许其他事务对此数据对象加X锁或者S锁</li>\n<li>共享锁（读锁/S锁）：当某一事物对数据对象加上S锁，则该事务可以对数据对象读不允许写，其他事务也可以对数据对象加S锁不能加X锁</li>\n</ul>\n<h4>9.3 .2 封锁协议</h4>\n<ul>\n<li><strong>一级封锁协议</strong>：事务在修改数据前必须加X锁，直到事务结束才释放。不能保证不可重复读和脏读</li>\n<li><strong>二级封锁协议</strong>：在一级封锁协议的基础上加上事务在读取数据前必须加S锁，直到读完。不能保证不可重复读</li>\n<li><strong>三级封锁协议</strong>：在一级封锁协议的基础上加上事务在读取数据前必须加S锁，直到事务结束</li>\n</ul>\n<h3>9.4 活锁和死锁</h3>\n<h4>9.4.1 活锁</h4>\n<ul>\n<li>当多个事务请求同一个锁时，某个事物可能会永远都在等待而获取不到锁</li>\n<li>避免活锁的简单办法是采用先到先服务的策略</li>\n</ul>\n<h4>9.4.2 死锁</h4>\n<ul>\n<li>事物A1申请了锁R1，事物A2申请了锁R2，紧接着事物A1又想申请R2，A2又想申请R1，两个事物都互相等待对方释放锁，形成死锁</li>\n<li><strong>死锁的预防</strong></li>\n<li>一次封锁法：要求每个事物将其索要使用的数据一次全部加锁。这种方法会加大封锁范围，降低并发度</li>\n<li>顺序封锁法：对数据对象规定一个封锁顺序，所有的事务都按照这个顺序进行封锁</li>\n<li><strong>死锁的诊断</strong></li>\n<li>超时法：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁</li>\n<li>等待图法：事务的等待图是一个有向图，如果存在回路就认为发生了死锁</li>\n<li><strong>死锁解除</strong></li>\n<li>选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有的锁，是其他事务运行下去</li>\n</ul>\n<h3>9.5 两段封锁协议</h3>\n<ul>\n<li>目前数据库使用两段封锁协议实现并发的可串行化，两段封锁协议是指所有事物分两个阶段对数据进行加锁和解锁</li>\n<li>在对任何事物读、写操作之前，首先要申请获得对该数据的加锁</li>\n<li>在释放一个封锁之后，事务不再申请和获得其他任何封锁</li>\n</ul>\n<h3>9.6 封锁的粒度</h3>\n<h4>9.6.1 多粒度封锁</h4>\n<ul>\n<li><strong>封锁粒度</strong>：封锁对象的大小，封锁粒度越大，并发度越小，系统开销越小，封锁粒度越小，并发度越大，系统开销越大</li>\n<li><strong>多粒度封锁</strong>：一个系统中支持多种封锁的粒度供不同的事物选择，这种封锁称为多粒度封锁</li>\n<li><strong>多粒度树</strong>：多粒度树的根节点为整个数据库，表示最大粒度，叶节点为最小粒度。如三级粒度树从根节点到叶节点分别为：数据库-关系-元组。</li>\n<li><strong>多粒度封锁协议</strong>：多粒度封锁协议允许多粒度树种每个节点被独立加锁，则该节点的子孙节点也被加以同样的锁。因此分为显式加锁和隐式加锁</li>\n<li>显式加锁：应事物的要求直接加到数据对象上的锁</li>\n<li>隐式加锁：该数据对象没有被独立加锁，而是由于其上级节点加锁而使该对象加了锁</li>\n<li>缺点：多粒度加锁中，显式加锁和隐式加锁的效果都是一样的，因此系统在检查锁冲突时不仅要检查显式加锁还要检查隐式加锁。如果某一个事物需要对数据对象加锁，首先检查该数据对象上是否有无显式加锁与之冲突，再检查该数据对象的上级节点，看本事务的显式加锁是否与该数据对象上的隐式加锁冲突，最后检查其所有的下级节点，看它们的显式加锁是否和本事务的显式加锁冲突</li>\n</ul>\n<h4>9.6.2 意向锁</h4>\n<ul>\n<li><strong>意向锁</strong>：为了解决多粒度封锁协议加锁不仅要检查数据对象上的锁还要检查其上级节点和下级节点的显式加锁，引入了意向锁，如果对一个节点加意向锁，则说明该节点的下层节点正在被加锁。对任一节点加锁必须先对其上层节点加意向锁，例如对任一元组加锁时，必须先对其所在数据库和关系加意向锁</li>\n<li><strong>意向锁的分类</strong></li>\n<li>IS锁：对一个数据对象加IS锁，表示它的子孙节点将加S锁</li>\n<li>IX锁：对一个数据对象加IX锁，表示它的子孙节点将加X锁</li>\n<li>SIX锁：对一个数据对象加SIX锁，表示对它加S锁再加IX锁</li>\n</ul>\n<h3>9.7 多版本并发控制（MVCC）</h3>\n<h4>9.7.1 多版本并发控制概念及实现</h4>\n<ul>\n<li><p><strong>概念</strong>：是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别，而读未提交这种隔离级别总是读取最新的数据行，无需用MVCC，可串行化隔离级别需要对所有读取的行都加锁，单纯的使用MVCC无法实现</p>\n</li>\n<li><p><strong>版本</strong>：是指数据库中数据对象的一个快照，记录了数据对象在某个时刻的状态</p>\n</li>\n<li><p>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增</p>\n</li>\n<li><p>事物版本号：事务开始时的系统版本号</p>\n</li>\n<li><p><strong>隐藏的列</strong>：MVCC在每行记录后面都保存着两个隐藏的列，用来存储两个版本号</p>\n</li>\n<li><p>创建版本号：创建一个数据行的快照时的系统版本号</p>\n</li>\n<li><p>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除</p>\n</li>\n<li><p><strong>实现过程</strong></p>\n</li>\n<li><p>当开启一个新的事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号</p>\n</li>\n<li><p>SELECT：多个事务必须读取到同一个数据行最近的一个有效快照，该快照的创建版本号必须小于事务的版本号，快照的删除版本号必须大于事务的版本号</p>\n</li>\n<li><p>INSERT：将当前系统版本号作为快照创建版本号</p>\n</li>\n<li><p>DELETE：将当前系统版本号作为快照删除版本号</p>\n</li>\n<li><p>UPDATE：将当前系统版本号作为更新前数据行快照的删除版本号，并将当前系统版本号作为更新后数据行的快照创建版本号，可以理解先执行DELETE再执行INSERT</p>\n</li>\n</ul>\n<h4>9.7.2 NEXT-KEY LOCKS</h4>\n<ul>\n<li>是指MySQL的InnoDB存储引擎的一种锁实现，MVCC不能解决幻读的问题，Next-Key Locks就是为了解决幻读，在可重复读隔离级别下，使用MVCC+Next-Key Locks可以解决幻读</li>\n<li>Next-Key Locks不仅锁定一个记录上的所有还锁定索引之间的间隙</li>\n</ul>\n', 3, '关系数据库的设计、范式、约束、并发', 'database', '数据库系统概论', 1, 2, 2);
INSERT INTO blog VALUES (3, 3, '## 一、概述\n\n### ISP\n\n- ISP指互联网服务提供商，ISP可以从互联网管理机构获取很多IP地址，同时拥有通信线路及路由器互联网等设备，个人或机构向ISP缴纳一定的费用就可以接入互联网\n- 目前的互联网是一种多层次ISP结构，ISP根据覆盖面积的大小分为第一层ISP、区域ISP和接入ISP\n\n### 主机间的通信方式\n\n- C/S：客户是服务的请求方，服务器是服务的提供方\n- P2P：不区分客户和服务器\n\n### 计算机网络体系结构\n\n![1537757939109](C:\\Users\\59247\\AppData\\Roaming\\Typora\\typora-user-images\\1537757939109.png)\n\n1. **五层协议**\n\n   - 应用层：为特定应用程序提供数据传输服务，数据单位为报文\n   - 传输层：为进程提供统一的数据传输服务，运输层包括两种协议：传输控制协议TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议UDP，提供面向无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP提供完整性服务，UDP提供及时性服务\n   - 网络层：为主机提供数据传输服务，而运输层协议是为主机中的进程提供数据传输服务，网络层将传输层传递下来的报文段或者用户数据报封装成分组\n   - 数据链路层：网络层针对的是主机间的数据传输服务，而主机间有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层将网络层传下来的分组封装成帧\n   - 物理层：考虑是怎样在传输媒体上传输成比特流，而不是指具体的传输媒体\n\n2. **OSI**\n\n   - 在五层协议的基础上，将应用层又分为应用层、表示层、会话层，其中表示层和会话层功能如下\n     - 表示层：数据压缩、加密以及数据描述，使应用程序不必关心各台主机中数据内部格式不同的问题\n     - 会话层：建立及管理会话\n   - 五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理\n\n3. ### TCP/IP\n\n   - 在五层协议的基础上，将数据链路层和物理层合并为网络接口层\n   - TCP/IP体系结构不严格遵循OSI分层概念，应用层可能直接使用网络层和网络接口层\n   - TCP/IP协议族是一种沙漏形状，中间小两边大，IP协议在其中占举足轻重的地位\n\n4. 数据在各层传递的过程\n\n   - 在向下的过程，需要添加下层协议所需的首部或尾部，在向上的过程中不断拆开首部和尾部\n   - 路由器只有下三层协议，因为路由器位于网络和心中，不需要为进程或应用程序提供服务，因此也就不需要运输层和应用层\n\n## 二、物理层\n\n### 通信方式\n\n- 单工通信：单向传输\n- 半双工通信：双向交替传输\n- 全双工通信：双向同时传输\n\n### 带通调制\n\n- 模拟信号是连续的信号，数字信号是离散的信号，带通调制是把数字信号转换为模拟信号\n\n## 三、数据链路层\n\n### 基本问题\n\n1. **封装成帧**：将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束\n2. **透明传输**：帧使用首部和尾部进行定界，如果帧的数据部分包含有首部和尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部和尾部相同的内容前插入转义字符\n3. **差错检测**：目前数据链路层广泛使用循环冗余检测（CRC）来检测比特差错\n\n### 信道分类\n\n1. **广播信号**：一对多通信，一个节点发送的数据能够被所有节点接收，主要使用两种控制方法进行协调，一种使用信道复用技术，一种使用CSMA.CD协议\n2. **点对点通信**：一对一通信，使用PPP协议进行控制\n\n### 信道复用技术\n\n1. **频分复用**：所有主机在相同的时间占用不同的频率宽带资源\n2. **时分复用**：所有主机在不同时间占用相同频率的宽带资源\n3. **统计时分复用**：对时分复用的改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来统计时分复用帧然后发送\n4. **波分复用**：光的频分复用，使用波长代替频率表示使用的光载波\n5. **码分复用**：为每个用户分配码片，所有码片正交\n\n### CSMA/CD协议\n\n- **多点接入**：说明这是总线型网络，许多主机以多点的方式连接到总线\n- **载波监听**：每个主机都必须不停的监听信道，如果监听到信道正在使用，就必须等待\n- **碰撞检测**：在发送中，如果监听到信道已有其他主机正在发送数据，就表示发生了碰撞，当发生碰撞时，站点要停止发送，等待一段时间再发送，这个时间采用截断二进制指数退避算法来确定\n\n### PPP协议\n\n- 互联网用户通常需要连接到某个ISP之后才能接入到互联网，PPP协议是用户计算机和ISP进行通信时所使用的数据链路层协议\n- PPP协议的帧格式\n  - F字段为帧的定界符\n  - A和C字段暂时没有意义\n  - FCS字段是使用CRC的检验序列\n  - 信息部分的长度不超过1500\n\n### MAC地址\n\n- MAC地址是链路层地址，长度为6字节，用于唯一标识网络适配器\n- 一台主机拥有多少个网络适配器就有多少个MAC地址\n\n### 局域网\n\n- 局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目有线，主要有以太网、令牌环网等，可以按网络拓扑分为星型网、环形网、总线网\n- **以太网**\n  - 是一种星型拓扑局域网，早期使用集线器连接，集线器是一种物理层设备，作用于比特而不是帧，目前使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据MAC地址进行存储转发\n  - 以太网帧格式\n    - 目的地址\n    - 源地址\n    - 类型：标记上层使用的协议\n    - 数据\n    - FCS：使用CRC校验的序列\n    - 前同步码：为了计算FCS临时加入，计算结束丢弃\n\n- **交换机**\n  - 交换机具有自学能力，学习的是交换表的内容，交换表中存储着MAC地址到接口的映射，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容\n- **虚拟局域网**：可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网的成员才能收到链路层广播信息\n\n## 四、网络层\n\n### 概述\n\n- 网络层是整个互联网的核心，因此应该让网络层尽量简单，向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务，使用IP协议可以将物理网络连接起来\n- 与IP协议配套使用的还有三个协议\n  - 地址解析协议ARP\n  - 网际控制报协议ICMP\n  - 网际组管协议IGMP\n\n### IP协议\n\n- **IP数据报格式**\n\n  - 版本：IPv4和IPv6两个版本\n  - 首部长度：最大值为15，表示4个字节长度，因为首部固定长度为20个字节，所以该值最小为5\n  - 区分服务\n  - 总长度：包括首部长度和数据长度\n  - 生存时间：TTL\n  - 协议：指出携带的数据应该上交给哪个协议进行处理，如ICMP、TCP、UDP等\n  - 首部校验和：不包含数据部分，可以减少计算工作量\n  - 标识：在数据报长度过长发生分片的情况下，相同数据报的不同分片具有相同的标识符\n  - 片偏移：和标识符一起，用于发生分片的情况\n\n- **IP地址编码**\n\n  1. 分类：由网络号和主机号组成\n\n     - A类地址：网络号占一个字节，主机号占3个字节，网路号第一位为0，范围为：1.0.0.0-127.255.255.255\n     - B类地址：网路号占两个字节，主机号占一个字节，网路号前两位为10，范围为128.0.0.0-191.255.255.255\n     - C类地址：网路号占三个字节，主机号占一个字节，网络号前三位为110，范围为192.0.0.0-223.255.255.255\n\n  2. 子网划分\n\n     - 通过在主机号中那一部分作为子网号，将两级IP地址分为了网络号、子网号、主机号三级IP\n     - 要想使用子网，必须配置子网掩码，一个A类地址的子网掩码为255.0.0.0，一个B级地址的子网掩码为255.255.0.0，一个C级地址的子网掩码为255.255.255.0\n     - 真实的IP地址为三级IP地址与子网掩码进行与运算得到\n\n  3. 无分类\n\n     - 无分类编址CIDR消除了传统的地址分类和子网划分的概念，使用网络前缀和主机号对IP地址进行编码，采用在IP地址后面加上网络前缀的长度\n\n     - CIDR的地址掩码可以继续称为子网掩码\n\n### 地址解析协议ARP\n\n- 网络层实现主机之间的通信，而链路层实现每段链路之间的通信，因此在通信过程中数据报的源地址和目的地址始终不变，MAC地址随着链路的改变而改变，ARP协议实现了由IP地址得到MAC地址\n- 每个主机都有一个ARP告诉缓存，里面有本局域网内各主机和路由器的IP地址到MAC地址的映射表，如果主机A知道主机B的IP地址，但是ARP高速缓存中没有该IP地址到主机B的MAC地址的映射，此时主机A通过广播的方式发送ARP请求分组，主机B收到后发送ARP相应告诉主机A其MAC地址，随后主机A向其高速缓存写入主机B的IP地址到MAC地址的映射\n\n### 网际控制报文协议ICMP\n\n- ICMP是为了更有效的转发IP数据报和提高交付成功的集合，它封装在IP数据报中，但不属于高层协议\n- 分为差错报告报文和询问报文\n\n1. **Ping**\n   - Ping是ICMP的一个重要应用，主要用来测试两台主机之间的连通性\n2. **Traceroute**\n   - Traceroute是ICMP的另一个应用，用来跟踪一个分组远点到终点的路径\n\n### 虚拟专用网VPN\n\n- 由于IP地址的紧缺，一个机构能申请到的IP地址远小于本机构所拥有的主机数，并且一个机构不需要将所有的主机接入外部互联网，机构内计算机可以使用仅在本机构有效的IP地址\n- 有三个专用地址块\n  - 10.0.0.0-10.255.255.255\n  - 172.16.0.0-172.16.255.255\n  - 192.168.0.0-192.168.255.255\n- VPN使用公用的互联网作为本机构各专用网之间的通信载体，专用指机构内主机只与机构内的其他主机通信，虚拟指好像是，实际并不是，它有经过专用的互联网\n\n### 网络地址转换NAT\n\n- 专用网内部的主机使用本地IP地址又想和互联网上的主机通信时，可以使用NAT将本地IP转换为全球IP\n\n### 路由器\n\n- **路由器的结构**：从功能上分为路由选择和分组转发，分组转发由交换结构、一组输入端口、一组输出端口组成\n- **分组转发流程**\n  - 从数据报首部提取目的主机IP地址得到目的网络地址\n  - 如果这个网络地址是此路由器直接相连的某个网络地址，直接进行交付\n  - 若路由表中有目的IP地址的特定主机路由，将数据报传送给表中指明的下一路由器\n  - 若路由表中有到达此网络地址的路由，将数据报传给路由表中指明的下一路由\n  - 若路由表中有一默认路由，将数据报传送给路由表中所指明的默认路由\n  - 报告转发分组出错\n- **路由选择协议**：互联网可以划分为许多小的自治系统，可以将路由选择协议分为两大类\n  - 自治系统内部的路由选择：RIP（一种基于距离向量的路由选择协议）和OSPF（开放最短路径优先，使用Dijkstra的最短路径算法SPF）\n  - 自治系统间的路由选择：BGP（边界网关协议，寻找一条比较好的路由）\n\n## 五、运输层\n\n### 概念\n\n- 网络层只是将分组发送到目的主机，真正进行通信的并不是主机而是主机中的进程，运输层提供了进程间的逻辑通信，向高层用户屏蔽下面网络层的核心细节\n\n### UDP\n\n- **特点**：UDP是无连接的，尽最大可能交付，没有拥塞控制，面向报文，支持一对一、一对多、多对一和多对多通信\n- **UDP首部格式**\n  - 源端口\n  - 目的端口\n  - 长度\n  - 校验和\n\n### TCP\n\n- **特点**：面向连接，提供可靠交付，有流量控制、拥塞控制、提供双全工通信，面向字节流，只能是一对一的\n\n- **TCP首部格式**\n\n  - 序号：用于对字节流进行编号\n  - 确认号：期望收到的下一个报文段的序号，如B正确收到A发来的报文段，序号为501，携带数据长度为200字节，那边B期望下一个报文段的序号为701，B发送给A的报文段确认号就是701\n  - 数据偏移：指数据部分距离报文起始处的偏移量\n  - 确认ACK：当ACK=1时，确认号字段有效，否则无效，TCP规定在建立连接以后所有传输的报文段都必须将ACK置为1\n  - 同步SYN：在建立时用来同步序号，当SYN=1，ACK=0标识这是一个请求连接的报文段，若对方同意建立连接，则响应报文段中SYN=1，ACK=1\n  - 终止FIN：用来释放一个连接，当FIN=1时，标识此报文段发送方的数据发送完毕，要求释放连接\n  - 窗口：窗口值作为接收方让发送方设置其发送窗口的依据\n\n- **TCP三次握手**\n\n  ![1537776156503](C:\\Users\\59247\\AppData\\Roaming\\Typora\\typora-user-images\\1537776156503.png)\n\n  - 首先B处于LISTEN状态，等待客户的连接请求\n  - A向B发送请求连接报文，SYN=1，ACK=0，选择一个初始的序号x，A进入SYN-SENT状态\n  - B收到连接请求报文，如果同意建立连接，向A发送确认报文，SYN=1，ACK=1，确认号为x+1，同时也选择一个初始序号y，B进入SYN-RCVD状态\n  - A收到B的连接确认报文后，向B发送确认，ACK=1，确认号为y+1，序号为x+1，A进入ESTABLISH状态\n  - B收到A的确认后，建立连接，B进入ESTABLISH状态\n\n- **三次握手的原因**\n\n  - 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开，如果客户端发送的连接请求在网络中滞留，那么就会隔很长一段时间才能收到服务器发出的连接确认，客户端等待一个超时时间之后，就会重新发出连接请求，如果不进行三次握手，服务器就会收到两个连接请求，造成资源浪费，如果有第三次握手，客户端会忽略之前的阻塞的链接请求，只打开一个连接\n\n- **TCP的四次挥手**\n\n  ![1537776789549](C:\\Users\\59247\\AppData\\Roaming\\Typora\\typora-user-images\\1537776789549.png)\n\n  - 数据传输完毕，A、B都处于ESTABLISHED状态\n  - A发送释放连接报文，FIN=1，序号seq为u，A进入FIN-WAIT-1状态\n  - B收到A发出的释放连接报文，发出确认报文，ACK=1，序号为seq为v，确认号为u+1，B进入CLOSE-WAIT状态，A收到这个报文进入FIN-WAIT-2状态，此时B可以向A发送数据，而A不能像B发送数据\n  - 当B不要连接时，发送释放连接报文，FIN=1，ACK=1，序号seq为w，确认号为u+1，此时B进入LAST-ACK状态\n  - A收到释放连接报文，发送确认报文，ACK=1，序号seq为u+1，确认号为w+1，A进入TIME-WAIT状态，2s后释放连接进入CLOSED状态\n  - B收到A发出的确认报文，进入CLOSED状态\n\n- **四次挥手的原因**\n\n  - 客户端发送了FIN释放连接报文以后，服务器收到这个报文进入CLOSE-WAIT状态，这个状态是为了让服务器发送还未传送完毕的数据，传送完毕后，服务器会发送FIN连接释放报文\n  - 客户端收到服务器的FIN报文后进入TIME-WAIT状态等待2s后自动进入CLOSED状态而不是直接进入CLOSED状态是因为要确保最后一个确认报文到达，如果B没有收到A发送的确认报文，会重新发送请求释放连接报文，A等待一段时间是为了处理这种情况，等待一段时间是为了让本地连接持续时间内产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文\n\n- **TCP可靠传输**\n\n  - TCP使用超时重传来实现可靠传输，如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段\n\n- **TCP滑动窗口**\n\n  - 窗口是缓存的一部分，用来暂时存放字节流，发送方和接收方各有一个窗口，接收方通过TCP报文段中的窗口字段告诉发送方字节的窗口大小，发送方根据这个值和其他信息设置自己的窗口大小\n  - 发送方的窗口内字节都允许被发送，接收方窗口内的字节都允许被拒收，如果发送窗口左部的字节已经发送且收到确认，那么就将发送窗口向右移动一段距离，知道左部的第一个字节不再是已发送且已确认的状态；接收窗口类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动窗口\n  - 接收窗口会对窗口内最后一个按序到达的字节进行确认，发送方得到这个字节的确认后，就知道这个字节之前的所有字节都被接收\n\n- **TCP流量控制**\n\n  - 流量控制是为了控制发送方发送速率，保证接收方来得及接收，接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率，将窗口字段设置为0，则发送方不能发送数据\n\n- **TCP拥塞控制**\n\n  - 如果网络出现拥塞，分组会丢失，此时发送方继续重传，会导致网络拥塞程度更高，因此出现拥塞时应该控制发送方的速率，拥塞控制是为了降低整个网络的拥塞程度\n  - TCP主要通过四个算法进行拥塞控制：慢开始、拥塞避免、快重传、快恢复，发送方维护一个拥塞窗口的状态变量，和发送方窗口区别是拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据是发送窗口\n  - 慢开始与拥塞避免\n    - 发送最开始执行慢开始，使swnd=1，发送方只能发送一个报文段，当收到确认时，使cwnd加倍，慢开始每次都会使cwnd加倍，网络拥塞可能性变高，设置一个门限ssthresh，当cwnd>=ssthresh时进入拥塞避免，每轮只将cwnd加1，如果出现了超时，则令ssthresh=cwnd/2，然后重新执行慢开始\n  - 快重复与快恢复\n    - 在接收方，要求每次接收到报文段都对最后一个已收到的有序报文段进行确认，在发送方如果收到三个重复确认，就可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段，然后执行快恢复，令ssthresh=cwnd/2，cwnd=ssthresh，直接进入拥塞避免，慢开始和快恢复的快慢指cwnd的设定值，慢开始设定cwnd为1，快恢复设定为ssthresh\n\n## 六、应用层\n\n### 域名系统\n\n- DNS是一个分布式数据库，提供了主机名和IP地址间互换的服务，这里的分布式是指每个站点只保留它自己的那部分数据，域名从上到下分为：根域名、顶级域名、二级域名\n- DNS可以使用TCP或UDP进行传输，使用端口号为53，大多数使用UDP进行传输\n- **解析过程**\n  - 递归：主机向本地域名服务器查询一般使用递归查询，如果本地域名服务器不知道被查询IP地址，会向其他域名服务器发出查询请求\n  - 迭代：本地域名服务器向根域名服务器查询一般是采用迭代，由根域名服务器告诉本地域名服务器下一步查询的服务器然后由本地域名服务器继续查询\n\n### 文件传送协议\n\n- FTP使用TCP进行连接，需要两个连接来传送一个文件\n  - 控制连接：服务器打开端口号21等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端命令传送给服务器，并传回服务器的应答\n  - 数据连接：传送一个文件数据\n- 根据数据连接是否是服务器端主动建立，FTP有主动和被动两种模式\n  - 主动模式：服务器端主动建立数据连接，服务器端的端口号为20，客户端端口随机，但是必须大于1024，因为0-1023是熟知端口号。主动模式需要客户端开放端口号给服务器，需要配置客户端的防火墙\n  - 被动模式：客户端主动建立数据连接，客户端端口号由客户端自己指定，服务器端的端口号随机，被动模式只需要服务器开放端口号即可，无需客户端配置防火墙，但是服务器的安全性减弱，因为开放了过多端口号\n\n### 动态主机配置协议\n\n- **DHCP**：提供了即插即用的连网方式，自动配置IP地址，子网掩码，网关IP\n- **DHCP的工作流程**\n  - 客户端发送Discover报报文，放入UDP中，被广播到同一子网所有主机上\n  - DHCP服务器接收到Discover报文，发送Offer报文给客户端\n  - 如果客户端选择了某个DHCP服务器提供的信息，就发送Request报文给该DHCP服务器\n  - DHCP服务器发送ACK报文，表示客户端此时可以使用提供给它们的信息\n\n### 远程登陆协议\n\n- TELNET可以用于登陆到远程主机上，可以适应许多计算机和操作系统的差异\n\n### 电子邮件协议\n\n- 电子邮件协议由三部分组成：用户代理、邮件服务器及邮件协议。邮件协议包含发送协议和读取协议，发送协议常用SMTP，读取协议常用POP3和IMAP\n- **SMTP**\n  - 只能发送ASCII码，而互联网邮件扩充MIME可以发送二进制文件，MIME并没有盖顶或取代SMTP，而是增加了邮件主体的结构，定义了非ASCII码的编码规则\n- **POP3**\n  - 只要用户从服务器上读取了邮件，就把该邮件删除\n- **IMAP**\n  - 客户端和服务器端的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除，IMAP可以让用户随时随机访问服务器上的邮件\n\n### 常用端口和传输层协议类型\n\n|        应用层协议        | 端口号  |          传输层协议          |\n| :----------------------: | :-----: | :--------------------------: |\n|   DNS（域名解析协议）    |   53    | UDP/TCP（当长度超过512字节） |\n| DHCP（动态主机配置协议） |  67/68  |             UDP              |\n| SNMP（简单网络管理协议） | 161/162 |             UDP              |\n| TFTP（简单文件传输协议） |   69    |             UDP              |\n|   FTP（文件传输协议）    |  20/21  |             TCP              |\n|  TELNET（远程终端协议）  |   23    |             TCP              |\n|  HTTP（超文本传输协议）  |   80    |             TCP              |\n| SMTP（简单邮件传输协议） |   25    |             TCP              |\n|   POP3（邮件读取协议）   |   110   |             TCP              |\n| IMAP（网际报文存取协议） |   143   |             TCP              |\n\n### Web页面请求过程\n\n1. **DHCP配置主机信息**\n   - 假设主机最开始没有IP地址，使用DHCP获取IP地址，首先生成一个DHCP请求报文，将报文放入具有目的端叫67和源端口68的UDP报文中\n   - 将该报文放入一个具有广播IP目的地址和源地址的IP数据报中\n   - 该数据报放入MAC帧中，该帧具有能广播到与交换机连接的所有设备的目的地址\n   - DHCP收到广播帧之后，不断向上分解最终得到DHCP请求报文，生成DHCP的ACK报文，该报文包含IP地址、DNS服务器的IP地址、默认网关路由IP地址和子网掩码，然后将该报文放入UDP报文段，UDP报文段又被放入IP数据报，最后放入MAC帧，该帧的目的地址为主机的MAC地址\n   - 由于交换机具有学习能力，可以将MAC帧直接发送到主机\n   - 主机收到帧后，不断向上分解得到DHCP报文，之后配置它的IP地址、子网掩码和DNS服务器的IP地址，并在IP转发表中安装默认网关\n2. **ARP获取网关路由MAC地址**\n   - 主机生成一个包含目的地址为网关路由器的IP地址的ARP请求报文放入一个具有广播地址的MAC帧中，向交换机发送该帧，交换机将帧发送给所有连接设备\n   - 网关路由器收到帧后，不断向上分解得到ARP报文，如果其中IP与其接口的IP地址匹配，发送一个ARP响应报文给主机\n   - 主机生成一个DNS查询报文，目的端口号为53，该报文被放入目的地址为DNS服务器IP数据报中，然后放入一个MAC帧中，将该帧发送给网关路由器\n   - 网关路由器收到DNS查询报文，抽取出IP数据报将其数据报转发给下一路由器，最终到达DNS服务器\n3. **DNS域名解析**\n   - DNS服务器收到IP数据报后，得到DNS查询报文，在DNS数据库查询带解析的域名\n   - 找到DNS记录后发送DNS响应报文，将其放入UDP报文段然后放入IP数据报，通过路由器反向转发给网关路由然后通过交换机到达主机\n4. **HTTP请求页面**\n   - 有了HTTP服务器的IP地址后，主机生成TCP套接字\n   - 然后与HTTP服务器通过三次握手建立连接\n   - 连接建立后浏览器生成HTTP GET报文交付给HTTP服务器\n   - HTTP服务器从TCP套接字读取HTTP GET报文，生成HTTP响应报文，将Web页面放入报文主体发给主机\n   - 浏览器收到HTTP响应后，抽取Web页面内容进行渲染，显示Web页面\n\n## 参考资料\n\n- 计算机网络, 谢希仁\n- JamesF.Kurose, KeithW.Ross, 库罗斯, 等. 计算机网络: 自顶向下方法 [M]. 机械工业出版社, 2014.\n- W.RichardStevens. TCP/IP 详解. 卷 1, 协议 [M]. 机械工业出版社, 2006.\n- [Active vs Passive FTP Mode: Which One is More Secure?](https://securitywing.com/active-vs-passive-ftp-mode/)\n- [Active and Passive FTP Transfers Defined - KB Article #1138](http://www.serv-u.com/kb/1138/active-and-passive-ftp-transfers-defined)\n- [Traceroute](https://zh.wikipedia.org/wiki/Traceroute)\n- [ping](https://zh.wikipedia.org/wiki/Ping)\n- [How DHCP works and DHCP Interview Questions and Answers](http://webcache.googleusercontent.com/search?q=cache:http://anandgiria.blogspot.com/2013/09/windows-dhcp-interview-questions-and.html)\n- [What is process of DORA in DHCP?](https://www.quora.com/What-is-process-of-DORA-in-DHCP)\n- [What is DHCP Server ?](https://tecadmin.net/what-is-dhcp-server/)\n- [Tackling emissions targets in Tokyo](http://www.climatechangenews.com/2011/html/university-tokyo.html)\n- [What does my ISP know when I use Tor?](http://www.climatechangenews.com/2011/html/university-tokyo.html)\n- [Technology-Computer Networking[1\\]-Computer Networks and the Internet](http://www.linyibin.cn/2017/02/12/technology-ComputerNetworking-Internet/)\n- [P2P 网络概述.](http://slidesplayer.com/slide/11616167/)\n- [Circuit Switching (a) Circuit switching. (b) Packet switching.](http://slideplayer.com/slide/5115386/)', '2019-02-16 11:39:08', '<h2>一、概述</h2>\n<h3>ISP</h3>\n<ul>\n<li>ISP指互联网服务提供商，ISP可以从互联网管理机构获取很多IP地址，同时拥有通信线路及路由器互联网等设备，个人或机构向ISP缴纳一定的费用就可以接入互联网</li>\n<li>目前的互联网是一种多层次ISP结构，ISP根据覆盖面积的大小分为第一层ISP、区域ISP和接入ISP</li>\n</ul>\n<h3>主机间的通信方式</h3>\n<ul>\n<li>C/S：客户是服务的请求方，服务器是服务的提供方</li>\n<li>P2P：不区分客户和服务器</li>\n</ul>\n<h3>计算机网络体系结构</h3>\n<p><img src=\"C:\\Users\\59247\\AppData\\Roaming\\Typora\\typora-user-images\\1537757939109.png\" alt=\"1537757939109\" /></p>\n<ol>\n<li><p><strong>五层协议</strong></p>\n</li>\n<li><p>应用层：为特定应用程序提供数据传输服务，数据单位为报文</p>\n</li>\n<li><p>传输层：为进程提供统一的数据传输服务，运输层包括两种协议：传输控制协议TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议UDP，提供面向无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP提供完整性服务，UDP提供及时性服务</p>\n</li>\n<li><p>网络层：为主机提供数据传输服务，而运输层协议是为主机中的进程提供数据传输服务，网络层将传输层传递下来的报文段或者用户数据报封装成分组</p>\n</li>\n<li><p>数据链路层：网络层针对的是主机间的数据传输服务，而主机间有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层将网络层传下来的分组封装成帧</p>\n</li>\n<li><p>物理层：考虑是怎样在传输媒体上传输成比特流，而不是指具体的传输媒体</p>\n</li>\n<li><p><strong>OSI</strong></p>\n</li>\n<li><p>在五层协议的基础上，将应用层又分为应用层、表示层、会话层，其中表示层和会话层功能如下</p>\n<ul>\n<li>表示层：数据压缩、加密以及数据描述，使应用程序不必关心各台主机中数据内部格式不同的问题</li>\n<li>会话层：建立及管理会话</li>\n</ul>\n</li>\n<li><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理</p>\n</li>\n<li><h3>TCP/IP</h3>\n</li>\n<li><p>在五层协议的基础上，将数据链路层和物理层合并为网络接口层</p>\n</li>\n<li><p>TCP/IP体系结构不严格遵循OSI分层概念，应用层可能直接使用网络层和网络接口层</p>\n</li>\n<li><p>TCP/IP协议族是一种沙漏形状，中间小两边大，IP协议在其中占举足轻重的地位</p>\n</li>\n<li><p>数据在各层传递的过程</p>\n</li>\n<li><p>在向下的过程，需要添加下层协议所需的首部或尾部，在向上的过程中不断拆开首部和尾部</p>\n</li>\n<li><p>路由器只有下三层协议，因为路由器位于网络和心中，不需要为进程或应用程序提供服务，因此也就不需要运输层和应用层</p>\n</li>\n</ol>\n<h2>二、物理层</h2>\n<h3>通信方式</h3>\n<ul>\n<li>单工通信：单向传输</li>\n<li>半双工通信：双向交替传输</li>\n<li>全双工通信：双向同时传输</li>\n</ul>\n<h3>带通调制</h3>\n<ul>\n<li>模拟信号是连续的信号，数字信号是离散的信号，带通调制是把数字信号转换为模拟信号</li>\n</ul>\n<h2>三、数据链路层</h2>\n<h3>基本问题</h3>\n<ol>\n<li><strong>封装成帧</strong>：将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束</li>\n<li><strong>透明传输</strong>：帧使用首部和尾部进行定界，如果帧的数据部分包含有首部和尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部和尾部相同的内容前插入转义字符</li>\n<li><strong>差错检测</strong>：目前数据链路层广泛使用循环冗余检测（CRC）来检测比特差错</li>\n</ol>\n<h3>信道分类</h3>\n<ol>\n<li><strong>广播信号</strong>：一对多通信，一个节点发送的数据能够被所有节点接收，主要使用两种控制方法进行协调，一种使用信道复用技术，一种使用CSMA.CD协议</li>\n<li><strong>点对点通信</strong>：一对一通信，使用PPP协议进行控制</li>\n</ol>\n<h3>信道复用技术</h3>\n<ol>\n<li><strong>频分复用</strong>：所有主机在相同的时间占用不同的频率宽带资源</li>\n<li><strong>时分复用</strong>：所有主机在不同时间占用相同频率的宽带资源</li>\n<li><strong>统计时分复用</strong>：对时分复用的改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来统计时分复用帧然后发送</li>\n<li><strong>波分复用</strong>：光的频分复用，使用波长代替频率表示使用的光载波</li>\n<li><strong>码分复用</strong>：为每个用户分配码片，所有码片正交</li>\n</ol>\n<h3>CSMA/CD协议</h3>\n<ul>\n<li><strong>多点接入</strong>：说明这是总线型网络，许多主机以多点的方式连接到总线</li>\n<li><strong>载波监听</strong>：每个主机都必须不停的监听信道，如果监听到信道正在使用，就必须等待</li>\n<li><strong>碰撞检测</strong>：在发送中，如果监听到信道已有其他主机正在发送数据，就表示发生了碰撞，当发生碰撞时，站点要停止发送，等待一段时间再发送，这个时间采用截断二进制指数退避算法来确定</li>\n</ul>\n<h3>PPP协议</h3>\n<ul>\n<li>互联网用户通常需要连接到某个ISP之后才能接入到互联网，PPP协议是用户计算机和ISP进行通信时所使用的数据链路层协议</li>\n<li>PPP协议的帧格式</li>\n<li>F字段为帧的定界符</li>\n<li>A和C字段暂时没有意义</li>\n<li>FCS字段是使用CRC的检验序列</li>\n<li>信息部分的长度不超过1500</li>\n</ul>\n<h3>MAC地址</h3>\n<ul>\n<li>MAC地址是链路层地址，长度为6字节，用于唯一标识网络适配器</li>\n<li>一台主机拥有多少个网络适配器就有多少个MAC地址</li>\n</ul>\n<h3>局域网</h3>\n<ul>\n<li><p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目有线，主要有以太网、令牌环网等，可以按网络拓扑分为星型网、环形网、总线网</p>\n</li>\n<li><p><strong>以太网</strong></p>\n</li>\n<li><p>是一种星型拓扑局域网，早期使用集线器连接，集线器是一种物理层设备，作用于比特而不是帧，目前使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据MAC地址进行存储转发</p>\n</li>\n<li><p>以太网帧格式</p>\n<ul>\n<li>目的地址</li>\n<li>源地址</li>\n<li>类型：标记上层使用的协议</li>\n<li>数据</li>\n<li>FCS：使用CRC校验的序列</li>\n<li>前同步码：为了计算FCS临时加入，计算结束丢弃</li>\n</ul>\n</li>\n<li><p><strong>交换机</strong></p>\n</li>\n<li><p>交换机具有自学能力，学习的是交换表的内容，交换表中存储着MAC地址到接口的映射，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容</p>\n</li>\n<li><p><strong>虚拟局域网</strong>：可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网的成员才能收到链路层广播信息</p>\n</li>\n</ul>\n<h2>四、网络层</h2>\n<h3>概述</h3>\n<ul>\n<li>网络层是整个互联网的核心，因此应该让网络层尽量简单，向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务，使用IP协议可以将物理网络连接起来</li>\n<li>与IP协议配套使用的还有三个协议</li>\n<li>地址解析协议ARP</li>\n<li>网际控制报协议ICMP</li>\n<li>网际组管协议IGMP</li>\n</ul>\n<h3>IP协议</h3>\n<ul>\n<li><p><strong>IP数据报格式</strong></p>\n</li>\n<li><p>版本：IPv4和IPv6两个版本</p>\n</li>\n<li><p>首部长度：最大值为15，表示4个字节长度，因为首部固定长度为20个字节，所以该值最小为5</p>\n</li>\n<li><p>区分服务</p>\n</li>\n<li><p>总长度：包括首部长度和数据长度</p>\n</li>\n<li><p>生存时间：TTL</p>\n</li>\n<li><p>协议：指出携带的数据应该上交给哪个协议进行处理，如ICMP、TCP、UDP等</p>\n</li>\n<li><p>首部校验和：不包含数据部分，可以减少计算工作量</p>\n</li>\n<li><p>标识：在数据报长度过长发生分片的情况下，相同数据报的不同分片具有相同的标识符</p>\n</li>\n<li><p>片偏移：和标识符一起，用于发生分片的情况</p>\n</li>\n<li><p><strong>IP地址编码</strong></p>\n</li>\n<li><p>分类：由网络号和主机号组成</p>\n<ul>\n<li>A类地址：网络号占一个字节，主机号占3个字节，网路号第一位为0，范围为：1.0.0.0-127.255.255.255</li>\n<li>B类地址：网路号占两个字节，主机号占一个字节，网路号前两位为10，范围为128.0.0.0-191.255.255.255</li>\n<li>C类地址：网路号占三个字节，主机号占一个字节，网络号前三位为110，范围为192.0.0.0-223.255.255.255</li>\n</ul>\n</li>\n<li><p>子网划分</p>\n<ul>\n<li>通过在主机号中那一部分作为子网号，将两级IP地址分为了网络号、子网号、主机号三级IP</li>\n<li>要想使用子网，必须配置子网掩码，一个A类地址的子网掩码为255.0.0.0，一个B级地址的子网掩码为255.255.0.0，一个C级地址的子网掩码为255.255.255.0</li>\n<li>真实的IP地址为三级IP地址与子网掩码进行与运算得到</li>\n</ul>\n</li>\n<li><p>无分类</p>\n<ul>\n<li><p>无分类编址CIDR消除了传统的地址分类和子网划分的概念，使用网络前缀和主机号对IP地址进行编码，采用在IP地址后面加上网络前缀的长度</p>\n</li>\n<li><p>CIDR的地址掩码可以继续称为子网掩码</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3>地址解析协议ARP</h3>\n<ul>\n<li>网络层实现主机之间的通信，而链路层实现每段链路之间的通信，因此在通信过程中数据报的源地址和目的地址始终不变，MAC地址随着链路的改变而改变，ARP协议实现了由IP地址得到MAC地址</li>\n<li>每个主机都有一个ARP告诉缓存，里面有本局域网内各主机和路由器的IP地址到MAC地址的映射表，如果主机A知道主机B的IP地址，但是ARP高速缓存中没有该IP地址到主机B的MAC地址的映射，此时主机A通过广播的方式发送ARP请求分组，主机B收到后发送ARP相应告诉主机A其MAC地址，随后主机A向其高速缓存写入主机B的IP地址到MAC地址的映射</li>\n</ul>\n<h3>网际控制报文协议ICMP</h3>\n<ul>\n<li><p>ICMP是为了更有效的转发IP数据报和提高交付成功的集合，它封装在IP数据报中，但不属于高层协议</p>\n</li>\n<li><p>分为差错报告报文和询问报文</p>\n</li>\n<li><p><strong>Ping</strong></p>\n</li>\n<li><p>Ping是ICMP的一个重要应用，主要用来测试两台主机之间的连通性</p>\n</li>\n<li><p><strong>Traceroute</strong></p>\n</li>\n<li><p>Traceroute是ICMP的另一个应用，用来跟踪一个分组远点到终点的路径</p>\n</li>\n</ul>\n<h3>虚拟专用网VPN</h3>\n<ul>\n<li>由于IP地址的紧缺，一个机构能申请到的IP地址远小于本机构所拥有的主机数，并且一个机构不需要将所有的主机接入外部互联网，机构内计算机可以使用仅在本机构有效的IP地址</li>\n<li>有三个专用地址块</li>\n<li>10.0.0.0-10.255.255.255</li>\n<li>172.16.0.0-172.16.255.255</li>\n<li>192.168.0.0-192.168.255.255</li>\n<li>VPN使用公用的互联网作为本机构各专用网之间的通信载体，专用指机构内主机只与机构内的其他主机通信，虚拟指好像是，实际并不是，它有经过专用的互联网</li>\n</ul>\n<h3>网络地址转换NAT</h3>\n<ul>\n<li>专用网内部的主机使用本地IP地址又想和互联网上的主机通信时，可以使用NAT将本地IP转换为全球IP</li>\n</ul>\n<h3>路由器</h3>\n<ul>\n<li><strong>路由器的结构</strong>：从功能上分为路由选择和分组转发，分组转发由交换结构、一组输入端口、一组输出端口组成</li>\n<li><strong>分组转发流程</strong></li>\n<li>从数据报首部提取目的主机IP地址得到目的网络地址</li>\n<li>如果这个网络地址是此路由器直接相连的某个网络地址，直接进行交付</li>\n<li>若路由表中有目的IP地址的特定主机路由，将数据报传送给表中指明的下一路由器</li>\n<li>若路由表中有到达此网络地址的路由，将数据报传给路由表中指明的下一路由</li>\n<li>若路由表中有一默认路由，将数据报传送给路由表中所指明的默认路由</li>\n<li>报告转发分组出错</li>\n<li><strong>路由选择协议</strong>：互联网可以划分为许多小的自治系统，可以将路由选择协议分为两大类</li>\n<li>自治系统内部的路由选择：RIP（一种基于距离向量的路由选择协议）和OSPF（开放最短路径优先，使用Dijkstra的最短路径算法SPF）</li>\n<li>自治系统间的路由选择：BGP（边界网关协议，寻找一条比较好的路由）</li>\n</ul>\n<h2>五、运输层</h2>\n<h3>概念</h3>\n<ul>\n<li>网络层只是将分组发送到目的主机，真正进行通信的并不是主机而是主机中的进程，运输层提供了进程间的逻辑通信，向高层用户屏蔽下面网络层的核心细节</li>\n</ul>\n<h3>UDP</h3>\n<ul>\n<li><strong>特点</strong>：UDP是无连接的，尽最大可能交付，没有拥塞控制，面向报文，支持一对一、一对多、多对一和多对多通信</li>\n<li><strong>UDP首部格式</strong></li>\n<li>源端口</li>\n<li>目的端口</li>\n<li>长度</li>\n<li>校验和</li>\n</ul>\n<h3>TCP</h3>\n<ul>\n<li><p><strong>特点</strong>：面向连接，提供可靠交付，有流量控制、拥塞控制、提供双全工通信，面向字节流，只能是一对一的</p>\n</li>\n<li><p><strong>TCP首部格式</strong></p>\n</li>\n<li><p>序号：用于对字节流进行编号</p>\n</li>\n<li><p>确认号：期望收到的下一个报文段的序号，如B正确收到A发来的报文段，序号为501，携带数据长度为200字节，那边B期望下一个报文段的序号为701，B发送给A的报文段确认号就是701</p>\n</li>\n<li><p>数据偏移：指数据部分距离报文起始处的偏移量</p>\n</li>\n<li><p>确认ACK：当ACK=1时，确认号字段有效，否则无效，TCP规定在建立连接以后所有传输的报文段都必须将ACK置为1</p>\n</li>\n<li><p>同步SYN：在建立时用来同步序号，当SYN=1，ACK=0标识这是一个请求连接的报文段，若对方同意建立连接，则响应报文段中SYN=1，ACK=1</p>\n</li>\n<li><p>终止FIN：用来释放一个连接，当FIN=1时，标识此报文段发送方的数据发送完毕，要求释放连接</p>\n</li>\n<li><p>窗口：窗口值作为接收方让发送方设置其发送窗口的依据</p>\n</li>\n<li><p><strong>TCP三次握手</strong></p>\n<p><img src=\"C:\\Users\\59247\\AppData\\Roaming\\Typora\\typora-user-images\\1537776156503.png\" alt=\"1537776156503\" /></p>\n</li>\n<li><p>首先B处于LISTEN状态，等待客户的连接请求</p>\n</li>\n<li><p>A向B发送请求连接报文，SYN=1，ACK=0，选择一个初始的序号x，A进入SYN-SENT状态</p>\n</li>\n<li><p>B收到连接请求报文，如果同意建立连接，向A发送确认报文，SYN=1，ACK=1，确认号为x+1，同时也选择一个初始序号y，B进入SYN-RCVD状态</p>\n</li>\n<li><p>A收到B的连接确认报文后，向B发送确认，ACK=1，确认号为y+1，序号为x+1，A进入ESTABLISH状态</p>\n</li>\n<li><p>B收到A的确认后，建立连接，B进入ESTABLISH状态</p>\n</li>\n<li><p><strong>三次握手的原因</strong></p>\n</li>\n<li><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开，如果客户端发送的连接请求在网络中滞留，那么就会隔很长一段时间才能收到服务器发出的连接确认，客户端等待一个超时时间之后，就会重新发出连接请求，如果不进行三次握手，服务器就会收到两个连接请求，造成资源浪费，如果有第三次握手，客户端会忽略之前的阻塞的链接请求，只打开一个连接</p>\n</li>\n<li><p><strong>TCP的四次挥手</strong></p>\n<p><img src=\"C:\\Users\\59247\\AppData\\Roaming\\Typora\\typora-user-images\\1537776789549.png\" alt=\"1537776789549\" /></p>\n</li>\n<li><p>数据传输完毕，A、B都处于ESTABLISHED状态</p>\n</li>\n<li><p>A发送释放连接报文，FIN=1，序号seq为u，A进入FIN-WAIT-1状态</p>\n</li>\n<li><p>B收到A发出的释放连接报文，发出确认报文，ACK=1，序号为seq为v，确认号为u+1，B进入CLOSE-WAIT状态，A收到这个报文进入FIN-WAIT-2状态，此时B可以向A发送数据，而A不能像B发送数据</p>\n</li>\n<li><p>当B不要连接时，发送释放连接报文，FIN=1，ACK=1，序号seq为w，确认号为u+1，此时B进入LAST-ACK状态</p>\n</li>\n<li><p>A收到释放连接报文，发送确认报文，ACK=1，序号seq为u+1，确认号为w+1，A进入TIME-WAIT状态，2s后释放连接进入CLOSED状态</p>\n</li>\n<li><p>B收到A发出的确认报文，进入CLOSED状态</p>\n</li>\n<li><p><strong>四次挥手的原因</strong></p>\n</li>\n<li><p>客户端发送了FIN释放连接报文以后，服务器收到这个报文进入CLOSE-WAIT状态，这个状态是为了让服务器发送还未传送完毕的数据，传送完毕后，服务器会发送FIN连接释放报文</p>\n</li>\n<li><p>客户端收到服务器的FIN报文后进入TIME-WAIT状态等待2s后自动进入CLOSED状态而不是直接进入CLOSED状态是因为要确保最后一个确认报文到达，如果B没有收到A发送的确认报文，会重新发送请求释放连接报文，A等待一段时间是为了处理这种情况，等待一段时间是为了让本地连接持续时间内产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文</p>\n</li>\n<li><p><strong>TCP可靠传输</strong></p>\n</li>\n<li><p>TCP使用超时重传来实现可靠传输，如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段</p>\n</li>\n<li><p><strong>TCP滑动窗口</strong></p>\n</li>\n<li><p>窗口是缓存的一部分，用来暂时存放字节流，发送方和接收方各有一个窗口，接收方通过TCP报文段中的窗口字段告诉发送方字节的窗口大小，发送方根据这个值和其他信息设置自己的窗口大小</p>\n</li>\n<li><p>发送方的窗口内字节都允许被发送，接收方窗口内的字节都允许被拒收，如果发送窗口左部的字节已经发送且收到确认，那么就将发送窗口向右移动一段距离，知道左部的第一个字节不再是已发送且已确认的状态；接收窗口类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动窗口</p>\n</li>\n<li><p>接收窗口会对窗口内最后一个按序到达的字节进行确认，发送方得到这个字节的确认后，就知道这个字节之前的所有字节都被接收</p>\n</li>\n<li><p><strong>TCP流量控制</strong></p>\n</li>\n<li><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收，接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率，将窗口字段设置为0，则发送方不能发送数据</p>\n</li>\n<li><p><strong>TCP拥塞控制</strong></p>\n</li>\n<li><p>如果网络出现拥塞，分组会丢失，此时发送方继续重传，会导致网络拥塞程度更高，因此出现拥塞时应该控制发送方的速率，拥塞控制是为了降低整个网络的拥塞程度</p>\n</li>\n<li><p>TCP主要通过四个算法进行拥塞控制：慢开始、拥塞避免、快重传、快恢复，发送方维护一个拥塞窗口的状态变量，和发送方窗口区别是拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据是发送窗口</p>\n</li>\n<li><p>慢开始与拥塞避免</p>\n<ul>\n<li>发送最开始执行慢开始，使swnd=1，发送方只能发送一个报文段，当收到确认时，使cwnd加倍，慢开始每次都会使cwnd加倍，网络拥塞可能性变高，设置一个门限ssthresh，当cwnd>=ssthresh时进入拥塞避免，每轮只将cwnd加1，如果出现了超时，则令ssthresh=cwnd/2，然后重新执行慢开始</li>\n</ul>\n</li>\n<li><p>快重复与快恢复</p>\n<ul>\n<li>在接收方，要求每次接收到报文段都对最后一个已收到的有序报文段进行确认，在发送方如果收到三个重复确认，就可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段，然后执行快恢复，令ssthresh=cwnd/2，cwnd=ssthresh，直接进入拥塞避免，慢开始和快恢复的快慢指cwnd的设定值，慢开始设定cwnd为1，快恢复设定为ssthresh</li>\n</ul>\n</li>\n</ul>\n<h2>六、应用层</h2>\n<h3>域名系统</h3>\n<ul>\n<li>DNS是一个分布式数据库，提供了主机名和IP地址间互换的服务，这里的分布式是指每个站点只保留它自己的那部分数据，域名从上到下分为：根域名、顶级域名、二级域名</li>\n<li>DNS可以使用TCP或UDP进行传输，使用端口号为53，大多数使用UDP进行传输</li>\n<li><strong>解析过程</strong></li>\n<li>递归：主机向本地域名服务器查询一般使用递归查询，如果本地域名服务器不知道被查询IP地址，会向其他域名服务器发出查询请求</li>\n<li>迭代：本地域名服务器向根域名服务器查询一般是采用迭代，由根域名服务器告诉本地域名服务器下一步查询的服务器然后由本地域名服务器继续查询</li>\n</ul>\n<h3>文件传送协议</h3>\n<ul>\n<li>FTP使用TCP进行连接，需要两个连接来传送一个文件</li>\n<li>控制连接：服务器打开端口号21等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端命令传送给服务器，并传回服务器的应答</li>\n<li>数据连接：传送一个文件数据</li>\n<li>根据数据连接是否是服务器端主动建立，FTP有主动和被动两种模式</li>\n<li>主动模式：服务器端主动建立数据连接，服务器端的端口号为20，客户端端口随机，但是必须大于1024，因为0-1023是熟知端口号。主动模式需要客户端开放端口号给服务器，需要配置客户端的防火墙</li>\n<li>被动模式：客户端主动建立数据连接，客户端端口号由客户端自己指定，服务器端的端口号随机，被动模式只需要服务器开放端口号即可，无需客户端配置防火墙，但是服务器的安全性减弱，因为开放了过多端口号</li>\n</ul>\n<h3>动态主机配置协议</h3>\n<ul>\n<li><strong>DHCP</strong>：提供了即插即用的连网方式，自动配置IP地址，子网掩码，网关IP</li>\n<li><strong>DHCP的工作流程</strong></li>\n<li>客户端发送Discover报报文，放入UDP中，被广播到同一子网所有主机上</li>\n<li>DHCP服务器接收到Discover报文，发送Offer报文给客户端</li>\n<li>如果客户端选择了某个DHCP服务器提供的信息，就发送Request报文给该DHCP服务器</li>\n<li>DHCP服务器发送ACK报文，表示客户端此时可以使用提供给它们的信息</li>\n</ul>\n<h3>远程登陆协议</h3>\n<ul>\n<li>TELNET可以用于登陆到远程主机上，可以适应许多计算机和操作系统的差异</li>\n</ul>\n<h3>电子邮件协议</h3>\n<ul>\n<li>电子邮件协议由三部分组成：用户代理、邮件服务器及邮件协议。邮件协议包含发送协议和读取协议，发送协议常用SMTP，读取协议常用POP3和IMAP</li>\n<li><strong>SMTP</strong></li>\n<li>只能发送ASCII码，而互联网邮件扩充MIME可以发送二进制文件，MIME并没有盖顶或取代SMTP，而是增加了邮件主体的结构，定义了非ASCII码的编码规则</li>\n<li><strong>POP3</strong></li>\n<li>只要用户从服务器上读取了邮件，就把该邮件删除</li>\n<li><strong>IMAP</strong></li>\n<li>客户端和服务器端的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除，IMAP可以让用户随时随机访问服务器上的邮件</li>\n</ul>\n<h3>常用端口和传输层协议类型</h3>\n<p>|        应用层协议        | 端口号  |          传输层协议          |\n| :----------------------: | :-----: | :--------------------------: |\n|   DNS（域名解析协议）    |   53    | UDP/TCP（当长度超过512字节） |\n| DHCP（动态主机配置协议） |  67/68  |             UDP              |\n| SNMP（简单网络管理协议） | 161/162 |             UDP              |\n| TFTP（简单文件传输协议） |   69    |             UDP              |\n|   FTP（文件传输协议）    |  20/21  |             TCP              |\n|  TELNET（远程终端协议）  |   23    |             TCP              |\n|  HTTP（超文本传输协议）  |   80    |             TCP              |\n| SMTP（简单邮件传输协议） |   25    |             TCP              |\n|   POP3（邮件读取协议）   |   110   |             TCP              |\n| IMAP（网际报文存取协议） |   143   |             TCP              |</p>\n<h3>Web页面请求过程</h3>\n<ol>\n<li><strong>DHCP配置主机信息</strong></li>\n<li>假设主机最开始没有IP地址，使用DHCP获取IP地址，首先生成一个DHCP请求报文，将报文放入具有目的端叫67和源端口68的UDP报文中</li>\n<li>将该报文放入一个具有广播IP目的地址和源地址的IP数据报中</li>\n<li>该数据报放入MAC帧中，该帧具有能广播到与交换机连接的所有设备的目的地址</li>\n<li>DHCP收到广播帧之后，不断向上分解最终得到DHCP请求报文，生成DHCP的ACK报文，该报文包含IP地址、DNS服务器的IP地址、默认网关路由IP地址和子网掩码，然后将该报文放入UDP报文段，UDP报文段又被放入IP数据报，最后放入MAC帧，该帧的目的地址为主机的MAC地址</li>\n<li>由于交换机具有学习能力，可以将MAC帧直接发送到主机</li>\n<li>主机收到帧后，不断向上分解得到DHCP报文，之后配置它的IP地址、子网掩码和DNS服务器的IP地址，并在IP转发表中安装默认网关</li>\n<li><strong>ARP获取网关路由MAC地址</strong></li>\n<li>主机生成一个包含目的地址为网关路由器的IP地址的ARP请求报文放入一个具有广播地址的MAC帧中，向交换机发送该帧，交换机将帧发送给所有连接设备</li>\n<li>网关路由器收到帧后，不断向上分解得到ARP报文，如果其中IP与其接口的IP地址匹配，发送一个ARP响应报文给主机</li>\n<li>主机生成一个DNS查询报文，目的端口号为53，该报文被放入目的地址为DNS服务器IP数据报中，然后放入一个MAC帧中，将该帧发送给网关路由器</li>\n<li>网关路由器收到DNS查询报文，抽取出IP数据报将其数据报转发给下一路由器，最终到达DNS服务器</li>\n<li><strong>DNS域名解析</strong></li>\n<li>DNS服务器收到IP数据报后，得到DNS查询报文，在DNS数据库查询带解析的域名</li>\n<li>找到DNS记录后发送DNS响应报文，将其放入UDP报文段然后放入IP数据报，通过路由器反向转发给网关路由然后通过交换机到达主机</li>\n<li><strong>HTTP请求页面</strong></li>\n<li>有了HTTP服务器的IP地址后，主机生成TCP套接字</li>\n<li>然后与HTTP服务器通过三次握手建立连接</li>\n<li>连接建立后浏览器生成HTTP GET报文交付给HTTP服务器</li>\n<li>HTTP服务器从TCP套接字读取HTTP GET报文，生成HTTP响应报文，将Web页面放入报文主体发给主机</li>\n<li>浏览器收到HTTP响应后，抽取Web页面内容进行渲染，显示Web页面</li>\n</ol>\n<h2>参考资料</h2>\n<ul>\n<li>计算机网络, 谢希仁</li>\n<li>JamesF.Kurose, KeithW.Ross, 库罗斯, 等. 计算机网络: 自顶向下方法 [M]. 机械工业出版社, 2014.</li>\n<li>W.RichardStevens. TCP/IP 详解. 卷 1, 协议 [M]. 机械工业出版社, 2006.</li>\n<li><a href=\"https://securitywing.com/active-vs-passive-ftp-mode/\">Active vs Passive FTP Mode: Which One is More Secure?</a></li>\n<li><a href=\"http://www.serv-u.com/kb/1138/active-and-passive-ftp-transfers-defined\">Active and Passive FTP Transfers Defined - KB Article #1138</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/Traceroute\">Traceroute</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/Ping\">ping</a></li>\n<li><a href=\"http://webcache.googleusercontent.com/search?q=cache:http://anandgiria.blogspot.com/2013/09/windows-dhcp-interview-questions-and.html\">How DHCP works and DHCP Interview Questions and Answers</a></li>\n<li><a href=\"https://www.quora.com/What-is-process-of-DORA-in-DHCP\">What is process of DORA in DHCP?</a></li>\n<li><a href=\"https://tecadmin.net/what-is-dhcp-server/\">What is DHCP Server ?</a></li>\n<li><a href=\"http://www.climatechangenews.com/2011/html/university-tokyo.html\">Tackling emissions targets in Tokyo</a></li>\n<li><a href=\"http://www.climatechangenews.com/2011/html/university-tokyo.html\">What does my ISP know when I use Tor?</a></li>\n<li><a href=\"http://www.linyibin.cn/2017/02/12/technology-ComputerNetworking-Internet/\">Technology-Computer Networking[1]-Computer Networks and the Internet</a></li>\n<li><a href=\"http://slidesplayer.com/slide/11616167/\">P2P 网络概述.</a></li>\n<li><a href=\"http://slideplayer.com/slide/5115386/\">Circuit Switching (a) Circuit switching. (b) Packet switching.</a></li>\n</ul>\n', 3, '计算机网络模型、各层协议', 'net', '计算机网络', 1, 3, 2);
INSERT INTO blog VALUES (4, 2, '### 缓存特征\n\n- **命中率**：返回正确结果数/请求缓存次数，命中率越高表明缓存的使用率越高\n- **最大空间**：缓存可以存放的最大元素的数量，当缓存中元素超过这个值会触发启动淘汰策略\n- **淘汰策略**：当缓存空间被占满，使用淘汰策略处理，设计适合自身数据特征的淘汰策略能提高命中率，常见的淘汰策略有：\n  - FIFO：先进先出策略，先进入缓存的数据会被优先清除\n  - LFU：最少使用策略，根据元素的被使用次数清除次数较少的元素，策略主要比较元素的命中次数\n  - LRU：最近最少使用策略，根据元素最后一次被使用的时间戳，清除最远使用时间戳的元素释放空间，主要比较元素最近一次被get使用的事件，在热点数据场景下适用\n\n### 缓存介质\n\n- **内存**：将缓存存储于内存是最快的选择，无需IO开销，缺点是无法持久化到磁盘\n- **硬盘**：一般来说，很多框架会结合适用内存和硬盘，在内存分配空间满了或者异常情况下，可以主动或被动将内存空间数据持久化到硬盘中\n- **数据库**：一些NoSQL数据库的响应速度和吞吐量远高于常见的关系型数据库，因此可以将这类数据库作为缓存介质\n\n### 缓存分类和应用场景\n\n- **浏览器**：当HTTP响应允许进行缓存时，浏览器会将HTML、CSS等静态资源进行缓存\n- **ISP**：网络服务器提供商是网络访问的第一条，通过将数据缓存在ISP中能提高用户的访问速度\n- **反向代理**：反向代理位于服务器之前，请求和响应都需要经过反向代理\n- **本地缓存**：指的是在应用中的缓存组件，最大优点是应用和缓存在统一进程，请求缓存速度很快，无需额外的网络开销，在单应用不需要集群支持的场景下适用本地缓存比较合适。缺点是缓存和应用程序耦合，多个应用无法直接共享缓存，各应用节点需要维护自己的单独缓存\n- **分布式缓存**：指应用分离的缓存组建，最大优点是自身作为一个独立的应用与本地应用隔离，多个应用可以共享内存\n- **数据库缓存**：M有SQL等数据库管理系统具有自己的查询缓存机制来提高查询效率\n\n### 本地缓存\n\n- **编程实现缓存**：个别情况下，我们只需要简单的缓存数据的功能，而无需关注存取、淘汰策略时，直接编程实现缓存是迅捷和高效的。具体做法是适用hashmap作为成员变量或者静态变量实现\n- **Ehcache**：Encache是一个Java开源缓存框架，Hibernate中集成了相关缓存功能。最初是独立的本地缓存组建，后期也可以支持分布式事务集群。Ehcache使用时需要主动将缓存刷到磁盘，可以使用cache.flush()执行\n- **Guava Cache**：Guava Cache是谷歌开源的重用工具库里的一款缓存工具，主要支持缓存的淘汰机制、统计命中率、key和value封装在弱引用中。架构灵感来自于ConcurrentHashMap，使用多个segments方式的细粒度锁\n\n### 分布式缓存\n\n- **memcached缓存**：cache的分布式主要是在客户端实现，通过客户端的路由处理来达到分布式解决方案的目的，客户端在应用程序每次存取键值对时，通过某种算法将键映射到某台memcachd服务器的某个节点上，之后的操作都在这个节点上进行。memcached客户端采用一致性哈希算法，除了计算key的哈希值外，还会计算每个服务器对应的哈希值，然后将这些哈希值映射到一个优先的值域上，通过寻找哈希值大于key的哈希值的最小服务器作为目标服务器\n- **Redis缓存**：redis倾向于服务器端构建分布式存储，redis集群没有中心节点，节点与节点之间通过二进制协议进行通信，将整个key的数值域分为4096个哈希槽，每个节点可以存储一个或多个哈希槽\n\n### CDN\n\n- **CDN（内容分发网络）**：是一种互联的网络系统，利用更靠近用户的服务器从而更快的将HTML等静态资源分发给用户\n\n### 缓存问题\n\n- **缓存穿透**：指对某个一定不存在的数据进行请求，该请求会穿透缓存到达数据库，解决方案有：\n  - 对不存在的数据缓存一个空数据\n  - 对这类请求进行过滤\n- **缓存雪崩**：由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效或者缓存服务器宕机导致请求都到达数据库，解决方法\n  - 通过观察用户行为合理设置缓存过期时间\n  - 采用分布式缓存，每个节点之缓存部分的数据\n  - 进行缓存预热，避免在系统启动不久还未将大量数据缓存而导致缓存雪崩\n- **缓存一致性**：数据更新和缓存数据更新不一致，解决方案\n  - 在数据更新时立即更新缓存\n  - 再度缓存前先判断缓存是否是最新的，如果不是要先进行更新\n\n### 一致性哈希\n\n- **原理**：将哈希空间看成一个哈希环，每个服务器节点配置到哈希环上，每个数据对象通过哈希函数取得哈希值后存放到哈希环上顺时针方向第一个大于等于该哈希值的节点上\n- **虚拟机点**：一致性哈希存在分布不均匀的问题，节点存储的数据量可能有很大的不同，解决方式是增加虚拟节点，然后将虚拟节点映射到真实节点上，虚拟节点的数量比真实节点多，那么虚拟节点在哈希环上分布的均匀性会比原来的真实节点好，从而使数据分布更加均匀', '2019-02-16 11:41:37', '<h3>缓存特征</h3>\n<ul>\n<li><strong>命中率</strong>：返回正确结果数/请求缓存次数，命中率越高表明缓存的使用率越高</li>\n<li><strong>最大空间</strong>：缓存可以存放的最大元素的数量，当缓存中元素超过这个值会触发启动淘汰策略</li>\n<li><strong>淘汰策略</strong>：当缓存空间被占满，使用淘汰策略处理，设计适合自身数据特征的淘汰策略能提高命中率，常见的淘汰策略有：</li>\n<li>FIFO：先进先出策略，先进入缓存的数据会被优先清除</li>\n<li>LFU：最少使用策略，根据元素的被使用次数清除次数较少的元素，策略主要比较元素的命中次数</li>\n<li>LRU：最近最少使用策略，根据元素最后一次被使用的时间戳，清除最远使用时间戳的元素释放空间，主要比较元素最近一次被get使用的事件，在热点数据场景下适用</li>\n</ul>\n<h3>缓存介质</h3>\n<ul>\n<li><strong>内存</strong>：将缓存存储于内存是最快的选择，无需IO开销，缺点是无法持久化到磁盘</li>\n<li><strong>硬盘</strong>：一般来说，很多框架会结合适用内存和硬盘，在内存分配空间满了或者异常情况下，可以主动或被动将内存空间数据持久化到硬盘中</li>\n<li><strong>数据库</strong>：一些NoSQL数据库的响应速度和吞吐量远高于常见的关系型数据库，因此可以将这类数据库作为缓存介质</li>\n</ul>\n<h3>缓存分类和应用场景</h3>\n<ul>\n<li><strong>浏览器</strong>：当HTTP响应允许进行缓存时，浏览器会将HTML、CSS等静态资源进行缓存</li>\n<li><strong>ISP</strong>：网络服务器提供商是网络访问的第一条，通过将数据缓存在ISP中能提高用户的访问速度</li>\n<li><strong>反向代理</strong>：反向代理位于服务器之前，请求和响应都需要经过反向代理</li>\n<li><strong>本地缓存</strong>：指的是在应用中的缓存组件，最大优点是应用和缓存在统一进程，请求缓存速度很快，无需额外的网络开销，在单应用不需要集群支持的场景下适用本地缓存比较合适。缺点是缓存和应用程序耦合，多个应用无法直接共享缓存，各应用节点需要维护自己的单独缓存</li>\n<li><strong>分布式缓存</strong>：指应用分离的缓存组建，最大优点是自身作为一个独立的应用与本地应用隔离，多个应用可以共享内存</li>\n<li><strong>数据库缓存</strong>：M有SQL等数据库管理系统具有自己的查询缓存机制来提高查询效率</li>\n</ul>\n<h3>本地缓存</h3>\n<ul>\n<li><strong>编程实现缓存</strong>：个别情况下，我们只需要简单的缓存数据的功能，而无需关注存取、淘汰策略时，直接编程实现缓存是迅捷和高效的。具体做法是适用hashmap作为成员变量或者静态变量实现</li>\n<li><strong>Ehcache</strong>：Encache是一个Java开源缓存框架，Hibernate中集成了相关缓存功能。最初是独立的本地缓存组建，后期也可以支持分布式事务集群。Ehcache使用时需要主动将缓存刷到磁盘，可以使用cache.flush()执行</li>\n<li><strong>Guava Cache</strong>：Guava Cache是谷歌开源的重用工具库里的一款缓存工具，主要支持缓存的淘汰机制、统计命中率、key和value封装在弱引用中。架构灵感来自于ConcurrentHashMap，使用多个segments方式的细粒度锁</li>\n</ul>\n<h3>分布式缓存</h3>\n<ul>\n<li><strong>memcached缓存</strong>：cache的分布式主要是在客户端实现，通过客户端的路由处理来达到分布式解决方案的目的，客户端在应用程序每次存取键值对时，通过某种算法将键映射到某台memcachd服务器的某个节点上，之后的操作都在这个节点上进行。memcached客户端采用一致性哈希算法，除了计算key的哈希值外，还会计算每个服务器对应的哈希值，然后将这些哈希值映射到一个优先的值域上，通过寻找哈希值大于key的哈希值的最小服务器作为目标服务器</li>\n<li><strong>Redis缓存</strong>：redis倾向于服务器端构建分布式存储，redis集群没有中心节点，节点与节点之间通过二进制协议进行通信，将整个key的数值域分为4096个哈希槽，每个节点可以存储一个或多个哈希槽</li>\n</ul>\n<h3>CDN</h3>\n<ul>\n<li><strong>CDN（内容分发网络）</strong>：是一种互联的网络系统，利用更靠近用户的服务器从而更快的将HTML等静态资源分发给用户</li>\n</ul>\n<h3>缓存问题</h3>\n<ul>\n<li><strong>缓存穿透</strong>：指对某个一定不存在的数据进行请求，该请求会穿透缓存到达数据库，解决方案有：</li>\n<li>对不存在的数据缓存一个空数据</li>\n<li>对这类请求进行过滤</li>\n<li><strong>缓存雪崩</strong>：由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效或者缓存服务器宕机导致请求都到达数据库，解决方法</li>\n<li>通过观察用户行为合理设置缓存过期时间</li>\n<li>采用分布式缓存，每个节点之缓存部分的数据</li>\n<li>进行缓存预热，避免在系统启动不久还未将大量数据缓存而导致缓存雪崩</li>\n<li><strong>缓存一致性</strong>：数据更新和缓存数据更新不一致，解决方案</li>\n<li>在数据更新时立即更新缓存</li>\n<li>再度缓存前先判断缓存是否是最新的，如果不是要先进行更新</li>\n</ul>\n<h3>一致性哈希</h3>\n<ul>\n<li><strong>原理</strong>：将哈希空间看成一个哈希环，每个服务器节点配置到哈希环上，每个数据对象通过哈希函数取得哈希值后存放到哈希环上顺时针方向第一个大于等于该哈希值的节点上</li>\n<li><strong>虚拟机点</strong>：一致性哈希存在分布不均匀的问题，节点存储的数据量可能有很大的不同，解决方式是增加虚拟节点，然后将虚拟节点映射到真实节点上，虚拟节点的数量比真实节点多，那么虚拟节点在哈希环上分布的均匀性会比原来的真实节点好，从而使数据分布更加均匀</li>\n</ul>\n', 2, '缓存特征、应用场景、常见的缓存', 'cache', '缓存', 1, 4, 3);
INSERT INTO blog VALUES (5, 1, '## 一、Git\n\n### 1.1 集中式和分布式\n\n- Git属于分布式版本控制系统，SVN属于集中式\n- 集中式版本控制系统只有中心服务器拥有一份代码，而分布式版本控制每个人的电脑就有一份完整的代码\n- 集中式版本需要联网才能工作，而分布式版本控制不需要联网就能工作\n- 分布式版本控制新建分支、合并分支很快，而集中式版本控制新建分支相当于复制以分完整代码\n\n### 1.2 中心服务器和工作流\n\n- **中心服务器**：用来交换每个用户的修改，没有中心服务器也能工作，Github就是一个中心服务器\n\n- **新建版本库**：git init：将当前文件夹设为一个版本库，用来管理此文件夹下的文件\n\n- **工作流**：新建一个版本库后，当前目录称成为了工作区，工作区下有一个隐藏目录.git，它属于Git的版本库，Git版本库有一个成为stage的暂存区，还有自动创建的master分支以及指向分类的HEAD指针\n\n  - **提交修改**\n\n    - git add [files]：将文件的修改添加到暂存区\n    - git add *：将所有修改全部提交到暂存区\n    - git commit -m [description of commit]：将暂存区的所有修改提交到当前分支，提交后暂存区被清空\n\n  - **查看状态**\n\n    - git status：查看当前暂存区的状态\n    - git diff [files]：查看文件修改的内容\n    - git log：查看提交历史\n    - git relog：查看命令历史\n\n  - **版本回退**\n\n    - git reset --hard [option]：option可以是HEAD^代表上一个版本，或者提交号，代表回到上次提交之后/某一次提交号版本之后\n    - git checkout --[files]：使用版本库中的版本替换工作区的版本，如果文件已经在暂存区，会让之后对它的修改回到刚存入暂存区的状态，如果文件没在暂存区，会让之后的修改回到最开始的状态\n\n    - git checkout HEAD --[files]：将某文件从缓存区取出到工作区\n\n  - **文件删除和版本删除**\n\n    - git rm [files]：如果我们删除了某个文件并且不需要版本管理它们，可以将它们的版本在git仓库删除，然后执行git commit\n    - git checkout -- [files]：如果误删了某个文件，而在版本库里还有它，可以将其在版本库的本并替换到工作区恢复该文件\n\n### 1.3 远程仓库\n\n- git add remote <远程仓库名> <远程仓库地址>：为本地仓库添加远程仓库，一般将远程仓库名命名为origin\n\n- git push <远程仓库名> master：将本地仓库推送到远程仓库，第一次推送时，加上参数-u，这样还会把本地master和远程master关联起来\n- git clone <远程仓库名>：将远程仓库复制到本地\n\n### 1.4分支\n\n- **分支实现**\n  - 使用指针将每一个提交连成一条时间线，HEAD指针指向当前分支\n  - 新建分支是新建一个指针指向时间线的最后一个节点，然后HEAD指针指向新分支\n  - 每次提交会让当前指针向前移动，而其他分支指针不会移动\n  - 合并分支只需改变指针即可\n- **冲突**：两个分支都对同一个文件的同一行进行了修改，在分支合并时会产生冲突\n- **Fast-forward**：快速式合并，会直接将master分支指向合并的分支，这种模式会丢失部分分支信息\n- **分支管理策略**：master分支是分层稳定的，只用来发布新版本，日常开发在分支dev上进行\n- **存储**：在一个分支操作后，如果没有将修改提交到分支上，此时进行分支切换在另一分支上也会看到新的修改，因为所有分支公用一个工作区。可用使用git stash将当前分支的修改存储起来，此时当前工作区的所有修改回村到栈上，此时可以安全的切换到其他分支上\n\n### 1.4 SSH传输设置个.gitignore文件\n\n- **SSH传输**：Git仓库和中心仓库之间的传输通过SSH加密，如果当前工作区下没有.ssh目录，或者该目录下没有id_rsa个id_rsa.pub文件，可以通过命令创建SSH key，然后将SSH key复制到中心仓库中\n- **.gitignore文件**：可以忽略以下文件\n  - 操作系统自动生成的文件，如缩略图\n  - 编译生成的中间文件，如Java编译产生的.class文件\n  - 自己的敏感信息，如存放口令等配置文件', '2019-02-16 11:43:29', '<h2>一、Git</h2>\n<h3>1.1 集中式和分布式</h3>\n<ul>\n<li>Git属于分布式版本控制系统，SVN属于集中式</li>\n<li>集中式版本控制系统只有中心服务器拥有一份代码，而分布式版本控制每个人的电脑就有一份完整的代码</li>\n<li>集中式版本需要联网才能工作，而分布式版本控制不需要联网就能工作</li>\n<li>分布式版本控制新建分支、合并分支很快，而集中式版本控制新建分支相当于复制以分完整代码</li>\n</ul>\n<h3>1.2 中心服务器和工作流</h3>\n<ul>\n<li><p><strong>中心服务器</strong>：用来交换每个用户的修改，没有中心服务器也能工作，Github就是一个中心服务器</p>\n</li>\n<li><p><strong>新建版本库</strong>：git init：将当前文件夹设为一个版本库，用来管理此文件夹下的文件</p>\n</li>\n<li><p><strong>工作流</strong>：新建一个版本库后，当前目录称成为了工作区，工作区下有一个隐藏目录.git，它属于Git的版本库，Git版本库有一个成为stage的暂存区，还有自动创建的master分支以及指向分类的HEAD指针</p>\n</li>\n<li><p><strong>提交修改</strong></p>\n<ul>\n<li>git add [files]：将文件的修改添加到暂存区</li>\n<li>git add *：将所有修改全部提交到暂存区</li>\n<li>git commit -m [description of commit]：将暂存区的所有修改提交到当前分支，提交后暂存区被清空</li>\n</ul>\n</li>\n<li><p><strong>查看状态</strong></p>\n<ul>\n<li>git status：查看当前暂存区的状态</li>\n<li>git diff [files]：查看文件修改的内容</li>\n<li>git log：查看提交历史</li>\n<li>git relog：查看命令历史</li>\n</ul>\n</li>\n<li><p><strong>版本回退</strong></p>\n<ul>\n<li><p>git reset --hard [option]：option可以是HEAD^代表上一个版本，或者提交号，代表回到上次提交之后/某一次提交号版本之后</p>\n</li>\n<li><p>git checkout --[files]：使用版本库中的版本替换工作区的版本，如果文件已经在暂存区，会让之后对它的修改回到刚存入暂存区的状态，如果文件没在暂存区，会让之后的修改回到最开始的状态</p>\n</li>\n<li><p>git checkout HEAD --[files]：将某文件从缓存区取出到工作区</p>\n</li>\n</ul>\n</li>\n<li><p><strong>文件删除和版本删除</strong></p>\n<ul>\n<li>git rm [files]：如果我们删除了某个文件并且不需要版本管理它们，可以将它们的版本在git仓库删除，然后执行git commit</li>\n<li>git checkout -- [files]：如果误删了某个文件，而在版本库里还有它，可以将其在版本库的本并替换到工作区恢复该文件</li>\n</ul>\n</li>\n</ul>\n<h3>1.3 远程仓库</h3>\n<ul>\n<li><p>git add remote <远程仓库名> <远程仓库地址>：为本地仓库添加远程仓库，一般将远程仓库名命名为origin</p>\n</li>\n<li><p>git push <远程仓库名> master：将本地仓库推送到远程仓库，第一次推送时，加上参数-u，这样还会把本地master和远程master关联起来</p>\n</li>\n<li><p>git clone <远程仓库名>：将远程仓库复制到本地</p>\n</li>\n</ul>\n<h3>1.4分支</h3>\n<ul>\n<li><strong>分支实现</strong></li>\n<li>使用指针将每一个提交连成一条时间线，HEAD指针指向当前分支</li>\n<li>新建分支是新建一个指针指向时间线的最后一个节点，然后HEAD指针指向新分支</li>\n<li>每次提交会让当前指针向前移动，而其他分支指针不会移动</li>\n<li>合并分支只需改变指针即可</li>\n<li><strong>冲突</strong>：两个分支都对同一个文件的同一行进行了修改，在分支合并时会产生冲突</li>\n<li><strong>Fast-forward</strong>：快速式合并，会直接将master分支指向合并的分支，这种模式会丢失部分分支信息</li>\n<li><strong>分支管理策略</strong>：master分支是分层稳定的，只用来发布新版本，日常开发在分支dev上进行</li>\n<li><strong>存储</strong>：在一个分支操作后，如果没有将修改提交到分支上，此时进行分支切换在另一分支上也会看到新的修改，因为所有分支公用一个工作区。可用使用git stash将当前分支的修改存储起来，此时当前工作区的所有修改回村到栈上，此时可以安全的切换到其他分支上</li>\n</ul>\n<h3>1.4 SSH传输设置个.gitignore文件</h3>\n<ul>\n<li><strong>SSH传输</strong>：Git仓库和中心仓库之间的传输通过SSH加密，如果当前工作区下没有.ssh目录，或者该目录下没有id<em>rsa个id</em>rsa.pub文件，可以通过命令创建SSH key，然后将SSH key复制到中心仓库中</li>\n<li><strong>.gitignore文件</strong>：可以忽略以下文件</li>\n<li>操作系统自动生成的文件，如缩略图</li>\n<li>编译生成的中间文件，如Java编译产生的.class文件</li>\n<li>自己的敏感信息，如存放口令等配置文件</li>\n</ul>\n', 1, 'Git概念、常见命令', 'git', 'Git', 1, 5, 4);
INSERT INTO blog VALUES (6, 1, '## 二、Docker\n\n### 2.1 解决的问题\n\n- 由于不同机器有不同的操作系统、库和组件，将一个应用部署到多态机器上需要大量的环境配置。Docker主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其他隔离进程。使用Docker可以不修改代码将现有程序部署到其他机器\n\n### 2.2 与虚拟机的比较\n\n- 虚拟机和Docker最大的区别是虚拟机通过模拟硬件，并在硬件上安装操作系统实现\n- 虚拟机启动需要启动虚拟机的操作系统，再启动应用，整个过程缓慢；启动Docker相当于启动一个进程\n- 虚拟机是一个完整的操作系统，占用大量磁盘、内存和CPU；Docker只是一个进程，在运行时占用很少资源\n\n### 2.3 优势\n\n- 更容易迁移：提供一致性的允许环境，可在不同环境机器上进行迁移\n- 更容易维护：使用分层技术和镜像，使得应用可以更容易复用重复部分\n- 更容易扩展：可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像\n\n### 2.4 镜像与容器\n\n- 镜像是一种静态的结构，而容器是镜像的一个实例\n- 镜像包含着容器运行时所需要的代码及组件，它是一种分层结构，每层都是只读的\n- 构建容器时通过在镜像的基础上添加一个可写层，用来保存容器运行过程中的修改', '2019-02-16 11:44:03', '<h2>二、Docker</h2>\n<h3>2.1 解决的问题</h3>\n<ul>\n<li>由于不同机器有不同的操作系统、库和组件，将一个应用部署到多态机器上需要大量的环境配置。Docker主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其他隔离进程。使用Docker可以不修改代码将现有程序部署到其他机器</li>\n</ul>\n<h3>2.2 与虚拟机的比较</h3>\n<ul>\n<li>虚拟机和Docker最大的区别是虚拟机通过模拟硬件，并在硬件上安装操作系统实现</li>\n<li>虚拟机启动需要启动虚拟机的操作系统，再启动应用，整个过程缓慢；启动Docker相当于启动一个进程</li>\n<li>虚拟机是一个完整的操作系统，占用大量磁盘、内存和CPU；Docker只是一个进程，在运行时占用很少资源</li>\n</ul>\n<h3>2.3 优势</h3>\n<ul>\n<li>更容易迁移：提供一致性的允许环境，可在不同环境机器上进行迁移</li>\n<li>更容易维护：使用分层技术和镜像，使得应用可以更容易复用重复部分</li>\n<li>更容易扩展：可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像</li>\n</ul>\n<h3>2.4 镜像与容器</h3>\n<ul>\n<li>镜像是一种静态的结构，而容器是镜像的一个实例</li>\n<li>镜像包含着容器运行时所需要的代码及组件，它是一种分层结构，每层都是只读的</li>\n<li>构建容器时通过在镜像的基础上添加一个可写层，用来保存容器运行过程中的修改</li>\n</ul>\n', 1, 'docker和虚拟机的区别和应用场景', 'docker', 'docker', 1, 5, 4);
INSERT INTO blog VALUES (7, 0, '## 一、大型网站架构演化和模式\n\n### 1.1 大型网站的架构演化\n\n- **初始阶段**：应用程序、数据库、文件等资源布置在一台服务器上。通常服务器采用linux，数据库采用MySQL，应用程序使用PHP开发，最后部署在Apache上\n- **应用服务器和数据服务分离**：应用程序、数据库、文件分别部署在三台服务器\n- **使用缓存改善网站性能**：使用缓存将热点数据缓存在内存中\n- **使用应用服务器集群改善网站并发性能**：\n- **数据库读写分离**：数据库采用主从数据库，写操作写到主数据库，主数据库将数据同步到从数据库，读操作从从数据库读取\n- **使用反向代理或CDN加速网络响应**：基本原理都是基于缓存\n- **使用分布式文件系统和分布式数据库系统**\n- **使用NoSQL和搜索引擎**\n- **业务拆分**\n- **分布式服务**\n\n### 1.2 大型网站的架构模式\n\n- **分层**：上层依赖下层\n- **分割**：讲不通的功能和服务分割\n- **分布式**：将不同模块部署在不同服务器上，通过远程调用协同工作\n- **集群**：对于用户集中访问的模块，需要使用多台服务器部署成集群，通过负载均衡对外提供服务\n- **缓存**：CDN、反向代理、本地缓存、分布式缓存\n- **异步**：在分布式系统中通过分布式消息队列实现异步\n- **冗余**：对服务器进行冗余运行，数据冗余备份，防止服务器宕机而无法工作\n- **自动化**：发布自动化、自动化代码管理、自动化测试、自动化部署等\n- **安全**：加密、验证、过滤、风险控制\n\n### 1.3 大型网站的核心架构要素\n\n- **性能**\n- **可用性**\n- **伸缩性**\n- **扩展性**\n- **安全性**\n\n## 二、性能\n\n### 2.1 性能指标\n\n- **响应时间**\n- **吞吐量**\n- **并发数**\n\n### 2.2 性能优化\n\n#### 2.2.1 Web前端优化\n\n- **浏览器访问优化**\n  - 减少http请求\n  - 使用浏览器缓存\n  - 启用压缩\n  - CSS放在页面最上面，JS放在页面最下方：因为浏览器会在下载完CSS才开始渲染，而JS则相反，因此可能会阻塞整个页面\n  - 减少Cookie传输\n- **CDN加速**：CDN本质上是缓存，是将数据缓存离用户距离最近的地方--运行商机房\n- **反向代理**：位于网站机房一侧，通过配置缓存将用户第一次请求的静态资源换缓存在反向代理服务器上\n\n#### 2.2.2 应用服务器优化\n\n- **分布式缓存**\n  - 缓存的基本原理：一张内存的Hash表\n  - 合理使用缓存\n    -  频繁修改的数据不适合缓存，缓存的数据读写比应在2:1以上\n    -  缓存热点数据\n    -  缓存有失效期，因此应用要容忍一定时间的数据不一致\n    -  缓存可用性：当缓存大量不可用时，大量的请求会直接落到数据库中，数据库完全不能承受压力而宕机，叫作缓存雪崩。使用分布式缓存将缓存分布在集群的多台服务器上可以在一定程度上改善缓存的可用性\n    -  缓存预热：在新的缓存服务器启动时将热点数据加载好\n    -  缓存穿透：由于不恰当的业务或者恶意攻击造成持续高并发的请求某个不存在的数据，叫做缓存穿透，解决的最简单的方法是将不存在的数据也缓存进来\n  -  分布式缓存架构\n    - JBoss Cache：集群中所有服务器中保存相同的缓存数据，当某台服务器有缓存数据更新的时候会通知集群中其他机器更新缓存或者清除缓存数据\n    - Memcached：缓存服务器之间互不通信，应用程序通过一致性Hash等路由算法选择缓存服务器远程访问缓存数据\n  - Memcached\n    - 简单的通信协议：使用TCP协议通信，UDP也支持，序列化协议是基于文本的自定义协议\n    - 高性能的网络通信：基于Libevent，一个支持事件触发的网络通信库\n  - 高效的内存管理：将内存分为slab，每个slab拥有多个相同大小的chunk，存储数据时根据存储数据的大小选择大于数据的最小chunk存储\n  - 互不通信的服务器集群架构\n- **异步操作**：使用消息队列具有很好的削峰作用，将短时间内高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务\n- **使用集群**：在高并发情况下，使用负载均衡技术为一个应用构建由多台服务器组成的服务器集群，并将访问请求分发到多台服务器上处理\n- **代码优化**\n  - 使用多线程\n  - 资源复用：使用单例或对象池\n  - 数据结构：如普通的哈希在有相似字符情况下哈希值相近，可以先对字符串进行MD5加密，然后再进行哈希计算\n  - JVM垃圾回收\n\n#### 2.2.3 存储性能优化\n\n- **固态硬盘**\n- **B+树vsLSM树**：一般NoSQL采用LSM树作为数据结构，LSM树可以看成一棵n阶合并树，数据写操作都会创建一个新纪录，这些数据在内存中仍然是一颗排序树，当数据超过设定的内存阈值后，将这颗排序数和磁盘上最新的排序数合并\n- **RAID VS HDFS**：RAID是一种廉价磁盘冗余阵列。HDFS以数据块管理存储空间，当应用程序写文件时，首先访问NameNode，请求分配数据库，NameNode会根据管理的DataNode的空间按一定负载策略分配空间供应用程序使用，当应用程序使用完毕，HDFS将数据复制到另外两个DataNode上，保证每个块有三个副本\n\n## 三、高可用的架构\n\n### 3.1 高可用的网站架构\n\n- 位于应用层的服务器通过负载均衡将一组服务器组成集群共同对外提供服务，当负载均衡设备通过心跳检测等手段检测到某台服务器不可用时，将其剔除并将请求分发到其他服务器\n- 位于服务层的服务器也通过集群实现高可用，但他们被应用层通过分布式服务调用框架访问，分布式服务调用框架会在应用层客户端程序实现软件的负载均衡，并通过服务注册中心对提供服务的服务器进行心跳检测\n- 位于数据层的服务器需要在数据写入时进行数据同步复制，实现数据备份冗余\n\n### 3.2 高可用的应用\n\n- **通过负载均衡进行无状态的服务失效转移**\n- **Session管理**\n  - Session复制（不适用）：使集群中每台服务器保存所有用户的Session信息\n  - Session绑定（很少使用）：利用Hash算法将来源于同一IP的Session负载在特定的服务器处理，这种方法又叫会话粘滞\n  - 使用Cookie记录Session（很少使用）：浏览器发送Cookie中保存Session，不安全，Cookie大小限制\n  - Session服务器：利用独立部署的Session服务器集群统一管理Session，可用使用MySQL或者Redis、Menmcached这种内存型数据库\n\n### 3.3 高可用的服务\n\n- **分级管理**：将不同的服务按照优先级分级，让核心应用和服务分配更好的硬件和资源\n- **超时设置**：在应用程序中设置服务调用的超时时间，当超过这个时间，通信框架就会抛异常，应用程序可以通过服务调度策略，重试或者将请求转移\n- **异步调用**：应用对服务的调用采用消息队列等异步方式完成\n- **服务降级**：当网站访问高峰期，服务可能因为大量的并发调用而性能下降，需要对服务降级。通过降级拒绝低优先级的应用的调用或者关闭部分不重要的服务\n- **幂等性设计**：由于响应等原因服务可能被重复调用，因此必须保证幂等性，不管服务被调用多少次，返回的结果都应一样，因此对于转账等服务应该调用有效的验证\n\n### 3.4 高可用的数据\n\n- **CAP原理**：一个提供数据服务的存储系统无法同时满足数据的一致性（C：所有应用程序都能访问到相同的数据）、数据可用性（A：在任何时候，任何应用都可以对数据进行读写）、分区耐受性（P：系统行具有跨网络分区的伸缩性）。在大型网站中，数据规模总是不断扩大，因此可伸缩性即耐受性必不可少，规模变大以后需要保证高可用性，因此通常会选择强化分布式存储系统的A和P，在某种程度上放弃一致性C。因此应用程序需要对分布式系统数据的不一致性有所了解并进行某种意义上的纠错\n- **数据一致性**\n  - 强一致性：各个副本在物理存储中总是一致的\n  - 数据用户一致性：数据在物理存储中可能不是一致的，但是终端访问时，通过纠错机制可以确定一个一致且正确的数据给用户\n  - 数据最终一致：物理存储可能不一致，用户访问可能不一致，但是经过一段时间的自我恢复数据最终达到一致\n- **数据备份**：同步热备份在应用程序客户端并发向多个存储服务器同时写入数据，等待所有存储服务器都返回操作成功的响应后再通知应用程序写操作成功\n- **失效转移**\n  - 失效确认：通过心跳检测或应用程序访问失败报告\n  - 访问转移：重新计算路由选择服务器进行读写\n  - 数据恢复：从健康的服务器复制数据\n\n### 3.5 高可用网站软件质量保证\n\n- 网站发布\n- 自动化测试\n- 预发布验证\n- 代码控制\n- 自动化发布\n\n## 四、伸缩性架构\n\n### 4.1 伸缩性架构设计\n\n- **不同功能进行物理分离实现伸缩**\n- **单一功能通过集群规模实现伸缩**\n\n### 4.2 应用服务器集群的伸缩性设计\n\n- **Http重定向负载均衡**：使用Http重定向服务器根据用户的Http请求计算一台真实的Web服务器地址，将地址写入Http重定向响应中返回给浏览器\n- **DNS域名解析负载均衡**：在DNS域名解析的同时使用负载均衡算法计算服务器IP，优点是DNS能根据地理位置进行域名解析，返回离用户最近的服务器IP，缺点是DNS具有多级结构，每一级都会被缓存，当下线一台服务器修改DNS记录时需要很长时间才生效。大型网站基本使用DNS作为第一级负载均衡手段，然后在内部使用其他方式做第二级负载均衡，即DNS解析的结构为内部的负载均衡服务器IP\n- **反向代理负载均衡**：反向代理服务器管理一组服务器，将请求根据负载均衡算法转发到不同服务器上，服务器处理完成后响应也通过反向代理服务器返回给用户，Web服务器不需要使用外部ip，而反向代理服务器则需要配置双网卡和内外部两套Ip地址\n- **IP负载均衡**：在操作系统内核进程获取网络数据包，使用负载均衡计算源服务器IP地址，通过修改数据包请求和响应的目的ip地址，实现请求转发。优点是是性能在内核进程处理，性能高；缺点是和反向代理一样，所有请求会经过负载均衡服务器，会成为性能瓶颈\n- **数据链路层负载均衡**：在通信协议的数据链路层修改目的mac地址进行负载均衡。通过配置原服务器的虚拟IP和负载均衡服务器的IP地址一致，从而不需要修改IP地址就可以进行转发，由于IP地址一样，所有原服务器的响应不需要转发回负载均衡服务器，可以直接转发给客户端，避免负载均衡服务器的性能瓶颈。这是一种三角传输方式，也是目前大型网站使用最广的负载均衡转发方式，在Linux上可用使用的负载均衡服务器为LVS\n- **负载均衡算法**\n  - 轮询：所有请求依次发到每台服务器上\n  - 加权轮询：在轮询的基础上按照配置的权重将请求转发到服务器\n  - 随机：请求被随机分配到服务器\n  - 最少连接：记录每个服务器的连接数，将新到的请求分发到最少连接的服务器上\n  - 源地址散列：根据请求的ip进行Hash计算，得到应用服务器，这样来自同一个IP地址的请求总会到达同一台服务器，从而实现会话粘滞\n\n### 4.3 分布式缓存集群的伸缩性设计\n\n- **Memcached分布式缓存集群访问模型**：应用程序通过Memcached客户端访问Memcached服务器集群，客户端通过路由算法根据输入的缓存数据KEY计算得到将数据写入哪台服务器或从哪台服务器读数据\n- **分布式缓存的一致性Hash算法**\n  - 具体流程：先构造一个长度为0-2^32长度的哈希环，根据节点名称的Hash值将缓存服务器节点放置在Hash环上，然后根据需要缓存的数据的KEY计算得到Hash值，然后在Hash环上顺时针查找距离这个Hash值最近的缓存服务器节点，完成KEY到服务器的映射。具体应用中，这个Hash环通过二叉查找树实现，Hash查找过程实际上是查找不小于查找数的最小数值，且二叉树的最右边叶子节点和最左边叶子节点相连接构成环\n  - 增加虚拟节点：上述流程新加入的节点虽然只影响环中的一小段，但是其他节点的负载压力会变大，解决方法是将每台物理服务器虚拟成一组虚拟服务器，将虚拟服务器的Hash值放置在Hash环上，KEY在环上先找到虚拟节点再得到物理服务器节点，当新加入节点时会均匀影响原来环上存在的集群的所有节点。一台物理服务器的虚拟节点数按经验值是150\n\n### 4.4 数据存储服务器集群的伸缩性设计\n\n- **关系数据库集群的伸缩性设计**：数据库主从复制、数据分库、大表进行分片，将一张表拆开分别存储在多个数据库中。目前比较成熟的支持分片的工具是Cobar，Coabr位于应用服务器和数据库连接之间，应用程序通过JDBC访问Cobar集群，Cobar根据SQL和分库规则分解SQL，分发到MySQL集群的不同数据库上执行。Cobar实现伸缩性主要是利用MySQL的数据同步进行数据迁移，数据迁移的不是以数据为单位，而是以Schema为单位\n- **NoSQL的伸缩性设计**：HBase通过HRegion为单位管理，当HRegion大小超过阈值，会分裂成两个并在急群众迁移\n\n## 五、可扩展性架构\n\n### 5.1 利用分布式消息队列降低耦合性\n\n- **事件驱动架构（EDA）**：通过在低耦合的模块之间传输事件消息，以保持模板的松散耦合\n- **分布式消息队列**\n  1. **消息模型**\n     - 点对点：消息生产者向消息队列发送一个消息后只能被消费者消费依次\n     - 发布/订阅：消息生产者向频道发送一个消息之后，多个消费者可用从该频道订阅到这条消息并消费。发布订阅模式和观察者模式不同，观察者模式中，观察者和是主题都知道对象的存在，而在发布订阅模式中，它们不知道对方的存在；观察者模式是同步的，当事件触发时，主题调用观察者的方法然后等待返回，发布订阅是异步的，发布者发送消息后可用立即返回\n  2. **使用场景**\n     - **异步处理**：发送者将消息发送给消息队列后不需要同步等待消息接收者处理完毕，而是立即返回\n     - **流量消峰**：在高并发场景下，将请求发送到消息队列中，服务器按照处理能力从消息队列中订阅消息进行处理\n     - **应用解耦**\n  3. **可靠性**\n     - **发送端的可靠性**：发送端完成后一定能将消息成功发送到消息队列\n       - 实现方法：在本地数据库建一张数据表，将消息数据和业务数据保存在同一数据库实例中，利用本地数据库的事务机制。当事务提交成功后，将消息表中的消息转移到消息队列中，消息转移成功删除消息表中数据，失败则继续重传\n     - **接收端的可靠性**：接收端能从消息队列成功消费依次消息，两种实现方法\n       - 保证接收端处理消息的业务逻辑具有幂等性：消费多少次消息，最后处理结果一样\n       - 保证消息具有唯一编号，并使用一张日志表记录已消费的消息编号\n\n### 5.2 利用分布式服务打造可复用平台\n\n- **纵向拆分**：将大应用拆分为小应用\n- **横向拆分**：将复用应用拆分独立为分布式服务\n- **Web Service**：服务提供者通过WSDL(Web服务描述语言)向注册中心描述自身提供的服务接口属性，注册中心使用UDDI（统一描述、发现和集成）发布服务提供者提供的服务，服务请求者从注册中心检索到服务后通过SOAP（简单对象访问协议）和服务提供者通信，使用相关服务\n\n## 六、网站的安全架构\n\n### 6.1 网站的攻击与防御\n\n#### 6.1.1 XSS攻击\n\n- **XSS攻击**：即跨站点脚本攻击，指黑客通过篡改网页，恶意注入HTML脚本，在用户浏览网页时控制用户浏览器进行恶意操作的一种攻击方式。分为两种：一种是反射型，攻击者诱使用户点击一个嵌入恶意脚本的链接达到攻击的目的；另一种是持久性XSS攻击，黑客提交含有恶意脚本的请求，保存在被攻击站点的数据库中，用户浏览网页时，恶意脚本包含在正常页面中达到攻击目的\n- **防御手段**\n  - 消毒：对某些HTML危险字符转义，如‘>’\n  - HttpOnly：浏览器禁止页面JS访问带有HttpOnly的Cookie，可用防止攻击者窃取Cookie\n\n#### 6.1.2 注入攻击\n\n- **注入攻击**：分为SQL注入和OS注入攻击\n- **防御手段**\n  - 消毒：通过正则匹配过滤掉请求中可能注入的SQL语句，如“drop table”\n  - 参数绑定：攻击者的注入SQL会被当成参数，而不是SQL命令被执行\n\n#### 6.1.3 CSRF攻击\n\n- **CSRF**：跨站点请求伪造，利用浏览器Cookie或者服务器Session策略盗取用户身份进行非法操作\n- **防御手段**\n  - 表单token\n  - 验证码\n  - Referer check：HTTP请求的Referer记录着请求来源，可通过检查来源验证是否合法\n\n#### 6.1.4 其他攻击和漏洞\n\n- **Error Code**：通过制造非法输入，得到异常信息，从而寻找漏洞进行攻击。防御方法是跳转500页面到专门的错误页面\n- **HTML注释**：若将代码使用HTML注释语法进行注释显示在页面会给黑客造成攻击便利\n- **文件上传**：如果上传的是可执行程序会通过上传获得服务器的执行能力。防御方法是设置上传白名单，只允许上传可靠的文件\n- **拒绝服务攻击（DoS）**：目的使电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其他用户无法访问\n\n#### 6.1.5 Web应用防火墙\n\n- **ModSecurity**：开源的Wen应用防火墙，采用处理逻辑和攻击规则集合分离的架构模式，处理逻辑负责请求和响应的拦截过滤，攻击规则集合负责对具体攻击定义、识别、防御策略等功能，攻击规则集合需要不断针对漏洞进行升级\n- **网站安全漏洞扫描**：根据内置规则，模拟攻击行为发现网站安全漏洞\n\n### 6.2 加密技术及密钥安全管理\n\n- **单向散列加密**：通过对不同输入长度的信息进行散列计算得到固定长度的输出，这个计算过程是单向的，不能对固定长度的输出进行计算从而获得输入信息，常见的如MD5、SHA。为了加强散列计算的安全性，还会给散列计算加salt值\n- **对称加密**：加密解密使用同一个密钥，常见的有RC算法、DES算法\n- **分对称加密**：加密解密的密钥不是同意密钥，用公钥加密的私钥才能解开，私钥加密公钥才能解开，常见的有RSA算法。HTTPS中浏览器使用的数字证书实质上是经过权威认证的非对称加密公钥\n\n### 6.3 信息过滤与反垃圾\n\n- **文本匹配**：网站维护一份敏感词表，如果用户发表的信息有敏感词进行消毒处理（将敏感词转为***）或拒绝发表。如果信息很短可用使用正则表达式，如果信息很长，一般算法是基于Trie树算法\n- **分类算法**：使用贝叶斯分类算法\n- **黑名单**：一般场景下通过Hash表，在对过滤需求不精确的情况下可以使用布隆过滤器。布隆过滤器使用一个二进制数组和一组随机数映射函数实现，当要加入黑名单时，将用户名使用随机映射函数得到若干随机数，然后将二进制数组对应随机数下标设为1，当要检查是否在黑名单时，使用同样的映射函数得到随机数，检查二进制数组随机数下标是否为1\n\n## 七、分布式系统架构\n\n### 7.1 分布式锁的实现\n\n- **分布式锁**：在单机场景下，可以使用语言的内置锁来实现进程同步，但是在分布式场景下，需要同步的进程可能位于不同的节点，就需要使用分布式锁。阻塞锁通常使用互斥量来实现：互斥量为0表示有其他进程正在使用锁，此时处于锁定状态；互斥量为1表示未锁定状态\n- **数据库的唯一索引**：获得锁时向表中插入一条记录，释放锁时删除这条记录，唯一索引可以保证该记录只被插入依次，那么就可以用这个记录是否存在来判断是否处于锁定状态。存在以下问题：\n  - 锁没有失效时间，解锁失败的话其他进程无法再获得锁\n  - 只能是非阻塞锁，插入失败直接报错，无法重试\n  - 不可重入，已经获得锁的进程也必须重新获取锁\n- **Redis的SETNX指令**：使用SETNX指令插入一个键值对，若key已存在会返回false，否则插入成功返回true。SETNX指令和数据库的唯一索引类似，保证只存在一个Key的键值对，可以通过用一个Key的键值对是否存在来判断是否处于锁定状态。EXPIRE指令可以为一个键值对设置过期时间从而避免数据库唯一索引实现方式中释放锁失败的问题\n- **Redis的RedLcok算法**：使用多个实例来实现分布式锁，这是为了保证在发生单点故障时依然可用\n  - 尝试从N个相互独立的Redis实例获取锁\n  - 计算获取锁消耗的时间，只有当这个时间小于锁的过期时间，并且从大多数(N/2+1)实例上获取了锁，就认为锁获取成功了\n  - 如果锁获取失败，就到每个实例上获取锁\n- **Zookeeper的有序节点**\n  - **Zookeeper的抽象模型**：Zookeepeer提供了一种属性结构级的命名空间，/app1/p_1节点的父节点为/app1\n  - **节点类型**\n    - 永久节点：不会因为会话结束或超时而消失\n    - 临时节点：如果会话结束就消失\n    - 有序节点：会在节点名后面加数字后缀，并且是有序的，例如生成的有序节点为/lock/node-000000，它的下一个有序节点为/lcok/node-000001\n  - **监听器**：为一个节点注册监听器，在节点状态发生改变时会向客户端发送消息\n  - **分布式锁实现**\n    - 创建一个锁目录/lock\n    - 当一个客户端需要获取锁时，在/lock下创建临时的有序子节点\n    - 客户端获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直到获取锁\n    - 执行业务代码，完成后，删除对应的子节点\n  - **会话超时**：如果一个已经获得锁的会话超时了，因为创建的是一个临时节点，所有该临时节点会被删除，其他会话节点就可以获得锁了，因此不会出现数据库的唯一索引实现的分布式锁的释放锁失败问题\n  - **羊群效应**：一个节点未获得锁，只需要监听自己的前一个节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其他所有子节点都会受到通知，而我们只希望它的后一个子节点收到通知\n\n### 7.2 分布式事务\n\n- **本地消息表**：本地消息表和业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性\n  - 在分布式事务操作的以访完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定被写入本地消息表中\n  - 之后将本地消息表中的消息转发到Kafka等消息队列中，如果转发成功则将消息从本地消息列表中删除，否则继续重新转发\n  - 在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作\n- **2PC（两阶段提交）**：引入协调者来协调参与者的行为，并最终决定这些参与者是否要真正执行事务\n  1. **运行过程**\n     - 准备阶段：协调者询问参与者事务是否执行成功，参与者发回事务执行结果\n     - 提交阶段：如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务\n  2. **存在的问题**\n     - 同步阻塞：所有事物参与者在等待其他参与者响应的时候都处于同步阻塞状态，无法进行其他操作\n     - 单点问题：协调者在2PC中起到非常大的作用，发生故障会造成很大影响，特别是阶段二发生故障，所有参与者会一直等待\n     - 数据不一致：在阶段二，如果协调者只发送了部分commit消息，此时网络发生异常，那么只要部分参与者收到commit消息，也就是说只有部分参与者提交了事物，使系统数据不一致\n     - 太过保守：任意一个节点失败会导致整个事物失败，没有完善的容错机制\n\n### 7.3 BASE\n\n- **BASE**：是基本可用（BA）、软状态（S）、最终一致性（E）的缩写，BASE理论是对CAP中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但是每个应用可用根据自身的业务特点采用释放的方法来使系统达到最终一致性\n- **基本可用**：指分布式系统出现的故障时，保证核心可用，允许损失部分可用性\n- **软状态**：指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延\n- **最终一致性**：强调系统中的所有数据副本，在经过一段时间后，最终达到一致的状态。ACID强调强一致性，通常用在传统的关系数据库系统上，而BASE要求最终一致性来达到可用性，通常用在大型分布式系统。在实际的分布式场景中，不同的业务单元和组件对一致性的要求是不同的，因此ACID和BASE常常配合在一起使用\n\n### 7.4 Paxos\n\n- **Paxos**：用于达成共识性问题，即多个节点产生的值，该算法能保证只选出唯一一个值，主要有三类节点：\n  - 提议者：提议一个值\n  - 接受者：对每个提议进行投票\n  - 告知者：被告知投票的结果，不参与投票\n- **执行过程**：规定一个提议包含两个字段：[n,v]，n为具有唯一性的序号，v为提议值\n  1. Prepare阶段：提议者向接受者发送提议[n1,v1]，如果接受着是首次收到提议，则发送一个Prepare响应，设置当前接收到的提议[n1,v1]。若不是首次收到提议，则比较当前收到的提议的n1与收到的提议n2比较，如果n2大于n1，则发送[n2,v2]的Prepare响应并将当前收到的提议改为[n2,v2]，否则抛弃该提议请求\n  2. Accpet阶段：当提议者收到一半以上的接受者的Prepare响应时，就可以发送Accpet请求\n  3. Learn阶段：接受者收到Accept请求时，如果序号大于等于该接受者承诺的最小序号，就发送Learn提议给所有的告知者，当告知者发现有大多数的接受者接受了某个提议，那么该提议的提议值就被Paxos选择出来\n- **约束条件**\n  - **正确性**：只有一个提议值会生效\n  - **可终止性**：指最后总有一个提议生效\n\n### 7.5 Raft\n\n- **Raft**：也是分布式一致协议，主要用来竞选主节点\n- **单个Candidate的竞选**：有三种节点：Follower、Candidate和Leader。Leader会周期性的发送心跳包给Follower，每个Follower都设置一个随机的竞选超时时间，一般为150ms-300ms，如果这个时候没有收到Leader的心跳包，就会变成Candidate，进入竞选状态。单个候选者节点竞选时，会发送投票信息给所有其他节点，如果收到超过一半节点的回复，该候选节点就变为Leader，之后Leader会周期性发送心跳包给Folower，Follower收到心跳包会重新计时\n- **多个Candidate竞选**：如果有多个Follower称为Cadidate，并且获得票数相同，就需要重新投票，由于每个节点设置的随机竞选超时时间不同，因此下一次再次出现多个Cadidate并获取同样票数的概率很低\n- **数据同步**：来自客户端的修改会被传入Leader，Leader将修改复制给所有Follower并等待大多数Follower进行了修改之后将修改提交，然后通知所有Follower让它们也提交，此时所有节点的值达成一致', '2019-02-16 11:47:56', '<h2>一、大型网站架构演化和模式</h2>\n<h3>1.1 大型网站的架构演化</h3>\n<ul>\n<li><strong>初始阶段</strong>：应用程序、数据库、文件等资源布置在一台服务器上。通常服务器采用linux，数据库采用MySQL，应用程序使用PHP开发，最后部署在Apache上</li>\n<li><strong>应用服务器和数据服务分离</strong>：应用程序、数据库、文件分别部署在三台服务器</li>\n<li><strong>使用缓存改善网站性能</strong>：使用缓存将热点数据缓存在内存中</li>\n<li><strong>使用应用服务器集群改善网站并发性能</strong>：</li>\n<li><strong>数据库读写分离</strong>：数据库采用主从数据库，写操作写到主数据库，主数据库将数据同步到从数据库，读操作从从数据库读取</li>\n<li><strong>使用反向代理或CDN加速网络响应</strong>：基本原理都是基于缓存</li>\n<li><strong>使用分布式文件系统和分布式数据库系统</strong></li>\n<li><strong>使用NoSQL和搜索引擎</strong></li>\n<li><strong>业务拆分</strong></li>\n<li><strong>分布式服务</strong></li>\n</ul>\n<h3>1.2 大型网站的架构模式</h3>\n<ul>\n<li><strong>分层</strong>：上层依赖下层</li>\n<li><strong>分割</strong>：讲不通的功能和服务分割</li>\n<li><strong>分布式</strong>：将不同模块部署在不同服务器上，通过远程调用协同工作</li>\n<li><strong>集群</strong>：对于用户集中访问的模块，需要使用多台服务器部署成集群，通过负载均衡对外提供服务</li>\n<li><strong>缓存</strong>：CDN、反向代理、本地缓存、分布式缓存</li>\n<li><strong>异步</strong>：在分布式系统中通过分布式消息队列实现异步</li>\n<li><strong>冗余</strong>：对服务器进行冗余运行，数据冗余备份，防止服务器宕机而无法工作</li>\n<li><strong>自动化</strong>：发布自动化、自动化代码管理、自动化测试、自动化部署等</li>\n<li><strong>安全</strong>：加密、验证、过滤、风险控制</li>\n</ul>\n<h3>1.3 大型网站的核心架构要素</h3>\n<ul>\n<li><strong>性能</strong></li>\n<li><strong>可用性</strong></li>\n<li><strong>伸缩性</strong></li>\n<li><strong>扩展性</strong></li>\n<li><strong>安全性</strong></li>\n</ul>\n<h2>二、性能</h2>\n<h3>2.1 性能指标</h3>\n<ul>\n<li><strong>响应时间</strong></li>\n<li><strong>吞吐量</strong></li>\n<li><strong>并发数</strong></li>\n</ul>\n<h3>2.2 性能优化</h3>\n<h4>2.2.1 Web前端优化</h4>\n<ul>\n<li><strong>浏览器访问优化</strong></li>\n<li>减少http请求</li>\n<li>使用浏览器缓存</li>\n<li>启用压缩</li>\n<li>CSS放在页面最上面，JS放在页面最下方：因为浏览器会在下载完CSS才开始渲染，而JS则相反，因此可能会阻塞整个页面</li>\n<li>减少Cookie传输</li>\n<li><strong>CDN加速</strong>：CDN本质上是缓存，是将数据缓存离用户距离最近的地方--运行商机房</li>\n<li><strong>反向代理</strong>：位于网站机房一侧，通过配置缓存将用户第一次请求的静态资源换缓存在反向代理服务器上</li>\n</ul>\n<h4>2.2.2 应用服务器优化</h4>\n<ul>\n<li><strong>分布式缓存</strong></li>\n<li>缓存的基本原理：一张内存的Hash表</li>\n<li>合理使用缓存<ul>\n<li>频繁修改的数据不适合缓存，缓存的数据读写比应在2:1以上</li>\n<li>缓存热点数据</li>\n<li>缓存有失效期，因此应用要容忍一定时间的数据不一致</li>\n<li>缓存可用性：当缓存大量不可用时，大量的请求会直接落到数据库中，数据库完全不能承受压力而宕机，叫作缓存雪崩。使用分布式缓存将缓存分布在集群的多台服务器上可以在一定程度上改善缓存的可用性</li>\n<li>缓存预热：在新的缓存服务器启动时将热点数据加载好</li>\n<li>缓存穿透：由于不恰当的业务或者恶意攻击造成持续高并发的请求某个不存在的数据，叫做缓存穿透，解决的最简单的方法是将不存在的数据也缓存进来</li>\n</ul>\n</li>\n<li>分布式缓存架构<ul>\n<li>JBoss Cache：集群中所有服务器中保存相同的缓存数据，当某台服务器有缓存数据更新的时候会通知集群中其他机器更新缓存或者清除缓存数据</li>\n<li>Memcached：缓存服务器之间互不通信，应用程序通过一致性Hash等路由算法选择缓存服务器远程访问缓存数据</li>\n</ul>\n</li>\n<li>Memcached<ul>\n<li>简单的通信协议：使用TCP协议通信，UDP也支持，序列化协议是基于文本的自定义协议</li>\n<li>高性能的网络通信：基于Libevent，一个支持事件触发的网络通信库</li>\n</ul>\n</li>\n<li>高效的内存管理：将内存分为slab，每个slab拥有多个相同大小的chunk，存储数据时根据存储数据的大小选择大于数据的最小chunk存储</li>\n<li>互不通信的服务器集群架构</li>\n<li><strong>异步操作</strong>：使用消息队列具有很好的削峰作用，将短时间内高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务</li>\n<li><strong>使用集群</strong>：在高并发情况下，使用负载均衡技术为一个应用构建由多台服务器组成的服务器集群，并将访问请求分发到多台服务器上处理</li>\n<li><strong>代码优化</strong></li>\n<li>使用多线程</li>\n<li>资源复用：使用单例或对象池</li>\n<li>数据结构：如普通的哈希在有相似字符情况下哈希值相近，可以先对字符串进行MD5加密，然后再进行哈希计算</li>\n<li>JVM垃圾回收</li>\n</ul>\n<h4>2.2.3 存储性能优化</h4>\n<ul>\n<li><strong>固态硬盘</strong></li>\n<li><strong>B+树vsLSM树</strong>：一般NoSQL采用LSM树作为数据结构，LSM树可以看成一棵n阶合并树，数据写操作都会创建一个新纪录，这些数据在内存中仍然是一颗排序树，当数据超过设定的内存阈值后，将这颗排序数和磁盘上最新的排序数合并</li>\n<li><strong>RAID VS HDFS</strong>：RAID是一种廉价磁盘冗余阵列。HDFS以数据块管理存储空间，当应用程序写文件时，首先访问NameNode，请求分配数据库，NameNode会根据管理的DataNode的空间按一定负载策略分配空间供应用程序使用，当应用程序使用完毕，HDFS将数据复制到另外两个DataNode上，保证每个块有三个副本</li>\n</ul>\n<h2>三、高可用的架构</h2>\n<h3>3.1 高可用的网站架构</h3>\n<ul>\n<li>位于应用层的服务器通过负载均衡将一组服务器组成集群共同对外提供服务，当负载均衡设备通过心跳检测等手段检测到某台服务器不可用时，将其剔除并将请求分发到其他服务器</li>\n<li>位于服务层的服务器也通过集群实现高可用，但他们被应用层通过分布式服务调用框架访问，分布式服务调用框架会在应用层客户端程序实现软件的负载均衡，并通过服务注册中心对提供服务的服务器进行心跳检测</li>\n<li>位于数据层的服务器需要在数据写入时进行数据同步复制，实现数据备份冗余</li>\n</ul>\n<h3>3.2 高可用的应用</h3>\n<ul>\n<li><strong>通过负载均衡进行无状态的服务失效转移</strong></li>\n<li><strong>Session管理</strong></li>\n<li>Session复制（不适用）：使集群中每台服务器保存所有用户的Session信息</li>\n<li>Session绑定（很少使用）：利用Hash算法将来源于同一IP的Session负载在特定的服务器处理，这种方法又叫会话粘滞</li>\n<li>使用Cookie记录Session（很少使用）：浏览器发送Cookie中保存Session，不安全，Cookie大小限制</li>\n<li>Session服务器：利用独立部署的Session服务器集群统一管理Session，可用使用MySQL或者Redis、Menmcached这种内存型数据库</li>\n</ul>\n<h3>3.3 高可用的服务</h3>\n<ul>\n<li><strong>分级管理</strong>：将不同的服务按照优先级分级，让核心应用和服务分配更好的硬件和资源</li>\n<li><strong>超时设置</strong>：在应用程序中设置服务调用的超时时间，当超过这个时间，通信框架就会抛异常，应用程序可以通过服务调度策略，重试或者将请求转移</li>\n<li><strong>异步调用</strong>：应用对服务的调用采用消息队列等异步方式完成</li>\n<li><strong>服务降级</strong>：当网站访问高峰期，服务可能因为大量的并发调用而性能下降，需要对服务降级。通过降级拒绝低优先级的应用的调用或者关闭部分不重要的服务</li>\n<li><strong>幂等性设计</strong>：由于响应等原因服务可能被重复调用，因此必须保证幂等性，不管服务被调用多少次，返回的结果都应一样，因此对于转账等服务应该调用有效的验证</li>\n</ul>\n<h3>3.4 高可用的数据</h3>\n<ul>\n<li><strong>CAP原理</strong>：一个提供数据服务的存储系统无法同时满足数据的一致性（C：所有应用程序都能访问到相同的数据）、数据可用性（A：在任何时候，任何应用都可以对数据进行读写）、分区耐受性（P：系统行具有跨网络分区的伸缩性）。在大型网站中，数据规模总是不断扩大，因此可伸缩性即耐受性必不可少，规模变大以后需要保证高可用性，因此通常会选择强化分布式存储系统的A和P，在某种程度上放弃一致性C。因此应用程序需要对分布式系统数据的不一致性有所了解并进行某种意义上的纠错</li>\n<li><strong>数据一致性</strong></li>\n<li>强一致性：各个副本在物理存储中总是一致的</li>\n<li>数据用户一致性：数据在物理存储中可能不是一致的，但是终端访问时，通过纠错机制可以确定一个一致且正确的数据给用户</li>\n<li>数据最终一致：物理存储可能不一致，用户访问可能不一致，但是经过一段时间的自我恢复数据最终达到一致</li>\n<li><strong>数据备份</strong>：同步热备份在应用程序客户端并发向多个存储服务器同时写入数据，等待所有存储服务器都返回操作成功的响应后再通知应用程序写操作成功</li>\n<li><strong>失效转移</strong></li>\n<li>失效确认：通过心跳检测或应用程序访问失败报告</li>\n<li>访问转移：重新计算路由选择服务器进行读写</li>\n<li>数据恢复：从健康的服务器复制数据</li>\n</ul>\n<h3>3.5 高可用网站软件质量保证</h3>\n<ul>\n<li>网站发布</li>\n<li>自动化测试</li>\n<li>预发布验证</li>\n<li>代码控制</li>\n<li>自动化发布</li>\n</ul>\n<h2>四、伸缩性架构</h2>\n<h3>4.1 伸缩性架构设计</h3>\n<ul>\n<li><strong>不同功能进行物理分离实现伸缩</strong></li>\n<li><strong>单一功能通过集群规模实现伸缩</strong></li>\n</ul>\n<h3>4.2 应用服务器集群的伸缩性设计</h3>\n<ul>\n<li><strong>Http重定向负载均衡</strong>：使用Http重定向服务器根据用户的Http请求计算一台真实的Web服务器地址，将地址写入Http重定向响应中返回给浏览器</li>\n<li><strong>DNS域名解析负载均衡</strong>：在DNS域名解析的同时使用负载均衡算法计算服务器IP，优点是DNS能根据地理位置进行域名解析，返回离用户最近的服务器IP，缺点是DNS具有多级结构，每一级都会被缓存，当下线一台服务器修改DNS记录时需要很长时间才生效。大型网站基本使用DNS作为第一级负载均衡手段，然后在内部使用其他方式做第二级负载均衡，即DNS解析的结构为内部的负载均衡服务器IP</li>\n<li><strong>反向代理负载均衡</strong>：反向代理服务器管理一组服务器，将请求根据负载均衡算法转发到不同服务器上，服务器处理完成后响应也通过反向代理服务器返回给用户，Web服务器不需要使用外部ip，而反向代理服务器则需要配置双网卡和内外部两套Ip地址</li>\n<li><strong>IP负载均衡</strong>：在操作系统内核进程获取网络数据包，使用负载均衡计算源服务器IP地址，通过修改数据包请求和响应的目的ip地址，实现请求转发。优点是是性能在内核进程处理，性能高；缺点是和反向代理一样，所有请求会经过负载均衡服务器，会成为性能瓶颈</li>\n<li><strong>数据链路层负载均衡</strong>：在通信协议的数据链路层修改目的mac地址进行负载均衡。通过配置原服务器的虚拟IP和负载均衡服务器的IP地址一致，从而不需要修改IP地址就可以进行转发，由于IP地址一样，所有原服务器的响应不需要转发回负载均衡服务器，可以直接转发给客户端，避免负载均衡服务器的性能瓶颈。这是一种三角传输方式，也是目前大型网站使用最广的负载均衡转发方式，在Linux上可用使用的负载均衡服务器为LVS</li>\n<li><strong>负载均衡算法</strong></li>\n<li>轮询：所有请求依次发到每台服务器上</li>\n<li>加权轮询：在轮询的基础上按照配置的权重将请求转发到服务器</li>\n<li>随机：请求被随机分配到服务器</li>\n<li>最少连接：记录每个服务器的连接数，将新到的请求分发到最少连接的服务器上</li>\n<li>源地址散列：根据请求的ip进行Hash计算，得到应用服务器，这样来自同一个IP地址的请求总会到达同一台服务器，从而实现会话粘滞</li>\n</ul>\n<h3>4.3 分布式缓存集群的伸缩性设计</h3>\n<ul>\n<li><strong>Memcached分布式缓存集群访问模型</strong>：应用程序通过Memcached客户端访问Memcached服务器集群，客户端通过路由算法根据输入的缓存数据KEY计算得到将数据写入哪台服务器或从哪台服务器读数据</li>\n<li><strong>分布式缓存的一致性Hash算法</strong></li>\n<li>具体流程：先构造一个长度为0-2^32长度的哈希环，根据节点名称的Hash值将缓存服务器节点放置在Hash环上，然后根据需要缓存的数据的KEY计算得到Hash值，然后在Hash环上顺时针查找距离这个Hash值最近的缓存服务器节点，完成KEY到服务器的映射。具体应用中，这个Hash环通过二叉查找树实现，Hash查找过程实际上是查找不小于查找数的最小数值，且二叉树的最右边叶子节点和最左边叶子节点相连接构成环</li>\n<li>增加虚拟节点：上述流程新加入的节点虽然只影响环中的一小段，但是其他节点的负载压力会变大，解决方法是将每台物理服务器虚拟成一组虚拟服务器，将虚拟服务器的Hash值放置在Hash环上，KEY在环上先找到虚拟节点再得到物理服务器节点，当新加入节点时会均匀影响原来环上存在的集群的所有节点。一台物理服务器的虚拟节点数按经验值是150</li>\n</ul>\n<h3>4.4 数据存储服务器集群的伸缩性设计</h3>\n<ul>\n<li><strong>关系数据库集群的伸缩性设计</strong>：数据库主从复制、数据分库、大表进行分片，将一张表拆开分别存储在多个数据库中。目前比较成熟的支持分片的工具是Cobar，Coabr位于应用服务器和数据库连接之间，应用程序通过JDBC访问Cobar集群，Cobar根据SQL和分库规则分解SQL，分发到MySQL集群的不同数据库上执行。Cobar实现伸缩性主要是利用MySQL的数据同步进行数据迁移，数据迁移的不是以数据为单位，而是以Schema为单位</li>\n<li><strong>NoSQL的伸缩性设计</strong>：HBase通过HRegion为单位管理，当HRegion大小超过阈值，会分裂成两个并在急群众迁移</li>\n</ul>\n<h2>五、可扩展性架构</h2>\n<h3>5.1 利用分布式消息队列降低耦合性</h3>\n<ul>\n<li><strong>事件驱动架构（EDA）</strong>：通过在低耦合的模块之间传输事件消息，以保持模板的松散耦合</li>\n<li><strong>分布式消息队列</strong></li>\n<li><strong>消息模型</strong><ul>\n<li>点对点：消息生产者向消息队列发送一个消息后只能被消费者消费依次</li>\n<li>发布/订阅：消息生产者向频道发送一个消息之后，多个消费者可用从该频道订阅到这条消息并消费。发布订阅模式和观察者模式不同，观察者模式中，观察者和是主题都知道对象的存在，而在发布订阅模式中，它们不知道对方的存在；观察者模式是同步的，当事件触发时，主题调用观察者的方法然后等待返回，发布订阅是异步的，发布者发送消息后可用立即返回</li>\n</ul>\n</li>\n<li><strong>使用场景</strong><ul>\n<li><strong>异步处理</strong>：发送者将消息发送给消息队列后不需要同步等待消息接收者处理完毕，而是立即返回</li>\n<li><strong>流量消峰</strong>：在高并发场景下，将请求发送到消息队列中，服务器按照处理能力从消息队列中订阅消息进行处理</li>\n<li><strong>应用解耦</strong></li>\n</ul>\n</li>\n<li><strong>可靠性</strong><ul>\n<li><strong>发送端的可靠性</strong>：发送端完成后一定能将消息成功发送到消息队列</li>\n<li>实现方法：在本地数据库建一张数据表，将消息数据和业务数据保存在同一数据库实例中，利用本地数据库的事务机制。当事务提交成功后，将消息表中的消息转移到消息队列中，消息转移成功删除消息表中数据，失败则继续重传</li>\n<li><strong>接收端的可靠性</strong>：接收端能从消息队列成功消费依次消息，两种实现方法</li>\n<li>保证接收端处理消息的业务逻辑具有幂等性：消费多少次消息，最后处理结果一样</li>\n<li>保证消息具有唯一编号，并使用一张日志表记录已消费的消息编号</li>\n</ul>\n</li>\n</ul>\n<h3>5.2 利用分布式服务打造可复用平台</h3>\n<ul>\n<li><strong>纵向拆分</strong>：将大应用拆分为小应用</li>\n<li><strong>横向拆分</strong>：将复用应用拆分独立为分布式服务</li>\n<li><strong>Web Service</strong>：服务提供者通过WSDL(Web服务描述语言)向注册中心描述自身提供的服务接口属性，注册中心使用UDDI（统一描述、发现和集成）发布服务提供者提供的服务，服务请求者从注册中心检索到服务后通过SOAP（简单对象访问协议）和服务提供者通信，使用相关服务</li>\n</ul>\n<h2>六、网站的安全架构</h2>\n<h3>6.1 网站的攻击与防御</h3>\n<h4>6.1.1 XSS攻击</h4>\n<ul>\n<li><strong>XSS攻击</strong>：即跨站点脚本攻击，指黑客通过篡改网页，恶意注入HTML脚本，在用户浏览网页时控制用户浏览器进行恶意操作的一种攻击方式。分为两种：一种是反射型，攻击者诱使用户点击一个嵌入恶意脚本的链接达到攻击的目的；另一种是持久性XSS攻击，黑客提交含有恶意脚本的请求，保存在被攻击站点的数据库中，用户浏览网页时，恶意脚本包含在正常页面中达到攻击目的</li>\n<li><strong>防御手段</strong></li>\n<li>消毒：对某些HTML危险字符转义，如‘>’</li>\n<li>HttpOnly：浏览器禁止页面JS访问带有HttpOnly的Cookie，可用防止攻击者窃取Cookie</li>\n</ul>\n<h4>6.1.2 注入攻击</h4>\n<ul>\n<li><strong>注入攻击</strong>：分为SQL注入和OS注入攻击</li>\n<li><strong>防御手段</strong></li>\n<li>消毒：通过正则匹配过滤掉请求中可能注入的SQL语句，如“drop table”</li>\n<li>参数绑定：攻击者的注入SQL会被当成参数，而不是SQL命令被执行</li>\n</ul>\n<h4>6.1.3 CSRF攻击</h4>\n<ul>\n<li><strong>CSRF</strong>：跨站点请求伪造，利用浏览器Cookie或者服务器Session策略盗取用户身份进行非法操作</li>\n<li><strong>防御手段</strong></li>\n<li>表单token</li>\n<li>验证码</li>\n<li>Referer check：HTTP请求的Referer记录着请求来源，可通过检查来源验证是否合法</li>\n</ul>\n<h4>6.1.4 其他攻击和漏洞</h4>\n<ul>\n<li><strong>Error Code</strong>：通过制造非法输入，得到异常信息，从而寻找漏洞进行攻击。防御方法是跳转500页面到专门的错误页面</li>\n<li><strong>HTML注释</strong>：若将代码使用HTML注释语法进行注释显示在页面会给黑客造成攻击便利</li>\n<li><strong>文件上传</strong>：如果上传的是可执行程序会通过上传获得服务器的执行能力。防御方法是设置上传白名单，只允许上传可靠的文件</li>\n<li><strong>拒绝服务攻击（DoS）</strong>：目的使电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其他用户无法访问</li>\n</ul>\n<h4>6.1.5 Web应用防火墙</h4>\n<ul>\n<li><strong>ModSecurity</strong>：开源的Wen应用防火墙，采用处理逻辑和攻击规则集合分离的架构模式，处理逻辑负责请求和响应的拦截过滤，攻击规则集合负责对具体攻击定义、识别、防御策略等功能，攻击规则集合需要不断针对漏洞进行升级</li>\n<li><strong>网站安全漏洞扫描</strong>：根据内置规则，模拟攻击行为发现网站安全漏洞</li>\n</ul>\n<h3>6.2 加密技术及密钥安全管理</h3>\n<ul>\n<li><strong>单向散列加密</strong>：通过对不同输入长度的信息进行散列计算得到固定长度的输出，这个计算过程是单向的，不能对固定长度的输出进行计算从而获得输入信息，常见的如MD5、SHA。为了加强散列计算的安全性，还会给散列计算加salt值</li>\n<li><strong>对称加密</strong>：加密解密使用同一个密钥，常见的有RC算法、DES算法</li>\n<li><strong>分对称加密</strong>：加密解密的密钥不是同意密钥，用公钥加密的私钥才能解开，私钥加密公钥才能解开，常见的有RSA算法。HTTPS中浏览器使用的数字证书实质上是经过权威认证的非对称加密公钥</li>\n</ul>\n<h3>6.3 信息过滤与反垃圾</h3>\n<ul>\n<li><strong>文本匹配</strong>：网站维护一份敏感词表，如果用户发表的信息有敏感词进行消毒处理（将敏感词转为***）或拒绝发表。如果信息很短可用使用正则表达式，如果信息很长，一般算法是基于Trie树算法</li>\n<li><strong>分类算法</strong>：使用贝叶斯分类算法</li>\n<li><strong>黑名单</strong>：一般场景下通过Hash表，在对过滤需求不精确的情况下可以使用布隆过滤器。布隆过滤器使用一个二进制数组和一组随机数映射函数实现，当要加入黑名单时，将用户名使用随机映射函数得到若干随机数，然后将二进制数组对应随机数下标设为1，当要检查是否在黑名单时，使用同样的映射函数得到随机数，检查二进制数组随机数下标是否为1</li>\n</ul>\n<h2>七、分布式系统架构</h2>\n<h3>7.1 分布式锁的实现</h3>\n<ul>\n<li><strong>分布式锁</strong>：在单机场景下，可以使用语言的内置锁来实现进程同步，但是在分布式场景下，需要同步的进程可能位于不同的节点，就需要使用分布式锁。阻塞锁通常使用互斥量来实现：互斥量为0表示有其他进程正在使用锁，此时处于锁定状态；互斥量为1表示未锁定状态</li>\n<li><strong>数据库的唯一索引</strong>：获得锁时向表中插入一条记录，释放锁时删除这条记录，唯一索引可以保证该记录只被插入依次，那么就可以用这个记录是否存在来判断是否处于锁定状态。存在以下问题：</li>\n<li>锁没有失效时间，解锁失败的话其他进程无法再获得锁</li>\n<li>只能是非阻塞锁，插入失败直接报错，无法重试</li>\n<li>不可重入，已经获得锁的进程也必须重新获取锁</li>\n<li><strong>Redis的SETNX指令</strong>：使用SETNX指令插入一个键值对，若key已存在会返回false，否则插入成功返回true。SETNX指令和数据库的唯一索引类似，保证只存在一个Key的键值对，可以通过用一个Key的键值对是否存在来判断是否处于锁定状态。EXPIRE指令可以为一个键值对设置过期时间从而避免数据库唯一索引实现方式中释放锁失败的问题</li>\n<li><strong>Redis的RedLcok算法</strong>：使用多个实例来实现分布式锁，这是为了保证在发生单点故障时依然可用</li>\n<li>尝试从N个相互独立的Redis实例获取锁</li>\n<li>计算获取锁消耗的时间，只有当这个时间小于锁的过期时间，并且从大多数(N/2+1)实例上获取了锁，就认为锁获取成功了</li>\n<li>如果锁获取失败，就到每个实例上获取锁</li>\n<li><strong>Zookeeper的有序节点</strong></li>\n<li><strong>Zookeeper的抽象模型</strong>：Zookeepeer提供了一种属性结构级的命名空间，/app1/p_1节点的父节点为/app1</li>\n<li><strong>节点类型</strong><ul>\n<li>永久节点：不会因为会话结束或超时而消失</li>\n<li>临时节点：如果会话结束就消失</li>\n<li>有序节点：会在节点名后面加数字后缀，并且是有序的，例如生成的有序节点为/lock/node-000000，它的下一个有序节点为/lcok/node-000001</li>\n</ul>\n</li>\n<li><strong>监听器</strong>：为一个节点注册监听器，在节点状态发生改变时会向客户端发送消息</li>\n<li><strong>分布式锁实现</strong><ul>\n<li>创建一个锁目录/lock</li>\n<li>当一个客户端需要获取锁时，在/lock下创建临时的有序子节点</li>\n<li>客户端获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直到获取锁</li>\n<li>执行业务代码，完成后，删除对应的子节点</li>\n</ul>\n</li>\n<li><strong>会话超时</strong>：如果一个已经获得锁的会话超时了，因为创建的是一个临时节点，所有该临时节点会被删除，其他会话节点就可以获得锁了，因此不会出现数据库的唯一索引实现的分布式锁的释放锁失败问题</li>\n<li><strong>羊群效应</strong>：一个节点未获得锁，只需要监听自己的前一个节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其他所有子节点都会受到通知，而我们只希望它的后一个子节点收到通知</li>\n</ul>\n<h3>7.2 分布式事务</h3>\n<ul>\n<li><strong>本地消息表</strong>：本地消息表和业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性</li>\n<li>在分布式事务操作的以访完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定被写入本地消息表中</li>\n<li>之后将本地消息表中的消息转发到Kafka等消息队列中，如果转发成功则将消息从本地消息列表中删除，否则继续重新转发</li>\n<li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作</li>\n<li><strong>2PC（两阶段提交）</strong>：引入协调者来协调参与者的行为，并最终决定这些参与者是否要真正执行事务</li>\n<li><strong>运行过程</strong><ul>\n<li>准备阶段：协调者询问参与者事务是否执行成功，参与者发回事务执行结果</li>\n<li>提交阶段：如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务</li>\n</ul>\n</li>\n<li><strong>存在的问题</strong><ul>\n<li>同步阻塞：所有事物参与者在等待其他参与者响应的时候都处于同步阻塞状态，无法进行其他操作</li>\n<li>单点问题：协调者在2PC中起到非常大的作用，发生故障会造成很大影响，特别是阶段二发生故障，所有参与者会一直等待</li>\n<li>数据不一致：在阶段二，如果协调者只发送了部分commit消息，此时网络发生异常，那么只要部分参与者收到commit消息，也就是说只有部分参与者提交了事物，使系统数据不一致</li>\n<li>太过保守：任意一个节点失败会导致整个事物失败，没有完善的容错机制</li>\n</ul>\n</li>\n</ul>\n<h3>7.3 BASE</h3>\n<ul>\n<li><strong>BASE</strong>：是基本可用（BA）、软状态（S）、最终一致性（E）的缩写，BASE理论是对CAP中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但是每个应用可用根据自身的业务特点采用释放的方法来使系统达到最终一致性</li>\n<li><strong>基本可用</strong>：指分布式系统出现的故障时，保证核心可用，允许损失部分可用性</li>\n<li><strong>软状态</strong>：指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延</li>\n<li><strong>最终一致性</strong>：强调系统中的所有数据副本，在经过一段时间后，最终达到一致的状态。ACID强调强一致性，通常用在传统的关系数据库系统上，而BASE要求最终一致性来达到可用性，通常用在大型分布式系统。在实际的分布式场景中，不同的业务单元和组件对一致性的要求是不同的，因此ACID和BASE常常配合在一起使用</li>\n</ul>\n<h3>7.4 Paxos</h3>\n<ul>\n<li><strong>Paxos</strong>：用于达成共识性问题，即多个节点产生的值，该算法能保证只选出唯一一个值，主要有三类节点：</li>\n<li>提议者：提议一个值</li>\n<li>接受者：对每个提议进行投票</li>\n<li>告知者：被告知投票的结果，不参与投票</li>\n<li><strong>执行过程</strong>：规定一个提议包含两个字段：[n,v]，n为具有唯一性的序号，v为提议值</li>\n<li>Prepare阶段：提议者向接受者发送提议[n1,v1]，如果接受着是首次收到提议，则发送一个Prepare响应，设置当前接收到的提议[n1,v1]。若不是首次收到提议，则比较当前收到的提议的n1与收到的提议n2比较，如果n2大于n1，则发送[n2,v2]的Prepare响应并将当前收到的提议改为[n2,v2]，否则抛弃该提议请求</li>\n<li>Accpet阶段：当提议者收到一半以上的接受者的Prepare响应时，就可以发送Accpet请求</li>\n<li>Learn阶段：接受者收到Accept请求时，如果序号大于等于该接受者承诺的最小序号，就发送Learn提议给所有的告知者，当告知者发现有大多数的接受者接受了某个提议，那么该提议的提议值就被Paxos选择出来</li>\n<li><strong>约束条件</strong></li>\n<li><strong>正确性</strong>：只有一个提议值会生效</li>\n<li><strong>可终止性</strong>：指最后总有一个提议生效</li>\n</ul>\n<h3>7.5 Raft</h3>\n<ul>\n<li><strong>Raft</strong>：也是分布式一致协议，主要用来竞选主节点</li>\n<li><strong>单个Candidate的竞选</strong>：有三种节点：Follower、Candidate和Leader。Leader会周期性的发送心跳包给Follower，每个Follower都设置一个随机的竞选超时时间，一般为150ms-300ms，如果这个时候没有收到Leader的心跳包，就会变成Candidate，进入竞选状态。单个候选者节点竞选时，会发送投票信息给所有其他节点，如果收到超过一半节点的回复，该候选节点就变为Leader，之后Leader会周期性发送心跳包给Folower，Follower收到心跳包会重新计时</li>\n<li><strong>多个Candidate竞选</strong>：如果有多个Follower称为Cadidate，并且获得票数相同，就需要重新投票，由于每个节点设置的随机竞选超时时间不同，因此下一次再次出现多个Cadidate并获取同样票数的概率很低</li>\n<li><strong>数据同步</strong>：来自客户端的修改会被传入Leader，Leader将修改复制给所有Follower并等待大多数Follower进行了修改之后将修改提交，然后通知所有Follower让它们也提交，此时所有节点的值达成一致</li>\n</ul>\n', 1, '设计大型网站高可用性、高伸缩性、高一致性的原理', 'Architecture', '大型网站设计原理', 0, 6, 5);

INSERT INTO blog_comment VALUES (1, 3);
INSERT INTO blog_comment VALUES (1, 7);
INSERT INTO blog_comment VALUES (1, 13);
INSERT INTO blog_comment VALUES (2, 2);
INSERT INTO blog_comment VALUES (2, 6);
INSERT INTO blog_comment VALUES (2, 12);
INSERT INTO blog_comment VALUES (3, 1);
INSERT INTO blog_comment VALUES (3, 5);
INSERT INTO blog_comment VALUES (3, 11);
INSERT INTO blog_comment VALUES (4, 4);
INSERT INTO blog_comment VALUES (4, 10);
INSERT INTO blog_comment VALUES (5, 9);
INSERT INTO blog_comment VALUES (6, 8);

INSERT INTO blog_vote VALUES (1, 1);
INSERT INTO blog_vote VALUES (2, 2);
INSERT INTO blog_vote VALUES (3, 3);
INSERT INTO blog_vote VALUES (4, 4);
INSERT INTO blog_vote VALUES (5, 5);
INSERT INTO blog_vote VALUES (6, 6);